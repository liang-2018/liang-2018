<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java连接neo4j及自定义查询返回格式]]></title>
    <url>%2F2019%2F05%2F25%2Fneo4j-result-customize%2F</url>
    <content type="text"><![CDATA[由于neo4j不像mysql一样有固定的字段，同时也因为neo4j不如mysql使用那么频繁，公开的工具类比较稀少。因而不得不自定义其结果返回格式。 一、apache的HttpClient方式请求数据(有注入风险) 使用Apache的HttpClient进行查询，由于查询方式是直接输入执行的cypher字符串，弄不好有注入风险，这就像mybatis中使用$ 取值有注入风险一样，至少我当前理解是这样。 需要使用的jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.7&lt;/version&gt;&lt;/dependency&gt; 连接方式及数据返回格式选择 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.liang.neo4j;import org.apache.http.auth.AuthScope;import org.apache.http.auth.UsernamePasswordCredentials;import org.apache.http.client.CredentialsProvider;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.BasicCredentialsProvider;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;public class HttpClientConnection &#123; // 对应的连接url private static String url = "http://localhost:7474/db/data/transaction/commit"; private static CredentialsProvider credsProvider = null; private static CloseableHttpClient httpClient = null; static &#123; credsProvider = new BasicCredentialsProvider(); credsProvider.setCredentials( new AuthScope("localhost", 7474), new UsernamePasswordCredentials("username", "passwd"));//设置对应的用户名和密码 httpClient = HttpClients.custom().setDefaultCredentialsProvider(credsProvider).build(); &#125; /** * execute the cypher only if the cypher grammar is OK * Attention: this method to access database is not suggested(at least from my perspective) since the * danger of injection might occur, at the same time, the format of result is specified which means extra * deal with result is almost impossible. * this method executed by http post * @param executeString the cypher sentence * @return the string json result */ public static String httpExecute(String executeString) &#123; StringEntity s = new StringEntity("&#123;\n" + " \"statements\" : [ &#123;\n" + " \"statement\" : \""+ executeString+"\"\n" + " &#125; ]\n" + "&#125;","UTF-8"); s.setContentEncoding("UTF-8"); s.setContentType("application/json");//发送json数据需要设置contentType HttpPost httppost = new HttpPost(url); httppost.setEntity(s); httppost.addHeader("Content-Type", "application/json"); httppost.addHeader("charset", "UTF-8"); CloseableHttpResponse response = null; //获取结果 String respString = ""; try &#123; response = httpClient.execute(httppost); // 注意，如果结果中有中文，不表明编码格式可能会乱码 respString = EntityUtils.toString(response.getEntity(),"UTF-8"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return respString; &#125; public static void main(String[] args) &#123; String str = httpExecute("MATCH (n:State) RETURN n LIMIT 5"); System.out.println(str); &#125;&#125; 返回结果如下： 1&#123;"results":[&#123;"columns":["n"],"data":[&#123;"row":[&#123;"ChineseName":"阿肯色","name":"Arkansas","Code":"AR"&#125;],"meta":[&#123;"id":191954,"type":"node","deleted":false&#125;]&#125;,&#123;"row":[&#123;"ChineseName":"阿拉巴马","name":"Alabama","Code":"AL"&#125;],"meta":[&#123;"id":191958,"type":"node","deleted":false&#125;]&#125;,&#123;"row":[&#123;"ChineseName":"阿拉斯加","name":"Alaska","Code":"AK"&#125;],"meta":[&#123;"id":191962,"type":"node","deleted":false&#125;]&#125;,&#123;"row":[&#123;"ChineseName":"爱达荷","name":"Idaho","Code":"ID"&#125;],"meta":[&#123;"id":191966,"type":"node","deleted":false&#125;]&#125;,&#123;"row":[&#123;"ChineseName":"爱荷华","name":"Iowa","Code":"IA"&#125;],"meta":[&#123;"id":191979,"type":"node","deleted":false&#125;]&#125;]&#125;],"errors":[]&#125;&#123;"results":[&#123;"columns":["n"],"data":[&#123;"row":[&#123;"ChineseName":"美国","code":"USA"&#125;],"meta":[&#123;"id":49961,"type":"node","deleted":false&#125;]&#125;]&#125;],"errors":[]&#125; 二、使用neo4j的GraphDatabase驱动连接 使用到的jar包 123456 &lt;!-- https://mvnrepository.com/artifact/org.neo4j.driver/neo4j-java-driver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.neo4j.driver&lt;/groupId&gt; &lt;artifactId&gt;neo4j-java-driver&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt; 连接neo4j数据库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.kg.database;import org.neo4j.driver.v1.*;import java.io.IOException;public class Neo4jUtil &#123; /** * @time:2019年3月3日 下午4:53:54 * @description:执行对应的cypher语句并返回json形式数据 */ private static String uri="Bolt://localhost:7687"; //后续可能要考虑添加自动关闭连接时长的设置，避免无用连接长时间保留，在config（GraphDatabase.driver可有Config参数选项）中设置 private static Driver driver = GraphDatabase.driver(uri, AuthTokens.basic("username","passwd")); /** * execute cypher with value for pre-compiling which helps avoid * dangerous cypher injection attacks and improves database performance as * Neo4j can re-use query plans more often. * the Transaction(success, failure) is not used now * @param sentence cypher sentence * @param objects params to replace sign "?" for pre-compiling * @return return "succeed" when the transaction proceeded with no exception */ public static String execute(String sentence, Object... objects) &#123; Value value = Values.parameters(objects); try (Session session = driver.session()) &#123; String result = session.writeTransaction((Transaction tx)-&gt; &#123; tx.run(sentence, value); return "succeed"; &#125;); System.out.println(result); session.close(); return result; &#125; &#125; /** * the run() method is as the same as the method run() in previous execute() * @param sentence * @param objects the params to * @return */ public static StatementResult query(String sentence, Object... objects)&#123; StatementResult result; Value value = Values.parameters(objects); try(Session session = driver.session())&#123; result = session.run(sentence, value); &#125; return result; &#125; /** * close the connection */ public static void close()&#123; driver.close(); &#125; public static void main(String[] args) &#123; StatementResult result = Neo4jUtil.query("MATCH (n:Person) RETURN n LIMIT 25"); System.out.println(result); close(); &#125; &#125; 执行cypher语句代码说明 如果在使用mysql数据库的时候有用过dbutils的话，看到这样的参数注入方式还是比较亲切的。 12345678910111213141516171819&gt; public static Value parameters( Object... keysAndValues )&gt; &#123;&gt; if ( keysAndValues.length % 2 != 0 )&gt; &#123;&gt; throw new ClientException( "Parameters function requires an even number " +&gt; "of arguments, " +&gt; "alternating key and value. Arguments were: " +&gt; Arrays.toString( keysAndValues ) + "." );&gt; &#125;&gt; HashMap&lt;String,Value&gt; map = newHashMapWithSize( keysAndValues.length / 2 );&gt; for ( int i = 0; i &lt; keysAndValues.length; i += 2 )&gt; &#123;&gt; Object value = keysAndValues[i + 1];&gt; assertParameter( value );&gt; map.put( keysAndValues[i].toString(), value( value ) );&gt; &#125;&gt; return value( map );&gt; &#125;&gt; &gt; 不过和dbutils还是有些不同的，dbutil按照顺序将需要设置的参数按照顺序建立一个数组就好，因为在mysql中，sql语句的占位符全是“?”，但是在cypher中的占位符则不同 123&gt; MATCH (n:Student) where n.name=$name and n.age=$age return n&gt; MATCH (n1:Student),(n2:Student) where n1.name=$param1 and n2.name=$parm2 return n&gt; &gt; 通过查看源码不难知道，此处是通过Map来进行注入参数的。所以如果，如果在书写cql语句的时候，$符号后的参数名，如果值不是一样，务必书写成不同的单词。 实际上，也支持其他方式的生成参数,因为有如下代码，但是，我当前只用到这个（因为官网的demo使用Values.parameters方法），所以，虽然知道有这些方式，但是具体怎么用，尚未来得及去探究（等哪天导师大大放我几天假，我再泡一泡这些源码）。 123456789101112131415&gt; public static Value value( Object value )&gt; &#123;&gt; if ( value == null ) &#123; return NullValue.NULL; &#125;&gt; ...................&gt; if ( value instanceof Period ) &#123; return value( (Period) value ); &#125;&gt; if ( value instanceof Duration ) &#123; return value( (Duration) value ); &#125;&gt; if ( value instanceof Point ) &#123; return value( (Point) value ); &#125;&gt; &gt; if ( value instanceof List&lt;?&gt; ) &#123; return value( (List&lt;Object&gt;) value ); &#125;&gt; if ( value instanceof Map&lt;?,?&gt; ) &#123; return value( (Map&lt;String,Object&gt;) value ); &#125;&gt; if ( value instanceof Iterable&lt;?&gt; ) &#123; return value( (Iterable&lt;Object&gt;) value ); &#125;&gt; if ( value instanceof Iterator&lt;?&gt; ) &#123; return value( (Iterator&lt;Object&gt;) value ); &#125;&gt; if ( value instanceof Stream&lt;?&gt; ) &#123; return value( (Stream&lt;Object&gt;) value ); &#125;&gt; ..................&gt; 三、自定义返回数据格式详细代码，看文末。 neo4j数据类型及关联 在手撕代码之前，我们有必要了解下，驱动中对结果的封装方式与依赖关系（接口实现主要在org.neo4j.driver.internal包里面） 大致关系是：StatementResult中包含Record(类似mysql中的行)，Record可以获取包含的Value,Value有多种可能：Node, Relationship,Path,String.所以，具体解析，要根据cypher语句中return 部分的内容。就如写msyql查询时，要根据select后的字段来书写对应的java bean。 各数据类型查看及解析方式1、(Internal)StatementResult keys() 返回的就是 cypher语句中return 后面的内容，勉强当做列的字段名吧。 hasNext() 是否有下一条数据 next() 返回下一条Record，并将游标下移 single() 返回结果中的第一条Record，如果结果中一条数据都没有，则抛出异常NoSuchRecordException peek() 返回下一条Record，但是游标不移动，Asynchronously investigate the next upcoming {@link Record} without moving forward in the result stream() 没用到过，以数据流返回结果？ list() 以List的方式返回所有Record，以便能够多次遍历结果，不过这个方法使用时，一定得在确保数据量有限（别太多）的情况下使用，否则会造成内存不足。 12345&gt; Note that this method can only be used if you know that the statement that&gt; * yielded this result returns a finite stream. Some statements can yield&gt; * infinite results, in which case calling this method will lead to running&gt; * out of memory.&gt; &gt; List list( Function mapFunction ) 自定义返回Record的方式，这个比较好玩，后面可以利用这个考虑仿照dbutils写一个工具类。其最终调用为： 12345678&gt; List&lt;T&gt; result = new ArrayList&lt;&gt;( records.size() );&gt; while ( !records.isEmpty() )&gt; &#123;&gt; Record record = records.poll();&gt; result.add( mapFunction.apply( record ) );&gt; &#125;&gt; return result;&gt; &gt; consume() summary() 二者都是总结结果的情况，如运行的类型、已执行的更新的数量与类型、查询计划和分析信息等。目前没用到过，不同的是，调用前者后，所有记录都用尽，无法再使用。后者则不会。 remove() emmm，这个嘛，主要接口里面有，不得不实现下。没有用也不能用的方法。因为： 123456&gt; @Override&gt; public void remove()&gt; &#123;&gt; throw new ClientException( "Removing records from a result is not supported." );&gt; &#125;&gt; 2、(Internal)Record 123456789&gt; // InternalRecord 初始化时，就初始化了keys和values&gt; private final List&lt;String&gt; keys;&gt; private final Value[] values;&gt; public InternalRecord( List&lt;String&gt; keys, Value[] values )&gt; &#123;&gt; this.keys = keys;&gt; this.values = values;&gt; &#125;&gt; &gt; keys() 和StatementResult里面一样 values() 获取Record中的所有Value，并以List返回。 返回List的长度，和cytpher语句有关 123&gt; match (n:Student) return n limit 25 // List长度,为1，包含的为n节点&gt; match (n:Student),p=(n)-[r:has_friend]-&gt;() return p,n //List长度为2，第一个为p,第二个为n&gt; &gt; fields() 将Record封装，返回为List]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>neo4j</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode note - part 4]]></title>
    <url>%2F2019%2F05%2F03%2FLeetCode-note-part-4%2F</url>
    <content type="text"><![CDATA[LeetCode 刷题笔记 4 166. Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: 123&gt; Input: numerator = 1, denominator = 2&gt; Output: &quot;0.5&quot;&gt; &gt; Example 2: 123&gt; Input: numerator = 2, denominator = 1&gt; Output: &quot;2&quot;&gt; &gt; Example 3: 123&gt; Input: numerator = 2, denominator = 3&gt; Output: &quot;0.(6)&quot;&gt; 此题关键在于一个知识点：能写成分数的都是有理数，有理数要么是有限的，要么是无限循环小数 为避免溢出，使用long https://www.cnblogs.com/grandyang/p/4238577.html 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public String fractionToDecimal(int numerator, int denominator) &#123; if(denominator==0) return "NaN"; if(numerator==0) return "0"; StringBuilder sb=new StringBuilder(); Boolean sign=(numerator&gt;=0)^(denominator&gt;=0);//都为正和都为负的时候为false，不需加负号 if(sign) sb.append('-'); long n=Math.abs((long)numerator);//int征服转换有可能溢出 long d=Math.abs((long)denominator); long m = n / d; //整数部分的商 long r= n - m * d; // 余数 sb.append(m); if(r == 0)&#123; return sb.toString(); &#125; sb.append("."); r = r * 10; Map&lt;Long, Integer&gt; map = new HashMap(); map.put(r, sb.length()); while(r != 0)&#123; m = r / d; r = r - m * d; sb.append(m); r = r * 10; if(map.containsKey(r))&#123; sb.append(')'); sb.insert((int)map.get(r), '(');//StringBuilder的insert方法 break; &#125;else&#123; map.put(r, sb.length()); &#125; if(r == 0)&#123; return sb.toString(); &#125; &#125; return sb.toString(); &#125; &#125; 使用两个StringBuilder 不用操心插入括号的位置了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public String fractionToDecimal(int numerator, int denominator) &#123; return fractionToDecimal2(numerator, denominator); &#125; public String fractionToDecimal2(long numerator, long denominator) &#123; StringBuilder sb1 = new StringBuilder(); if (numerator&lt;0&amp;&amp;denominator&gt;0) &#123; sb1.append("-"); numerator = -numerator; &#125; else if(numerator&gt;0&amp;&amp;denominator&lt;0) &#123; sb1.append("-"); denominator = -denominator; &#125; if(numerator&lt;0&amp;&amp;denominator&lt;0) &#123; numerator = -numerator; denominator = -denominator; &#125; sb1.append( numerator/denominator ); if(numerator%denominator==0) return sb1.toString(); sb1.append("."); numerator %= denominator; while(numerator!=0&amp;&amp;denominator%2==0||denominator%5==0) &#123; if(denominator%10==0) denominator /= 10; else if(denominator%2==0) &#123; denominator /= 2; numerator *= 5; &#125; else &#123; denominator /= 5; numerator *= 2; &#125; sb1.append(numerator/denominator); numerator %= denominator; &#125; if(numerator%denominator==0) return sb1.toString(); numerator %= denominator; long reminder = numerator; StringBuilder sb2 = new StringBuilder(); while(true) &#123; reminder *= 10; sb2.append(reminder/denominator); reminder = reminder%denominator; if(reminder%denominator==0||reminder==numerator) break; &#125; if(reminder%denominator==0) return sb1.append(sb2).toString(); else return sb1.append("(").append(sb2).append(")").toString(); &#125; &#125; 167. Two Sum II - Input array is sorted Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 1234&gt; Input: numbers = [2,7,11,15], target = 9&gt; Output: [1,2]&gt; Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.&gt; 123456789101112131415161718class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int left = 0; int right = numbers.length - 1; while(left &lt; right)&#123; int addup = numbers[left] + numbers[right]; if(addup == target)&#123; return new int[]&#123;left + 1, right + 1&#125;; &#125; if(addup &gt; target)&#123; right --; &#125;else&#123; left ++; &#125; &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 168. Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 123456789&gt; 1 -&gt; A&gt; 2 -&gt; B&gt; 3 -&gt; C&gt; ...&gt; 26 -&gt; Z&gt; 27 -&gt; AA&gt; 28 -&gt; AB &gt; ...&gt; &gt; Example 1: 123&gt; Input: 1&gt; Output: &quot;A&quot;&gt; &gt; Example 2: 123&gt; Input: 28&gt; Output: &quot;AB&quot;&gt; &gt; Example 3: 123&gt; Input: 701&gt; Output: &quot;ZY&quot;&gt; 10进制转26进制，不过由于10进制是从0到9，而 26进制是从’A’ ~ ‘Z’，由于 1 对应 A，但是没有字母对应数字 0，需要对数值进行预处理（减一处理） 123456789101112class Solution &#123; public String convertToTitle(int n) &#123; StringBuilder sb = new StringBuilder(); while(n &gt; 0)&#123; n --; // 减一处理， sb.append((char) (n % 26 + 'A')); n = n / 26; &#125; return sb.reverse().toString(); &#125;&#125; 169. Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: 123&gt; Input: [3,2,3]&gt; Output: 3&gt; &gt; Example 2: 123&gt; Input: [2,2,1,1,1,2,2]&gt; Output: 2&gt; 偷鸡法，排序然后去中间那个那个。实际上排序需要的时间复杂度是 (nlogn) 123456class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length / 2]; &#125;&#125; 正儿八经计数 ：从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个 123456789101112131415161718class Solution &#123; public int majorityElement(int[] nums) &#123; int majority = nums[0]; int count = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(majority == nums[i])&#123; count ++; &#125;else&#123; count --; if(count == 0)&#123; majority = nums[ i + 1]; &#125; &#125; &#125; return majority; &#125;&#125; 172. Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Example 1: 1234&gt; Input: 3&gt; Output: 0&gt; Explanation: 3! = 6, no trailing zero.&gt; &gt; Example 2: 1234&gt; Input: 5&gt; Output: 1&gt; Explanation: 5! = 120, one trailing zero.&gt; &gt; Note: Your solution should be in logarithmic time complexity. 由于是阶乘，所以0在乘积后面且连续的，故而分解可得 x $10^y$ ,也即 x $2^y * 5^y$,由于阶乘分解后 2的个数远多于5的个数，所以 0 的个数，取决于分解后 5 的个数。 12345678910class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n &gt;= 5)&#123; count += n / 5; n = n / 5; &#125; return count; &#125;&#125; 123456class Solution &#123; public int trailingZeroes(int n) &#123; if( n &lt; 5 )return 0; return n / 5 + trailingZeroes(n / 5); &#125;&#125; 错误想法，一来不符合题目时间要求，二来考虑不够周全 123456789class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; for(int i = 1; i &lt;= n; i ++)&#123; if(i % 5 == 0)count ++; // 遇到数字 25 625之类的数值就会出现错误 &#125; return count; &#125;&#125; 173. Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example: 1234567891011&gt; BSTIterator iterator = new BSTIterator(root);&gt; iterator.next(); // return 3&gt; iterator.next(); // return 7&gt; iterator.hasNext(); // return true&gt; iterator.next(); // return 9&gt; iterator.hasNext(); // return true&gt; iterator.next(); // return 15&gt; iterator.hasNext(); // return true&gt; iterator.next(); // return 20&gt; iterator.hasNext(); // return false&gt; &gt; Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called. 通过数组通过 后 中 前 存储所有的数据，用来遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class BSTIterator &#123; private Object[] data; private int size; public BSTIterator(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack(); TreeNode pre = null; List&lt;Integer&gt; result = new ArrayList(); while(root!=null||!stack.empty())&#123; while(root!=null)&#123; stack.add(root); root=root.right; &#125; root=stack.peek(); result.add(root.val); stack.pop(); root=root.left; &#125; data = result.toArray(); size = data.length; &#125; /** @return the next smallest number */ public int next() &#123; return (int)data[size -- - 1]; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return size &gt; 0; &#125;&#125;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ 最快捷的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class BSTIterator &#123; private ArrayList&lt;Integer&gt; order = new ArrayList&lt;&gt;(); private int currIdx; private int size; public BSTIterator(TreeNode root) &#123; inOrder(root); currIdx = -1; size = order.size(); &#125; /** @return the next smallest number */ public int next() &#123; if (hasNext()) return order.get(++currIdx); return -1; // 表示不存在下一个元素 &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return currIdx &lt; size - 1; &#125; private void inOrder(TreeNode root) &#123; if (root == null) return ; inOrder(root.left); order.add(root.val); inOrder(root.right); &#125; &#125;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ 189. Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: 1234567&gt; Input: [1,2,3,4,5,6,7] and k = 3&gt; Output: [5,6,7,1,2,3,4]&gt; Explanation:&gt; rotate 1 steps to the right: [7,1,2,3,4,5,6]&gt; rotate 2 steps to the right: [6,7,1,2,3,4,5]&gt; rotate 3 steps to the right: [5,6,7,1,2,3,4]&gt; &gt; Example 2: 123456&gt; Input: [-1,-100,3,99] and k = 2&gt; Output: [3,99,-1,-100]&gt; Explanation: &gt; rotate 1 steps to the right: [99,-1,-100,3]&gt; rotate 2 steps to the right: [3,99,-1,-100]&gt; &gt; Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? 12345678910111213141516class Solution &#123; public void rotate(int[] nums, int k) &#123; int length = nums.length; k = k % length; revert(nums, 0, length - 1);//整体翻转 revert(nums, 0, k - 1);//前面k个数翻转 revert(nums, k, length - 1);//后面length - k个数翻转 &#125; private void revert(int[] nums, int start, int end)&#123; while(start &lt; end)&#123; int tmp = nums[start]; nums[start ++] = nums[end]; nums[end --] = tmp; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * 循环交换 * 时间复杂度：O(n) * 空间复杂度：O(1) */ public void rotate_3(int[] nums, int k) &#123; int n = nums.length; k %= n; // 第一次交换完毕后，前 k 位数字位置正确，后 n-k 位数字中最后 k 位数字顺序错误，继续交换 for (int start = 0; start &lt; nums.length &amp;&amp; k != 0; n -= k, start += k, k %= n) &#123; for (int i = 0; i &lt; k; i++) &#123; swap(nums, start + i, nums.length - k + i); &#125; &#125; &#125; /** * 递归交换 * 时间复杂度：O(n) * 空间复杂度：O(n/k) */ public void rotate(int[] nums, int k) &#123; // 原理同上 recursiveSwap(nums, k, 0, nums.length); &#125; private void recursiveSwap(int[] nums, int k, int start, int length) &#123; k %= length; if (k != 0) &#123; for (int i = 0; i &lt; k; i++) &#123; swap(nums, start + i, nums.length - k + i); &#125; recursiveSwap(nums, k, start + k, length - k); &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 187. Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: 1234&gt; Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;&gt; &gt; Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]&gt; 1234567891011class Solution &#123; public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); Set&lt;String&gt; help = new HashSet&lt;&gt;(); for(int i = 0; i &lt;= s.length()-10; i++)&#123; String cur = s.substring(i, i+10); if(!set.add(cur)) help.add(cur); &#125; return new ArrayList&lt;String&gt;(help); &#125;&#125; 190. Reverse Bits Reverse bits of a given 32 bits unsigned integer. Example 1: 1234&gt; Input: 00000010100101000001111010011100&gt; Output: 00111001011110000010100101000000&gt; Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.&gt; &gt; Example 2: 1234&gt; Input: 11111111111111111111111111111101&gt; Output: 10111111111111111111111111111111&gt; Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.&gt; &gt; Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825. 123456789101112public class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int res = 0; for(int i = 0; i &lt; 32; i++)&#123; res = (res &lt;&lt; 1) | (n &amp; 0x01); //res = (res &lt;&lt; 1) ^ (n &amp; 0x01); n = n &gt;&gt; 1; &#125; return res; &#125;&#125; 12345678910public class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int a=0; for(int i=0;i&lt;=31;i++)&#123; a=a+((1&amp;(n&gt;&gt;i))&lt;&lt;(31-i)); &#125; return a; &#125;&#125; 191. Number of 1 Bits Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the Hamming weight). Example 1: 1234&gt; Input: 00000000000000000000000000001011&gt; Output: 3&gt; Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits.&gt; &gt; Example 2: 1234&gt; Input: 00000000000000000000000010000000&gt; Output: 1&gt; Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit.&gt; &gt; Example 3: 1234&gt; Input: 11111111111111111111111111111101&gt; Output: 31&gt; Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits.&gt; &gt; Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3 above the input represents the signed integer -3. 123456789101112public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; while (n != 0) &#123; count++; n &amp;= (n - 1);// n&amp;(n-1)时，正好只有去除最后一个1，当所有的1都去除后，就是0了 &#125; return count; &#125;&#125; 12345678910111213141516171819202122public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; while(n != 0)&#123; count += (n &amp; 0x01); n = n &gt;&gt;&gt; 1; &#125; return count; &#125;&#125;public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; for(int i = 0; i &lt; 32; i++)&#123; count += (n &amp; 0x01); n = n &gt;&gt; 1; &#125; return count; &#125;&#125; awk-192. Word Frequency Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume: words.txt contains only lowercase characters and space &#39; &#39; characters. Each word must consist of lowercase characters only. Words are separated by one or more whitespace characters. Example: Assume that words.txt has the following content: 123&gt; the day is sunny the the&gt; the sunny is is&gt; &gt; Your script should output the following, sorted by descending frequency: 12345&gt; the 4&gt; is 3&gt; sunny 2&gt; day 1&gt; &gt; Note: Don’t worry about handling ties, it is guaranteed that each word’s frequency count is unique. Could you write it in one-line using Unix pipes? 12# Read from the file words.txt and output the word frequency list to stdout.cat words.txt |tr -s ' ' '\n' |sort |uniq -c |sort -r |awk '&#123;print $2" "$1&#125;' 198. House Robber You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 12345&gt; Input: [1,2,3,1]&gt; Output: 4&gt; Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).&gt; Total amount you can rob = 1 + 3 = 4.&gt; &gt; Example 2: 12345&gt; Input: [2,7,9,3,1]&gt; Output: 12&gt; Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).&gt; Total amount you can rob = 2 + 9 + 1 = 12.&gt; 1234567891011121314class Solution &#123; public int rob(int[] nums) &#123; int n = nums.length; if(n == 0) return 0; if(n == 1) return nums[0]; int[] dp = new int[n]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for(int i=2;i&lt;n;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[n-1]; &#125;&#125; 123456789101112131415161718192021222324class Solution &#123; public int rob(int[] nums) &#123; memo = new int[nums.length]; Arrays.fill(memo, -1); return tryRob(nums, 0); &#125; private int tryRob(int[] nums, int index) &#123; if (index &gt;= nums.length) &#123; return 0; &#125; // 记忆化搜索可以避免重叠子问题的重复运算 if (memo[index] != -1) &#123; return memo[index]; &#125; // 下面是对状态转移方程的描述 int res = 0; for (int i = index; i &lt; nums.length; i++) &#123; res = Math.max(res, nums[i] + tryRob(nums, i + 2)); &#125; memo[index] = res; return res; &#125; &#125; 199. Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: 12345678910&gt; Input: [1,2,3,null,5,null,4]&gt; Output: [1, 3, 4]&gt; Explanation:&gt; &gt; 1 &lt;---&gt; / \&gt; 2 3 &lt;---&gt; \ \&gt; 5 4 &lt;---&gt; 题目意思是，只能看到最右边的数字，右边的数字会遮挡遍的数字。 最快能想到的就是用两个栈保存每层的节点，一个从左往右，一个从右往左。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList(); if(null == root)return result; Stack&lt;TreeNode&gt; stack1 = new Stack(); Stack&lt;TreeNode&gt; stack2 = new Stack(); stack1.push(root); while(!(stack1.isEmpty() &amp;&amp; stack2.isEmpty()))&#123; TreeNode last = null; if(!stack1.isEmpty())&#123; result.add(stack1.peek().val); while(!stack1.isEmpty())&#123; last = stack1.pop(); if(last.right != null) stack2.push(last.right); if(last.left != null) stack2.push(last.left); &#125; &#125;else&#123; while(!stack2.isEmpty())&#123; last = stack2.pop(); if(last.left != null) stack1.push(last.left); if(last.right != null) stack1.push(last.right); &#125; result.add(last.val); &#125; &#125; return result; &#125;&#125; 从模型上最符合的方法，每次都优先添加右边的节点(每次下一层的节点都是偏右边的先被遍历到)，如果最右边的节点是当前深度最大的，则为能看到的点。 123456789101112131415161718class Solution &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); int maxdepth=0; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; if(root==null) return list; return right(root,1); &#125; public List&lt;Integer&gt; right(TreeNode root,int depth)&#123; if(depth&gt;maxdepth)&#123; list.add(root.val); maxdepth=depth; &#125; //调换位置可以改变输出顺序 if(root.right!=null) right(root.right,depth+1); if(root.left!=null) right(root.left,depth+1); return list; &#125;&#125; 这个方法其实和双栈的方法差不多。 12345678910111213141516171819202122232425class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int i = queue.size(); for (; i &gt; 0; i--) &#123; if (queue.peek().left != null) &#123; queue.offer(queue.peek().left); &#125; if (queue.peek().right != null) &#123; queue.offer(queue.peek().right); &#125; list.add(queue.poll().val); &#125; result.add(list.get(list.size()-1)); &#125; return result; &#125;&#125; s-dp-200. Number of Islands Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 12345678&gt; Input:&gt; 11110&gt; 11010&gt; 11000&gt; 00000&gt; &gt; Output: 1&gt; &gt; Example 2: 12345678&gt; Input:&gt; 11000&gt; 11000&gt; 00100&gt; 00011&gt; &gt; Output: 3&gt; 遍历地图，直到遇到第一个‘1’（岛屿），以它为root开始通过DFS搜索这座岛屿的其它部分，并把他们全部转化为‘2’，同时把岛屿数量+1。之后接着遍历地图，由于我们将搜索过的岛屿转化为‘2’，因此不会再遇到‘1’。 123456789101112131415161718192021222324class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int islands = 0; for(int i = 0; i &lt; grid.length; i++) for(int j = 0; j &lt; grid[0].length; j++)&#123; if(grid[i][j] == '1')&#123; islands+=1; dfs(grid,i,j); &#125; &#125; return islands; &#125; private void dfs(char[][] grid, int x, int y)&#123; if(x &lt; 0 || y &lt; 0 || x &gt;= grid.length || y &gt;= grid[0].length || grid[x][y] == '0' || grid[x][y] == '2') return; grid[x][y] = '2'; dfs(grid,x+1,y); dfs(grid,x-1,y); dfs(grid,x,y+1); dfs(grid,x,y-1); &#125;&#125; 201. Bitwise AND of Numbers Range Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: 123&gt; Input: [5,7]&gt; Output: 4&gt; &gt; Example 2: 123&gt; Input: [0,1]&gt; Output: 0&gt; 1234567891011121314151617181920212223class Solution &#123; public int rangeBitwiseAnd(int m, int n) &#123; while(m&lt;n)&#123; n = n &amp; (n-1); &#125; return n; &#125;&#125;class Solution &#123; public int rangeBitwiseAnd(int m, int n) &#123; if(m == n)return m; int count = 0; while(m != n)&#123; n = n &gt;&gt; 1; m = m &gt;&gt; 1; count ++; &#125; for(int i = 0; i &lt; count; i++)&#123; m = m &lt;&lt; 1; &#125; return m; &#125;&#125; 202. Happy Number Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 12345678&gt; Input: 19&gt; Output: true&gt; Explanation: &gt; 12 + 92 = 82&gt; 82 + 22 = 68&gt; 62 + 82 = 100&gt; 12 + 02 + 02 = 1&gt; 12345678910111213141516171819class Solution &#123; public boolean isHappy(int n) &#123; int x = n; int sum = 0; if(n == 1) return true; while(sum != 1) &#123; sum = 0; while(x != 0) &#123; int y = x % 10; sum += y * y; x = x / 10; &#125; if(sum == n) return false; if(sum == 4) return false; x = sum; &#125; return true; &#125;&#125; 1234567891011121314151617181920212223class Solution &#123; public boolean isHappy(int n) &#123; int slow = happy(n); int fast = happy(happy(n)); while (fast != 1) &#123; slow = happy(slow); fast = happy(happy(fast)); if (slow == fast) &#123; return false; &#125; &#125; return true; &#125; private int happy(int n) &#123; int res = 0; while (n &gt; 0) &#123; int b = n % 10; n /= 10; res += b * b; &#125; return res; &#125;&#125; 123456789101112131415class Solution &#123; private Set&lt;Integer&gt; sumSet = new HashSet(); public boolean isHappy(int n) &#123; if(sumSet.contains(n))return false; sumSet.add(n); if( n == 1)return true; int sum = 0; while(n &gt; 0)&#123; int one = n % 10; sum += one * one; n = n / 10; &#125; return isHappy(sum); &#125;&#125; 203. Remove Linked List Elements Remove all elements from a linked list of integers that have value val. Example: 123&gt; Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6&gt; Output: 1-&gt;2-&gt;3-&gt;4-&gt;5&gt; 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode preHead = new ListNode(-1); preHead.next = head; ListNode prev = preHead; ListNode cur = preHead; while(cur != null)&#123; if(cur.val == val)&#123; prev.next = cur.next; cur = cur.next; &#125;else&#123; prev = cur; cur = cur.next; &#125; &#125; return preHead.next; &#125;&#125; 1234567class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null)return null; head.next = removeElements(head.next,val); return head.val == val ? head.next : head; &#125;&#125; 204. Count Primes Count the number of prime numbers less than a non-negative number, n. Example: 1234&gt; Input: 10&gt; Output: 4&gt; Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.&gt; 埃拉托斯特尼筛法:从2开始遍历到根号n，先找到第一个质数2，然后将其所有的倍数全部标记出来，然后到下一个质数3，标记其所有倍数，一次类推，直到根号n，此时数组中未被标记的数字就是质数。 12345678910111213141516171819public int countPrimes(int n) &#123; boolean[] isPrime = new boolean[n]; for (int i = 2; i &lt; n; i++) &#123; isPrime[i] = true; &#125; // Loop's ending condition is i * i &lt; n instead of i &lt; sqrt(n) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt; n; i++) &#123; if (!isPrime[i]) continue; for (int j = i * i; j &lt; n; j += i) &#123; isPrime[j] = false; &#125; &#125; int count = 0; for (int i = 2; i &lt; n; i++) &#123; if (isPrime[i]) count++; &#125; return count;&#125; 1234567891011121314class Solution &#123; public int countPrimes(int n) &#123; boolean[] isPrime = new boolean[n]; int count = 0; for(int i = 2; i &lt; n; i ++)&#123; if(isPrime[i]) continue; count ++; for(long j = (long)i * i;j &lt; n; j += i)&#123; isPrime[(int)j] = true; &#125; &#125; return count; &#125;&#125; 205. Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: 123&gt; Input: s = &quot;egg&quot;, t = &quot;add&quot;&gt; Output: true&gt; &gt; Example 2: 123&gt; Input: s = &quot;foo&quot;, t = &quot;bar&quot;&gt; Output: false&gt; &gt; Example 3: 123&gt; Input: s = &quot;paper&quot;, t = &quot;title&quot;&gt; Output: true&gt; 1234567891011121314class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; char[] sc = s.toCharArray(); char[] tc = t.toCharArray(); char[] map = new char[256]; for (int i = sc.length-1;i &gt;= 0;i--) &#123; if (map[sc[i]] != map[tc[i]+128]) &#123; return false; &#125; map[sc[i]] = map[tc[i] + 128] = sc[i]; &#125; return true; &#125;&#125; method-207. Course ScheduleThere are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1:1234Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2:12345Input: 2, [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.You may assume that there are no duplicate edges in the input prerequisites. 1、构建邻接表2、DFS遍历，三种状态，0 未遍历，1正在遍历，2已遍历，在DFS遍历过程中，如果再次遍历到处于1状态的节点说明存在环。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public static int[] visitStatus; public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adjList; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; adjList=new ArrayList&lt;&gt;(); visitStatus=new int[numCourses];// 每个节点的状态 // 构建邻接表 for(int i=0;i&lt;numCourses;i++) adjList.add(new ArrayList&lt;&gt;()); for(int[] tmp:prerequisites) &#123; adjList.get(tmp[1]).add(tmp[0]); &#125; for(int i=0;i&lt;numCourses;i++) &#123; if(visitStatus[i]!=0) continue; if(!dfs(i)) return false; &#125; return true; &#125; public static boolean dfs(int i) &#123; visitStatus[i]=1; // 遍历中 for(int j=0;j&lt;adjList.get(i).size();j++) &#123; int m=adjList.get(i).get(j); if(visitStatus[m]==2) continue; if(visitStatus[m]==1)// 说明有环 return false; if(!dfs(m))// 递归调用 return false; &#125; visitStatus[i]=2; // 已遍历 return true; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); boolean[][] adjMat; boolean[] visited; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; adjMat = new boolean[numCourses][numCourses]; visited = new boolean[numCourses]; /** * 构建邻接矩阵 */ for(int i=0;i&lt;prerequisites.length;i++)&#123; adjMat[prerequisites[i][1]][prerequisites[i][0]] = true; &#125; /** * 深度优先搜索 */ for(int i=0;i&lt;numCourses;i++)&#123; if(!visited[i])&#123; set.clear(); if(!DFS(i)) return false; &#125; &#125; return true; &#125; private boolean DFS(int index)&#123; visited[index] = true; set.add(index); for(int i=0;i&lt;visited.length;i++)&#123; if(adjMat[index][i]&amp;&amp;set.contains(i))// index 有边指向i，但是此次遍历i遍历过的点，说明有环 return false; if(!visited[i]&amp;&amp;adjMat[index][i])&#123;//i没有被遍历且index有边指向i if(!DFS(i)) return false; &#125; &#125; set.remove(index); return true; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; EdgeNode[] edges = new EdgeNode[numCourses]; Node temp = null; int topoSize = 0; for(int i=0;i&lt;numCourses;i++)&#123; edges[i] = new EdgeNode(); edges[i].in = 0; edges[i].val = i;// 节点id &#125; for(int i=0;i&lt;prerequisites.length;i++)&#123; temp = edges[prerequisites[i][1]].next; // 如果没有则为null Node newNode = new Node(); newNode.val = prerequisites[i][0];// 目标节点的id edges[prerequisites[i][1]].next = newNode;// 起始节点指向 目标节点 newNode.next = temp;// 将边插入到原来边中 edges[prerequisites[i][0]].in ++; &#125; Stack&lt;EdgeNode&gt; stack = new Stack&lt;EdgeNode&gt;();//存储入度为0的结点 for(int i=0;i&lt;numCourses;i++)&#123; //将入度为0的结点压入栈中 if(edges[i].in==0)&#123; stack.push(edges[i]); &#125; &#125; EdgeNode deletedNode = null; while(!stack.isEmpty())&#123; topoSize++; deletedNode = stack.pop(); //删除入度为0的结点 temp = deletedNode.next; while(temp!=null)&#123; //更新其邻接点的入度 if(edges[temp.val].in&gt;0)&#123; // 大于0的点说明是没有遍历过的 edges[temp.val].in --; if(edges[temp.val].in == 0) //如果更新后的邻接结点的入度为0，将其压入栈中 stack.push(edges[temp.val]); &#125; temp = temp.next; &#125; &#125; return topoSize == numCourses; &#125; class EdgeNode&#123; int in; int val; Node next; &#125; class Node&#123; int val; Node next; &#125;&#125;&#125; 208. Implement Trie (Prefix Tree)Implement a trie with insert, search, and startsWith methods. Example:12345678Trie trie = new Trie();trie.insert("apple");trie.search("apple"); // returns truetrie.search("app"); // returns falsetrie.startsWith("app"); // returns truetrie.insert("app"); trie.search("app"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z.All inputs are guaranteed to be non-empty strings. 前缀树，将每个单词以树的形式存储起来，只不过每个节点有27个子节点，字母为26个，多一个用于存储结束标记来判断当前word是否存在，比如 apple 存在时，appl 不一定存在，需要有一个标记，用于表示word结束。当然，这个标记也可以在内部类中额外用一个boolean变量来标记，相对来说这个更节省内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Trie &#123; private TrieNode root;//定义根节点 /** Initialize your data structure here. */ public Trie() &#123; root = new TrieNode(); root.val = ' ';//根节点为空 &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode ws = root;//root赋值给新变量 //遍历全部的word for(int i = 0; i &lt; word.length(); i++)&#123; //获取word中的单个字符 char c = word.charAt(i);//获取字符 if(ws.children[c - 'a'] == null)&#123;//判断该字符是否存在于当前的节点的子节点中 ws.children[c - 'a'] = new TrieNode(c);//赋予节点对象 &#125; ws = ws.children[c - 'a'];//下一个节点为ws的子节点 &#125; ws.isWord = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode ws = root; for(int i = 0; i &lt; word.length();i++)&#123; char c = word.charAt(i); if(ws.children[c - 'a'] == null)&#123; return false; &#125; ws = ws.children[c - 'a']; &#125; return ws.isWord; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode ws = root; for(int i = 0; i &lt; prefix.length();i++)&#123; char c = prefix.charAt(i); if(ws.children[c - 'a'] == null) return false; ws = ws.children[c - 'a']; &#125; return true; &#125;&#125;class TrieNode&#123;//定义节点类 public char val; public boolean isWord;//是否一个单词的最后的节点 public TrieNode[] children = new TrieNode[26];//26个小写的孩子节点 public TrieNode()&#123;&#125; public TrieNode(char c)&#123; isWord = false; this.val = c; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ 209. Minimum Size Subarray SumGiven an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. Example:123Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint.Follow up:If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 使用滑动窗口，如果和小于s，则窗口右边界右移，否则左边界右移 123456789101112131415161718192021class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; int min = Integer.MAX_VALUE; int left = 0; int right = 0; int sum = 0; while( right &lt; nums.length )&#123; if(sum + nums[right] &lt; s)&#123; sum = sum + nums[right]; right ++; &#125;else&#123; sum = sum - nums[left]; if(right - left &lt; min)&#123; min = right - left + 1; &#125; left ++; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; 210. Course Schedule IIThere are a total of n courses you have to take, labeled from 0 to n-1.Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. 12345Example 1:Input: 2, [[1,0]] Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . 1234567Example 2:Input: 4, [[1,0],[2,0],[3,1],[3,2]]Output: [0,1,2,3] or [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.You may assume that there are no duplicate edges in the input prerequisites. 邻接表保存，对应顺序的列表保存着修完改课程才能修读的课程 1、构建邻接表 2、逐个节点dfs遍历，并从后往前保存遍历的节点，如果有环说明不可行，排序队列不存在 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public static int[] reversePost; public static int idx; public static int[] visitStatus; public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adjList;//邻接表 public int[] findOrder(int numCourses, int[][] prerequisites) &#123; idx=numCourses-1; reversePost=new int[numCourses]; adjList=new ArrayList&lt;&gt;(); visitStatus=new int[numCourses]; for(int i=0;i&lt;numCourses;i++) adjList.add(new ArrayList&lt;&gt;()); for(int[] tmp:prerequisites) &#123; adjList.get(tmp[1]).add(tmp[0]); &#125; for(int i=0;i&lt;numCourses;i++) &#123; if(visitStatus[i]!=0) continue; if(!dfs(i)) return new int[0]; &#125; return reversePost; &#125; public static boolean dfs(int i) &#123; visitStatus[i]=1; for(int j=0;j&lt;adjList.get(i).size();j++) &#123; int m=adjList.get(i).get(j); if(visitStatus[m]==2) continue; if(visitStatus[m]==1) return false; if(!dfs(m)) return false; &#125; visitStatus[i]=2; reversePost[idx--]=i; return true; &#125; &#125; 1、构建图，每个Edge保存着需要先修完本课程才能修的课 2、查找入度为0的节点，加入到栈 3、栈弹出一个节点，并将该点加入到修读结果中，遍历该节点可达的全部节点tartget，并将target的入度减1，若target入度为0，加入栈 4、若栈为空时，所有节点入度为0或者修读结果列表大小正好是节点总数则说明有向图中不存在环(存在该排序) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; EdgeNode[] graph = new EdgeNode[numCourses]; for(int i = 0; i &lt; numCourses; i++)&#123; graph[i] = new EdgeNode(); graph[i].val = i; graph[i].in = 0; &#125; for(int[] edge : prerequisites)&#123; Node tmp = graph[edge[1]].next; Node newNode = new Node(); newNode.val = edge[0]; graph[edge[1]].next = newNode; newNode.next = tmp; graph[edge[0]].in ++; &#125; Stack&lt;EdgeNode&gt; stack = new Stack&lt;&gt;(); for(int i = 0; i &lt; numCourses; i++)&#123; if(graph[i].in == 0)&#123; stack.push(graph[i]); &#125; &#125; List&lt;Integer&gt; list = new ArrayList(); EdgeNode node2delete = null; while(! stack.isEmpty())&#123; node2delete = stack.pop(); list.add(node2delete.val); Node temp = node2delete.next; while( temp != null)&#123; if(graph[temp.val].in &gt;0 )&#123; graph[temp.val].in --; if(graph[temp.val].in == 0)stack.push(graph[temp.val]); &#125; temp = temp.next; &#125; &#125; if(list.size() == numCourses)&#123; int[] result = new int[numCourses]; for(int i = 0; i &lt; numCourses; i++)&#123; result[i] = list.get(i); &#125; return result; &#125;else&#123; return new int[0]; &#125; &#125; class EdgeNode&#123; int in; // 入度数 int val; Node next; &#125; class Node&#123; int val; Node next; &#125;&#125; 原理和方法一样，只是使用List代替Node类和入度值(该方法只适用这种规律强，id连续的图) 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] res = new int[numCourses]; int[] degrees = new int[numCourses]; List[] edges = new ArrayList[numCourses]; for (int i = 0; i &lt; numCourses; ++i) &#123; edges[i] = new ArrayList&lt;&gt;(); &#125; for (int[] pre : prerequisites) &#123; ++degrees[pre[0]]; edges[pre[1]].add(pre[0]); &#125; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) &#123; if (degrees[i] == 0) &#123; q.offer(i); &#125; &#125; int cnt = 0; while (!q.isEmpty()) &#123; int n = q.poll(); res[cnt++] = n; for (int i = 0; i &lt; edges[n].size(); ++i) &#123; int nei = (int) edges[n].get(i); --degrees[nei]; if (degrees[nei] == 0) &#123; q.offer(nei); &#125; &#125; &#125; return cnt == numCourses ? res : new int[0]; &#125;&#125; 211. Add and Search Word - Data structure designDesign a data structure that supports the following two operations: void addWord(word)bool search(word)search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example:1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. 题外话，同样的代码，中文leetcode会超时，但是实际上这是排在前百分之九十的答案，比别人的差太多了，还每次占题的时候要求附带链接。。。。。我有点无奈 其实这题和208题基本差不多，唯一就是’.’的处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class WordDictionary &#123; private TreeNode root; /** Initialize your data structure here. */ public WordDictionary() &#123; root = new TreeNode('0'); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; if(word==null || word.length()==0)&#123; return; &#125; TreeNode node = root; for(int i = 0; i &lt; word.length(); i++)&#123; char c = word.charAt(i); int pos = c - 'a'; if(node.children[pos] == null)&#123; node.children[pos] = new TreeNode(c); &#125; node = node.children[pos]; &#125; node.isWord = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; if(word==null || word.length()==0)&#123; return true; &#125; return search(root, word, 0); &#125; private boolean search(TreeNode node, String word, int index)&#123; if(word.length() == index)&#123; return node.isWord; &#125; if(word.charAt(index) == '.')&#123; for(int i = 0; i &lt; 26; i++)&#123; if(node.children[i] != null)&#123; if(search(node.children[i], word, index + 1)) return true; &#125; &#125; return false; &#125;else&#123; char c = word.charAt(index); int pos = c - 'a'; if(node.children[pos] != null)&#123; return search(node.children[pos], word, index + 1); &#125; return false; &#125; &#125; class TreeNode&#123; char val; boolean isWord; TreeNode[] children = new TreeNode[26]; public TreeNode(char c)&#123; isWord = false; this.val = c; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041class WordDictionary &#123; class Trie &#123; Trie[] tries = new Trie[26]; boolean isWord = false; void insert(String word, int index) &#123; if(index == word.length()) isWord = true; else &#123; if(tries[word.charAt(index) - 'a'] == null)tries[word.charAt(index) - 'a'] = new Trie(); tries[word.charAt(index) - 'a'].insert(word,index+1); &#125; &#125; boolean find(String word, int index) &#123; if(index== word.length()) return isWord; if(word.charAt(index) == '.') &#123; for(int i = 0 ; i &lt; 26;i++) &#123; if(tries[i] != null &amp;&amp; tries[i].find(word,index+1)) return true; &#125; return false; &#125;else return tries[word.charAt(index) - 'a'] != null &amp;&amp; tries[word.charAt(index) - 'a'].find(word,index+1); &#125; &#125; Trie root = new Trie(); /** Initialize your data structure here. */ public WordDictionary() &#123; &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; root.insert(word,0); &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; return root.find(word,0); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class WordDictionary &#123; Map&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); /** Initialize your data structure here. */ public WordDictionary() &#123; &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; int index = word.length(); if(!map.containsKey(index))&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(word); map.put(index, list); &#125; else&#123; map.get(index).add(word); &#125; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; int index= word.length(); if(!map.containsKey(index))&#123; return false; &#125; List&lt;String&gt; list = map.get(index); for(String s: list)&#123; if(isSame(s, word))&#123; return true; &#125; &#125; return false; &#125; public boolean isSame(String s, String word)&#123; for(int i = 0; i &lt; s.length();i++)&#123; if(word.charAt(i) != '.' &amp;&amp; word.charAt(i) != s.charAt(i))&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode note - part 3]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode-note-part-3%2F</url>
    <content type="text"><![CDATA[刷LeetCode笔记3 102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; return its level order traversal as: 123456&gt; [&gt; [3],&gt; [9,20],&gt; [15,7]&gt; ]&gt; 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; levelOrder(root,0); return result; &#125; public void levelOrder(TreeNode root, int level)&#123; if(root == null)return ; if(level &gt;= result.size())&#123; result.add(new ArrayList&lt;Integer&gt;()); &#125; List&lt;Integer&gt; list = result.get(level); list.add(root.val); levelOrder(root.left, level + 1); levelOrder(root.right, level + 1); &#125;&#125; 103. Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; return its zigzag level order traversal as: 123456&gt; [&gt; [3],&gt; [20,9],&gt; [15,7]&gt; ]&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 4ms 34.4MB/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; if(null == root)return result; Stack&lt;TreeNode&gt; stack1 = new Stack(); Stack&lt;TreeNode&gt; stack2 = new Stack(); stack2.push(root); boolean flag = false; while(!(stack1.isEmpty() &amp;&amp; stack2.isEmpty()))&#123; List&lt;Integer&gt; list = new ArrayList(); if(flag)&#123; flag = false; while(!stack1.isEmpty())&#123; TreeNode tree = stack1.pop(); list.add(tree.val); if(tree.right != null)&#123; stack2.push(tree.right); &#125; if(tree.left != null)&#123; stack2.push(tree.left); &#125; &#125; &#125;else&#123; flag = true; while(!stack2.isEmpty())&#123; TreeNode tree = stack2.pop(); list.add(tree.val); if(tree.left != null)&#123; stack1.push(tree.left); &#125; if(tree.right != null)&#123; stack1.push(tree.right); &#125; &#125; &#125; result.add(list); &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031// 2ms 34.8MB/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; zigzagLevelOrder(root, 0); return result; &#125; public void zigzagLevelOrder(TreeNode root, int level)&#123; if(null == root)return ; if(level &gt;= result.size())&#123; result.add(new LinkedList()); &#125; LinkedList&lt;Integer&gt; list = (LinkedList&lt;Integer&gt;)result.get(level); if(level % 2 == 0)&#123; list.addLast(root.val); &#125;else&#123; list.addFirst(root.val); &#125; zigzagLevelOrder(root.left, level + 1); zigzagLevelOrder(root.right, level + 1); &#125;&#125; 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; return its depth = 3. 123456789101112131415/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(null == root)return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125;&#125; 105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 123&gt; preorder = [3,9,20,15,7]&gt; inorder = [9,3,15,20,7]&gt; &gt; Return the following binary tree: 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); &#125; private TreeNode buildTree(int[] preorder, int ps, int pe, int[] inorder, int is, int ie) &#123; if(ps &gt; pe)return null; int val = preorder[ps]; TreeNode root = new TreeNode(val); int iroot = is; while(iroot &lt; ie &amp;&amp; val != inorder[iroot])&#123; iroot ++; &#125; root.left = buildTree(preorder, ps +1, ps + iroot -is, inorder, is, iroot -1); root.right = buildTree(preorder, ps + iroot - is + 1, pe, inorder, iroot +1, ie); return root; &#125;&#125; 106. Construct Binary Tree from Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 123&gt; inorder = [9,3,15,20,7]&gt; postorder = [9,15,7,20,3]&gt; &gt; Return the following binary tree: 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; 1234567891011121314151617181920212223242526272829// 3ms 36.8MB/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; return buildTree(inorder, 0, inorder.length-1, postorder, 0, postorder.length -1); &#125; public TreeNode buildTree(int[] inorder, int is, int ie, int[] postorder, int ps, int pe)&#123; if(ps &gt; pe)&#123; return null; &#125; int val = postorder[pe]; TreeNode root = new TreeNode(val); int iroot = ie; while(iroot &gt;= is &amp;&amp; inorder[iroot] != val)&#123; iroot --; &#125; root.left = buildTree(inorder,is, iroot -1, postorder, ps, ps + iroot - is -1); root.right = buildTree(inorder,iroot + 1, ie, postorder,ps + iroot - is , pe - 1); return root; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637// 原理一样，不同的表达而已/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if(postorder.length==0) return null; return builfTree(postorder,postorder.length-1,inorder,inorder.length-1,inorder.length); &#125; private TreeNode builfTree(int[] postorder,int pe, int[] inorder,int ie,int len)&#123; if(len==1)&#123; return new TreeNode(postorder[pe]); &#125; if(len&lt;1)&#123; return null; &#125; TreeNode node=new TreeNode(postorder[pe]); int midLen=0; for(int i=0;i&lt;len;i++)&#123; if(inorder[ie-i]==postorder[pe])&#123; midLen=i; break; &#125; &#125; node.right=builfTree(postorder,pe-1,inorder,ie,midLen); node.left=builfTree(postorder,pe-midLen-1,inorder,ie-1-midLen,len-midLen-1); return node; &#125;&#125; 107. Binary Tree Level Order Traversal IIGiven a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 123456789101112131415161718192021222324252627// 2ms 35.8MB/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; levelOrderBottom(root, 0); return result; &#125; public void levelOrderBottom(TreeNode root, int level)&#123; if(null == root)return; if(level &gt;= result.size())&#123; result.add(0, new ArrayList&lt;Integer&gt;()); &#125; List&lt;Integer&gt; list = result.get(result.size() - level - 1); list.add(root.val); levelOrderBottom(root.left, level +1); levelOrderBottom(root.right, level +1); &#125;&#125; 108. Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 12345678910&gt; Given the sorted array: [-10,-3,0,5,9],&gt; &gt; One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:&gt; &gt; 0&gt; / \&gt; -3 9&gt; / /&gt; -10 5&gt; 123456789101112131415161718192021222324// 逆 中序遍历/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(0 == nums.length) return null; return build(nums, 0, nums.length-1); &#125; public TreeNode build(int[] nums, int start, int end)&#123; if(start &gt; end)return null; int mid = start + (end - start)/2; TreeNode root = new TreeNode(nums[mid]); root.left = build(nums, start, mid -1); root.right = build(nums, mid +1, end); return root; &#125;&#125; Mark-109. Convert Sorted List to Binary Search Tree 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; /** * 考点：快慢指针法、DSF */ public TreeNode sortedListToBST(ListNode head) &#123; // 递归截止 if(head == null || head.next == null)&#123; return head == null ? null : new TreeNode(head.val); &#125; ListNode pre = head,mid = head,mid_next = head; while(mid_next != null &amp;&amp; mid_next.next != null)&#123;// 快慢指针法找到中间节点 pre = mid; mid = mid.next; mid_next = mid_next.next.next; &#125; pre.next = null; // 断链 TreeNode root = new TreeNode(mid.val); // 构造根节点，左右子节点DSF root.left = sortedListToBST(head); root.right = sortedListToBST(mid.next); return root; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; return buildBST(head, null); &#125; private TreeNode buildBST(ListNode start, ListNode end) &#123; if (start == end) return null; ListNode midNode = start, fast = start; while (fast != end &amp;&amp; fast.next != end) &#123; midNode = midNode.next; fast = fast.next.next; &#125; TreeNode root = new TreeNode(midNode.val); root.left = buildBST(start, midNode); root.right = buildBST(midNode.next, end); return root; &#125;&#125; 110. Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 12345678&gt; 1&gt; / \&gt; 2 2&gt; / \&gt; 3 3&gt; / \&gt; 4 4&gt; &gt; Return false. 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null)return true; if(Math.abs(height(root.left) - height(root.right)) &gt; 1)return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; private int height(TreeNode root)&#123; if(root == null)return 0; return Math.max(height(root.left), height(root.right)) + 1; &#125;&#125; 111. Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; return its minimum depth = 2. 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null)return 0; if(root.left == null &amp;&amp; root.right == null)return 1; if(root.left == null) return minDepth(root.right) + 1; if(root.right == null)return minDepth(root.left) + 1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; &#125;&#125; 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 12345678&gt; 5&gt; / \&gt; 4 8&gt; / / \&gt; 11 13 4&gt; / \ \&gt; 7 2 1&gt; &gt; return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null)return 0 == sum - root.val; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum -root.val); &#125;&#125; 113. Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 12345678&gt; 5&gt; / \&gt; 4 8&gt; / / \&gt; 11 13 4&gt; / \ / \&gt; 7 2 5 1&gt; &gt; Return: 12345&gt; [&gt; [5,4,11,2],&gt; [5,8,4,5]&gt; ]&gt; 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; pathSum(root, sum, new ArrayList()); return result; &#125; private void pathSum(TreeNode root, int sum, List&lt;Integer&gt; list)&#123; if(root == null) return ; if(root.left == null &amp;&amp; root.right == null )&#123;//到达叶节点 if(sum - root.val == 0)&#123; list.add(root.val); result.add(new ArrayList(list)); list.remove(list.size() -1); &#125; return; &#125; list.add(root.val); pathSum(root.left, sum - root.val, list); pathSum(root.right, sum - root.val, list); list.remove(list.size() -1); &#125;&#125; sMark-114. Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 123456&gt; 1&gt; / \&gt; 2 5&gt; / \ \&gt; 3 4 6&gt; &gt; The flattened tree should look like: 123456789101112&gt; 1&gt; \&gt; 2&gt; \&gt; 3&gt; \&gt; 4&gt; \&gt; 5&gt; \&gt; 6&gt; 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; if(null == root)return ; flatten(root.left); flatten(root.right); if(root.left == null &amp;&amp; root.right == null)return; if(root.left != null &amp;&amp; root.right != null)&#123; TreeNode node = root.left; while(node.right != null)&#123; node = node.right; &#125; node.right = root.right; root.right = root.left; root.left = null; &#125;else if(root.left != null)&#123; root.right = root.left; root.left = null; &#125; &#125; &#125; 116. Populating Next Right Pointers in Each Node You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 1234567&gt; struct Node &#123;&gt; int val;&gt; Node *left;&gt; Node *right;&gt; Node *next;&gt; &#125;&gt; &gt; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example: 123456&gt; Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;&gt; &gt; Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;&gt; &gt; Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val,Node _left,Node _right,Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if(null == root)return null; Node cur = root; while(cur != null &amp;&amp; cur.left != null)&#123; cur.left.next = cur.right; if(cur.next != null)&#123; cur.right.next = cur.next.left; &#125; cur = cur.next; &#125; connect(root.left); return root; &#125;&#125;// 用循环和用递归，只要脑子转得过来，看实际情况，怎么方便怎么来，没必要刻意class Solution &#123; public Node connect(Node root) &#123; if(null == root)return null; Node cur = root, pre = root; while(pre.left != null)&#123; cur = pre; while(cur != null)&#123; cur.left.next = cur.right; if(cur.next != null)&#123; cur.right.next = cur.next.left; &#125; cur = cur.next; &#125; pre = pre.left; &#125; return root; &#125;&#125; Mark-117. Populating Next Right Pointers in Each Node II Given a binary tree 1234567&gt; struct Node &#123;&gt; int val;&gt; Node *left;&gt; Node *right;&gt; Node *next;&gt; &#125;&gt; &gt; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example: 123456&gt; Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;&gt; &gt; Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;&gt; &gt; Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val,Node _left,Node _right,Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null) &#123; return null; &#125; // 借助队列实现层次遍历 LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; int size = queue.size(); while (size-- &gt; 0) &#123; Node node = queue.remove(); if (size &gt; 0) &#123; node.next = queue.peek(); &#125; if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; &#125; return root; &#125;&#125;// 先确保 root.right 下的节点的已完全连接，因 root.left 下的节点的连接// 需要 root.left.next 下的节点的信息，若 root.right 下的节点未完全连// 接（即先对 root.left 递归），则 root.left.next 下的信息链不完整，将// 返回错误的信息。可能出现的错误情况如下图所示。此时，底层最左边节点将无// 法获得正确的 next 信息：// o root// / \// root.left o —— o root.right// / / \// o —— o o// / / \// o o oclass Solution &#123; public Node connect(Node root) &#123; if (root == null) return null; if (root.left == null &amp;&amp; root.right == null) return root; //查找next节点可以考虑抽成额外方法 // 需要先right后left的原因在于寻找next Node childNext = root.next; while (childNext != null) &#123; if (childNext.left != null) &#123; childNext = childNext.left; break; &#125; if (childNext.right != null) &#123; childNext = childNext.right; break; &#125; childNext = childNext.next; &#125; if (root.left != null &amp;&amp; root.right != null) &#123; root.left.next = root.right; root.right.next = childNext; connect(root.right); connect(root.left); &#125; else if (root.left != null) &#123; root.left.next = childNext; connect(root.left); &#125; else &#123; root.right.next = childNext; connect(root.right); &#125; return root; &#125;&#125; 118. Pascal’s Triangle Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it. Example: 12345678910&gt; Input: 5&gt; Output:&gt; [&gt; [1],&gt; [1,1],&gt; [1,2,1],&gt; [1,3,3,1],&gt; [1,4,6,4,1]&gt; ]&gt; 12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); for(int i = 0; i &lt; numRows; i++)&#123; List&lt;Integer&gt; list = new ArrayList(); for(int j = 0; j &lt;= i; j++)&#123; if(j == i || j == 0)&#123; list.add(1); &#125;else&#123; List&lt;Integer&gt; preRow = result.get(i -1); int val = preRow.get(j -1) + preRow.get(j); list.add(val); &#125; &#125; result.add(list); &#125; return result; &#125;&#125; 119. Pascal’s Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. In Pascal’s triangle, each number is the sum of the two numbers directly above it. Example: 123&gt; Input: 3&gt; Output: [1,3,3,1]&gt; &gt; Follow up: Could you optimize your algorithm to use only O(k) extra space? 12345678910111213141516171819// 最笨的方法class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; preRow = null; for(int i = 0; i &lt;= rowIndex; i ++)&#123; List&lt;Integer&gt; tmp = new ArrayList(); for(int j = 0; j &lt; i + 1; j ++)&#123; if(j == 0 || j == i)&#123; tmp.add(1); &#125;else&#123; int val = preRow.get(j-1) + preRow.get(j); tmp.add(val); &#125; &#125; preRow = tmp; &#125; return preRow; &#125;&#125; 123456789101112// 通过数学规律将对应位置数值的表达式计算出来class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; result = new ArrayList(); long val = 1; // 后面数据太大，用int存不下 for(int i = 0; i &lt;= rowIndex; i ++)&#123; result.add((int)val); val = val * (rowIndex - i) / (i + 1); &#125; return result; &#125;&#125; sMark-120. Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 1234567&gt; [&gt; [2],&gt; [3,4],&gt; [6,5,7],&gt; [4,1,8,3]&gt; ]&gt; &gt; The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 这道题C++做起来更轻松些，Java的基础类型传值不传引用，这种情况下指针大法好(直接修改原数据)。 123456789101112131415class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null || triangle.size() == 0)&#123; return 0; &#125; int[] rms = new int[triangle.size() + 1]; for(int i = triangle.size(); i &gt; 0; i --)&#123; List&lt;Integer&gt; curRow = triangle.get(i - 1); for(int j = 0; j &lt; curRow.size(); j++)&#123; rms[j] = Math.min(rms[j], rms[j+1]) + curRow.get(j); &#125; &#125; return rms[0]; &#125;&#125; 1234567891011121314151617// 自下而上不用额外寻找最小值public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null || triangle.size() == 0)&#123; return 0; &#125; // 加1可以不用初始化最后一层 int[][] dp = new int[triangle.size()+1][triangle.size()+1]; for (int i = triangle.size()-1; i&gt;=0; i--)&#123; List&lt;Integer&gt; curTr = triangle.get(i); for(int j = 0 ; j&lt; curTr.size(); j++)&#123; dp[i][j] = Math.min(dp[i+1][j], dp[i+1][j+1]) + curTr.get(j); &#125; &#125; return dp[0][0]; &#125;&#125; 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: 12345&gt; Input: [7,1,5,3,6,4]&gt; Output: 5&gt; Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.&gt; Not 7-1 = 6, as selling price needs to be larger than buying price.&gt; &gt; Example 2: 1234&gt; Input: [7,6,4,3,1]&gt; Output: 0&gt; Explanation: In this case, no transaction is done, i.e. max profit = 0.&gt; 1234567891011121314class Solution &#123; public int maxProfit(int[] prices) &#123; int min = Integer.MAX_VALUE; int profit = 0; for(int i = 0; i &lt; prices.length; i ++)&#123; if(prices[i] &lt; min &amp;&amp; i != prices.length)&#123; min = prices[i]; continue; &#125; profit = profit &gt; prices[i] - min ? profit : prices[i] - min; &#125; return profit; &#125;&#125; 122. Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 12345&gt; Input: [7,1,5,3,6,4]&gt; Output: 7&gt; Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.&gt; Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.&gt; &gt; Example 2: 123456&gt; Input: [1,2,3,4,5]&gt; Output: 4&gt; Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.&gt; Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are&gt; engaging multiple transactions at the same time. You must sell before buying again.&gt; &gt; Example 3: 1234&gt; Input: [7,6,4,3,1]&gt; Output: 0&gt; Explanation: In this case, no transaction is done, i.e. max profit = 0.&gt; 1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int profit = 0; for(int i = 0; i &lt; prices.length - 1; i ++)&#123; if(prices[i+1] &gt; prices[i])&#123; profit += prices[i+1] - prices[i]; // 把式子连起来就清楚了，会把部分中间项抵消 &#125; &#125; return profit; &#125;&#125; Hard-123. Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 12345&gt; Input: [3,3,5,0,0,3,1,4]&gt; Output: 6&gt; Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.&gt; Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.&gt; &gt; Example 2: 123456&gt; Input: [1,2,3,4,5]&gt; Output: 4&gt; Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.&gt; Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are&gt; engaging multiple transactions at the same time. You must sell before buying again.&gt; &gt; Example 3: 1234&gt; Input: [7,6,4,3,1]&gt; Output: 0&gt; Explanation: In this case, no transaction is done, i.e. max profit = 0.&gt; 12345678910111213class Solution &#123; public int maxProfit(int[] prices) &#123; int fstBuy = Integer.MIN_VALUE, fstSell = 0; int secBuy = Integer.MIN_VALUE, secSell = 0; for(int p : prices) &#123; fstBuy = Math.max(fstBuy, -p); fstSell = Math.max(fstSell, fstBuy + p); secBuy = Math.max(secBuy, fstSell - p); secSell = Math.max(secSell, secBuy + p); &#125; return secSell; &#125;&#125; 1https://blog.csdn.net/qq_41855420/article/details/87867155 125. Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: 123&gt; Input: &quot;A man, a plan, a canal: Panama&quot;&gt; Output: true&gt; &gt; Example 2: 123&gt; Input: &quot;race a car&quot;&gt; Output: false&gt; 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; static int[] map = new int[256]; static&#123; for(int i =0 ; i &lt; 10 ; i++)&#123; map[ i + '0'] = i + 1; &#125; for(int i =0 ; i &lt; 26 ; i++)&#123; map[ i + 'a'] = map[ i + 'A'] = i + 11; &#125; &#125; public boolean isPalindrome(String s) &#123; char[] arrays = s.toCharArray(); int start = 0; int end = arrays.length - 1; int startChar, endChar; //注意 int转换为char会报错，因为值范围不同，会出现数据损失 while(start &lt; end)&#123; startChar = map[arrays[start]]; endChar = map[arrays[end]]; if( startChar !=0 &amp;&amp; endChar !=0)&#123; if(startChar != endChar)&#123; return false; &#125; start++; end--; &#125;else &#123; if( startChar ==0 ) start++; if( endChar ==0) end--; &#125; &#125; return true; &#125; &#125; Mark-127. Word LadderGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 123456789Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Example 2: 12345678Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. https://www.cnblogs.com/grandyang/p/4539768.html 1234567891011121314151617181920212223242526272829303132333435363738394041// 计算每多一步，计算量是指数级增长，如果从两端逼近，能有效减少计算量（分成了两份，但指数减小了）class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (wordList == null || wordList.size() == 0) return 0; HashSet&lt;String&gt; start = new HashSet&lt;&gt;(); HashSet&lt;String&gt; end = new HashSet&lt;&gt;(); HashSet&lt;String&gt; dic = new HashSet&lt;&gt;(wordList); start.add(beginWord); end.add(endWord); if (!dic.contains(endWord)) return 0; return bfs(start, end, dic, 2); &#125; public int bfs(HashSet&lt;String&gt; st, HashSet&lt;String&gt; ed, HashSet&lt;String&gt; dic, int l) &#123; if (st.size() == 0) return 0; if (st.size() &gt; ed.size()) &#123; return bfs(ed, st, dic, l);// 通过两端向中间靠拢，所以需要交换 &#125; dic.removeAll(st); HashSet&lt;String&gt; next = new HashSet&lt;&gt;(); for (String s : st) &#123; char[] arr = s.toCharArray(); for (int i = 0; i &lt; arr.length; i++) &#123; char tmp = arr[i]; for (char c = 'a'; c &lt;= 'z'; c++) &#123; if (tmp == c) continue; arr[i] = c; String nstr = new String(arr); if (dic.contains(nstr)) &#123; if (ed.contains(nstr)) return l;//st到ed存在可以改变一个字母完成改变的，说明转换队列完成 else next.add(nstr); &#125; &#125; arr[i] = tmp; &#125; &#125; return bfs(next, ed, dic, l + 1); &#125;&#125; 1234567891011121314151617181920212223242526272829303132// 187ms 69.9 MBclass Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (wordList == null || wordList.size() == 0) return 0; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();// 用于存储新生成的且之前没出现过的string Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();//用于保存转换到该词需要多少步 map.put(beginWord, 1); HashSet&lt;String&gt; dic = new HashSet&lt;&gt;(wordList); queue.add(beginWord); if (!dic.contains(endWord)) return 0; while( !queue.isEmpty() )&#123; String str = queue.poll(); char[] arr = str.toCharArray(); for(int i = 0; i &lt; arr.length; i++)&#123; char tmp = arr[i]; for(char c = 'a'; c &lt;= 'z'; c ++)&#123; arr[i] = c; String newWord = new String(arr); if(dic.contains(newWord) &amp;&amp; newWord.equals(endWord))&#123; return map.get(str) + 1; &#125; if(dic.contains(newWord) &amp;&amp; !map.containsKey(newWord))&#123; queue.add(newWord); map.put(newWord, map.get(str) + 1); &#125; &#125;//for 'a' ~ 'z' arr[i] = tmp; &#125;//for &#125;// while return 0; &#125;&#125; 129. Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: 12345678910&gt; Input: [1,2,3]&gt; 1&gt; / \&gt; 2 3&gt; Output: 25&gt; Explanation:&gt; The root-to-leaf path 1-&gt;2 represents the number 12.&gt; The root-to-leaf path 1-&gt;3 represents the number 13.&gt; Therefore, sum = 12 + 13 = 25.&gt; &gt; Example 2: 12345678910111213&gt; Input: [4,9,0,5,1]&gt; 4&gt; / \&gt; 9 0&gt; / \&gt; 5 1&gt; Output: 1026&gt; Explanation:&gt; The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.&gt; The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.&gt; The root-to-leaf path 4-&gt;0 represents the number 40.&gt; Therefore, sum = 495 + 491 + 40 = 1026.&gt; 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public int sumNumbers(TreeNode root) &#123; sumNumbers(root, 0); return sum; &#125; private void sumNumbers(TreeNode root, int preVal)&#123; if(root == null)return ; preVal = 10 * preVal + root.val; if(root.left == null &amp;&amp; root.right == null)&#123; sum += preVal; &#125; if(root.left != null)&#123; sumNumbers(root.left, preVal); &#125; if(root.right != null)&#123; sumNumbers(root.right, preVal); &#125; &#125;&#125; sMark-130. Surrounded Regions Given a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;. A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region. Example: 12345&gt; X X X X&gt; X O O X&gt; X X O X&gt; X O X X&gt; &gt; After running your function, the board should be: 12345&gt; X X X X&gt; X X X X&gt; X X X X&gt; X O X X&gt; &gt; Explanation: Surrounded regions shouldn’t be on the border, which means that any &#39;O&#39; on the border of the board are not flipped to &#39;X&#39;. Any &#39;O&#39; that is not on the border and it is not connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;. Two cells are connected if they are adjacent cells connected horizontally or vertically. 对矩阵边界上所有的O做深度优先搜索，将相连的O更改为-，然后编辑数组，将数组中O更改为X，将数组中-更改为O。只有外层为‘O’才会继续往内遍历。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; int row,col; public void solve(char[][] board) &#123; if(board==null||board.length==0) return ; row=board.length; col=board[0].length; for(int i=0;i&lt;row;i++)&#123; dfs(board,i,0); dfs(board,i,col-1); &#125; for(int j=0;j&lt;col;j++)&#123; dfs(board,0,j); dfs(board,row-1,j); &#125; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(board[i][j]=='O') board[i][j]='X'; if(board[i][j]=='-') board[i][j]='O'; &#125; &#125; return ; &#125; public void dfs(char[][] board,int i,int j)&#123; if(i&lt;0||j&lt;0||i&gt;=row||j&gt;=col||board[i][j]!='O') return; board[i][j]='-'; dfs(board,i-1,j); dfs(board,i+1,j); dfs(board,i,j-1); dfs(board,i,j+1); return ; &#125;&#125; method-131. Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: 1234567&gt; Input: &quot;aab&quot;&gt; Output:&gt; [&gt; [&quot;aa&quot;,&quot;b&quot;],&gt; [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]&gt; ]&gt; https://www.cnblogs.com/grandyang/p/4270008.html 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); char[] arr; String s; void core(int index)&#123; // 从index开始分割 if (index == arr.length)&#123; result.add(new ArrayList&lt;&gt;(list)); return; &#125; for (int i = index; i &lt; arr.length; i++)&#123; if (isPalindrome(index,i))&#123; list.add(s.substring(index,i + 1)); core(i + 1); list.remove(list.size() - 1); &#125; &#125; &#125; boolean isPalindrome(int left,int right)&#123;// 减少substring次数，直接使用索引 int L = left,R = right; while (L &lt;= R)&#123; if (arr[L++] != arr[R--])&#123; return false; &#125; &#125; return true; &#125; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; arr = s.toCharArray(); // 可以有效节约空间和时间 this.s = s; core(0); return result; &#125;&#125; map-133. Clone Graph Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. Example: 123456789&gt; Input:&gt; &#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;&gt; &gt; Explanation:&gt; Node 1&apos;s value is 1, and it has two neighbors: Node 2 and 4.&gt; Node 2&apos;s value is 2, and it has two neighbors: Node 1 and 3.&gt; Node 3&apos;s value is 3, and it has two neighbors: Node 2 and 4.&gt; Node 4&apos;s value is 4, and it has two neighbors: Node 1 and 3.&gt; &gt; Note: The number of nodes will be between 1 and 100. The undirected graph is a simple graph#Simple_graph), which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph. https://www.cnblogs.com/grandyang/p/4267628.html 123456789101112131415161718192021222324252627282930313233/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; neighbors; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;;*/class Solution &#123; Map&lt;Integer, Node&gt; map = new HashMap&lt;&gt;(); public Node cloneGraph(Node node) &#123; if (node == null) return null; if (map.containsKey(node.val)) return map.get(node.val); Node copyNode = new Node(node.val, new ArrayList&lt;Node&gt;()); map.put(node.val, copyNode); for (Node neighbour: node.neighbors) &#123; copyNode.neighbors.add(cloneGraph(neighbour)); &#125; return copyNode; &#125;&#125; 134. Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: 123456789101112131415&gt; Input: &gt; gas = [1,2,3,4,5]&gt; cost = [3,4,5,1,2]&gt; &gt; Output: 3&gt; &gt; Explanation:&gt; Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4&gt; Travel to station 4. Your tank = 4 - 1 + 5 = 8&gt; Travel to station 0. Your tank = 8 - 2 + 1 = 7&gt; Travel to station 1. Your tank = 7 - 3 + 2 = 6&gt; Travel to station 2. Your tank = 6 - 4 + 3 = 5&gt; Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.&gt; Therefore, return 3 as the starting index.&gt; &gt; Example 2: 1234567891011121314&gt; Input: &gt; gas = [2,3,4]&gt; cost = [3,4,3]&gt; &gt; Output: -1&gt; &gt; Explanation:&gt; You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.&gt; Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4&gt; Travel to station 0. Your tank = 4 - 3 + 2 = 3&gt; Travel to station 1. Your tank = 3 - 3 + 3 = 3&gt; You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.&gt; Therefore, you can&apos;t travel around the circuit once no matter where you start.&gt; 1234567891011121314151617class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int start = 0; int total = 0; int current = 0; for (int i = 0; i &lt; gas.length; i++) &#123; total += gas[i] - cost[i]; current += gas[i] - cost[i]; if (current &lt; 0) &#123;// 说明从start出发，会存在无法到达的情况（油不够） start = i + 1; // 在站点i才发生油不够的情况，说明从站点i到达i+1，因而至少从站点i+1出发 current = 0; &#125; &#125; return total &gt;= 0 ? start : -1; &#125;&#125; 1234567891011121314151617class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int tmpSum = 0, min = Integer.MAX_VALUE, minPoint = 0; for (int i = 0; i &lt; gas.length; i++) &#123; tmpSum += gas[i] - cost[i]; if (tmpSum &lt; min) &#123; min = tmpSum; minPoint = i; &#125; &#125; if (tmpSum &lt; 0) &#123; return -1; &#125; else &#123; return (minPoint + 1) % gas.length; //如果到底了，自动回到 0 站点 &#125; &#125;&#125; 136. Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 123&gt; Input: [2,2,1]&gt; Output: 1&gt; &gt; Example 2: 123&gt; Input: [4,1,2,1,2]&gt; Output: 4&gt; 123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int a = 0; for( int i = 0; i &lt; nums.length; i++ )&#123; a ^= nums[i]; &#125; return a; &#125;&#125; 1234567891011121314151617181920212223242526272829class Solution &#123; public int singleNumber(int[] nums) &#123; if(nums.length==0)return -1; if(nums.length==1)return nums[0]; Arrays.sort(nums); for(int i=0;i&lt;nums.length-1;i+=2)&#123; if(nums[i]!=nums[i+1]) return nums[i]; &#125; return nums[nums.length-1]; &#125;&#125;class Solution &#123; public int singleNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0;i&lt;nums.length;i++) &#123; int value = nums[i]; if(set.contains(value)) &#123; set.remove(value); &#125;else &#123; set.add(value); &#125; &#125; return set.iterator().next(); &#125;&#125; 137. Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 123&gt; Input: [2,2,3,2]&gt; Output: 3&gt; &gt; Example 2: 123&gt; Input: [0,1,0,1,0,1,99]&gt; Output: 99&gt; 通用做法，统计所有数字各个对应位1的总数，如第i位1的总数不是3的整数(此处余1)，说明那个特殊数字在该位置是1，遍历所有位，如此则能统计该数每个位上是0还是1,最终得到the single one 的值。 更效率的办法是模仿数电，使用真值表求出表达式 但是需要比较熟悉， 12345678910111213141516171819class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; int mask = 1; while(mask != 0)&#123; int count = 0; for(int x : nums)&#123; if((x &amp; mask) != 0)&#123; count ++; &#125; &#125; if(count % 3 == 1)&#123; result = result | mask; &#125; mask = mask &lt;&lt; 1; &#125; return result; &#125;&#125; 12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int high = 0, low = 0; for(int x : nums)&#123; low = low ^ x &amp; ~ high; high = high ^ x &amp; ~low; &#125; return low; &#125;&#125; 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Example 1: 1234567&gt; Input:&gt; &#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;&gt; &gt; Explanation:&gt; Node 1&apos;s value is 1, both of its next and random pointer points to Node 2.&gt; Node 2&apos;s value is 2, its next pointer points to null and its random pointer points to itself.&gt; &gt; Note: You must return the copy of the given head as a reference to the cloned list. 123456789101112131415161718192021222324252627282930/*// Definition for a Node.class Node &#123; public int val; public Node next; public Node random; public Node() &#123;&#125; public Node(int _val,Node _next,Node _random) &#123; val = _val; next = _next; random = _random; &#125;&#125;;*/class Solution &#123; private Map&lt;Node, Node&gt; map = new HashMap(); public Node copyRandomList(Node head) &#123; if(head == null) return null; if(map.containsKey(head))&#123; return map.get(head); &#125; Node copyHead = new Node(head.val); map.put(head, copyHead); copyHead.random = copyRandomList(head.random); copyHead.next = copyRandomList(head.next); return copyHead; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334class Solution &#123; /** * 复制带随机指针的链表 * 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 * 对每个node复制，插入到其他node的后面，新旧交替成为重复链表，遍历每个旧node复制随机指针，将新旧两个链表叉开，返回新的链表 */ public Node copyRandomList(Node head) &#123; if (head == null) return head; Node node = head; while (node != null) &#123; //复制链表 Node newNode = new Node(node.val,null,null); newNode.next = node.next; node.next = newNode; node = newNode.next; &#125; node = head; while (node != null) &#123; //复制随机指针 if (node.random != null) node.next.random = node.random.next; //应指向对应的复制节点 node = node.next.next; &#125; Node newHead = head.next; node = head; while (node != null) &#123; //拆分链表 Node newNode = node.next; node.next = newNode.next; if (newNode.next != null) &#123; newNode.next = newNode.next.next; &#125; node = node.next; &#125; return newHead; &#125;&#125; 139. Word Break Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: 1234&gt; Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]&gt; Output: true&gt; Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.&gt; &gt; Example 2: 12345&gt; Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]&gt; Output: true&gt; Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.&gt; Note that you are allowed to reuse a dictionary word.&gt; &gt; Example 3: 123&gt; Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]&gt; Output: false&gt; 通过遍历从0到i的子串是否存在于字典，result[i] 为true表示0到i能够完成拆分 12345678910111213141516class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;// 当前方法会造成优先匹配短的，所以会出问题 boolean[] result = new boolean[s.length() + 1]; result[0] = true; for(int i = 0; i &lt;= s.length(); i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(result[j] &amp;&amp; wordDict.contains(s.substring(j, i)))&#123; result[i] = true; break; &#125; &#125; &#125; return result[s.length()]; &#125;&#125; 原理类似，进行优化。先得出字典中字符串最大长度，优先查找长串（背包先装大的） 同时Set在查找效率上比List高(判断contains的时候) 1234567891011121314151617181920212223class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] result = new boolean[s.length() + 1]; HashSet&lt;String&gt; dict = new HashSet&lt;&gt;(wordDict); //使用的hash，查找效率比List高 result[0] = true; int maxLen = 0; for(String word : wordDict)&#123; if(maxLen &lt; word.length())&#123; maxLen = word.length(); &#125; &#125; for(int i = 0; i &lt;= s.length(); i++)&#123; for(int j = Math.max(0, i - maxLen - 1); j &lt; i; j++)&#123; if(result[j] &amp;&amp; dict.contains(s.substring(j, i)))&#123; result[i] = true; break; &#125; &#125; &#125; return result[s.length()]; &#125;&#125; 142. Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 1234&gt; Input: head = [3,2,0,-4], pos = 1&gt; Output: tail connects to node index 1&gt; Explanation: There is a cycle in the linked list, where tail connects to the second node.&gt; &gt; Example 2: 1234&gt; Input: head = [1,2], pos = 0&gt; Output: tail connects to node index 0&gt; Explanation: There is a cycle in the linked list, where tail connects to the first node.&gt; &gt; Example 3: 1234&gt; Input: head = [1], pos = -1&gt; Output: no cycle&gt; Explanation: There is no cycle in the linked list.&gt; &gt; 使用快慢指针，快的每次走两步，慢的一步，相遇时，快指针所走的路程是慢指针路程2倍 假设非环段长度为 a ，环部分长度为b, 假设相遇时距离环节点x 慢指针路程 s1 = a + mb + x （讲道理，慢指针应该没走满一圈） 快指针路程为 s2 = a + nb + x 由于有 s2 = 2 * s1 则可得 a + x = (n - 2m) b 假设此时 再走 a 步数，则有s2 + a = a + (2n - 2m)b, 即 a + n圈，正好回到环点 而从头部到达环点正好需要走 a 步， 即此时从头部出发，另一个从之前相遇点出发，都一次一步，能够同时到达环点 12345678910111213141516171819202122232425public class Solution &#123; // A+B+N = 2A+2B // N=A+B public ListNode detectCycle(ListNode head) &#123; if(head == null || head.next == null)&#123; return null; &#125; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; //快节点和快节点的next节点不为空时可能有环 fast = fast.next.next; if(fast == null) return null; slow = slow.next; if(slow == fast)&#123; //相等时才有环 while(slow != head &amp;&amp; slow != null)&#123; head = head.next; slow = slow.next; &#125; return slow; &#125; &#125; return null; &#125;&#125; 143. Reorder List Given a singly linked list L: L0→L1→…→L**n-1→Ln,reorder it to: L0→L**n→L1→L**n-1→L2→L**n-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: 12&gt; Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.&gt; &gt; Example 2: 12&gt; Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.&gt; 利用快慢指针快速定位，将链表分成两部分 将后半部分链表反转 将两部分量表合并 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if(head == null || head.next == null)return ; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; ListNode part1Point = head; ListNode part2Point = reverse(slow.next); slow.next = null; while(part1Point != null &amp;&amp; part2Point != null)&#123; ListNode part1next = part1Point.next; ListNode part2next = part2Point.next; part1Point.next = part2Point; part2Point.next = part1next; part1Point = part1next; part2Point = part2next; &#125; &#125; private ListNode reverse(ListNode head)&#123; ListNode prev = null; ListNode cur = head; ListNode next = head; while(cur != null)&#123; next = cur.next; cur.next = prev; prev = cur; cur = next; &#125; return prev; &#125;&#125; 144. Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes’ values. Example: 123456789&gt; Input: [1,null,2,3]&gt; 1&gt; \&gt; 2&gt; /&gt; 3&gt; &gt; Output: [1,2,3]&gt; &gt; Follow up: Recursive solution is trivial, could you do it iteratively? 递归 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;Integer&gt; result = new ArrayList(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root != null )&#123; result.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); &#125; return result; &#125;&#125; 迭代方式 1234567891011121314151617181920class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList(); if(root == null)return result; Stack&lt;TreeNode&gt; stack = new Stack(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); result.add(node.val); if(node.right != null)&#123; stack.push(node.right); &#125; if(node.left != null)&#123; stack.push(node.left); &#125; &#125; return result; &#125;&#125; 145.Binary Tree Postorder Traversal Given a binary tree, return the postorder traversal of its nodes’ values. Example: 123456789&gt; Input: [1,null,2,3]&gt; 1&gt; \&gt; 2&gt; /&gt; 3&gt; &gt; Output: [3,2,1]&gt; &gt; Follow up: Recursive solution is trivial, could you do it iteratively? 递归 1234567891011class Solution&#123; private List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;//递归写法 if(root == null) return res; postorderTraversal(root.left); postorderTraversal(root.right); res.add(root.val); return res; &#125; &#125; 迭代 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList(); if(root == null)return result; Stack&lt;TreeNode&gt; stack = new Stack(); stack.push(root); TreeNode pre = null; while(!stack.isEmpty())&#123; root = stack.peek(); if(root.left ==null &amp;&amp; root.right == null || (pre != null &amp;&amp; (pre == root.left || pre == root.right)))&#123; result.add(root.val); pre = root; stack.pop(); &#125;else&#123; if(root.right != null)stack.push(root.right); if(root.left != null)stack.push(root.left); &#125; &#125; return result; &#125;&#125; 12345678910111213141516class Solution&#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); if(node.left != null) stack.push(node.left);//和传统先序遍历不一样，先将左结点入栈 if(node.right != null) stack.push(node.right);//后将右结点入栈 res.add(0,node.val); //逆序添加结点值 &#125; return res; &#125;&#125; 147. Insertion Sort List Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Example 1: 123&gt; Input: 4-&gt;2-&gt;1-&gt;3&gt; Output: 1-&gt;2-&gt;3-&gt;4&gt; &gt; Example 2: 123&gt; Input: -1-&gt;5-&gt;3-&gt;4-&gt;0&gt; Output: -1-&gt;0-&gt;3-&gt;4-&gt;5&gt; 123456789101112131415161718192021222324252627// 中规中矩的办法/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode preHead = new ListNode(0); while(head != null)&#123; ListNode next = head.next; ListNode insert = preHead; while(insert.next != null &amp;&amp; head.val &gt; insert.next.val)&#123; insert = insert.next; &#125; head.next = insert.next; insert.next = head; head = next; &#125; return preHead.next; &#125;&#125; 归并排序 12345678910111213141516171819202122232425262728class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode fast = head; ListNode slow = head; ListNode pre = null; while (fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; ListNode l1 = insertionSortList(head); ListNode l2 = insertionSortList(slow); return merge(l1, l2); &#125; public static ListNode merge(ListNode l1, ListNode l2) &#123; if (l1 == null || l2 == null) return l1 == null ? l2 : l1; if (l1.val &lt; l2.val) &#123; l1.next = merge(l1.next, l2); return l1; &#125; else &#123; l2.next = merge(l1, l2.next); return l2; &#125; &#125;&#125; 148. Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: 123&gt; Input: 4-&gt;2-&gt;1-&gt;3&gt; Output: 1-&gt;2-&gt;3-&gt;4&gt; &gt; Example 2: 123&gt; Input: -1-&gt;5-&gt;3-&gt;4-&gt;0&gt; Output: -1-&gt;0-&gt;3-&gt;4-&gt;5&gt; 貌似是合格的，但是没太详细看，用的貌似是 Java 11 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution &#123; public ListNode SortList(ListNode head) &#123; if (head == null) return null; var n = 0; for (var current = head; current != null; current = current.next) n += 1; var dummy1 = new ListNode(-1); dummy1.next = head; var dummy2 = new ListNode(-1); for (var m = 1; m &lt; n; m *= 2) &#123; var prev1 = dummy1; while (prev1.next != null) &#123; // Grab up to the next m items into list1. var list1 = prev1.next; var prev2 = list1; for (var i = 0; i &lt; m - 1 &amp;&amp; prev2 != null; i++) prev2 = prev2.next; if (prev2 == null) break; // Grab up to the next m items into list2. var list2 = prev2.next; var prev3 = list2; for (var i = 0; i &lt; m - 1 &amp;&amp; prev3 != null; i++) prev3 = prev3.next; // Save the remaining items, if any. var list3 = prev3 != null ? prev3.next : null; // Terminate list1 and list2. prev2.next = null; if (prev3 != null) prev3.next = null; // Merge the two lists, terminating with remaining items. (prev1.next, prev1) = Merge(dummy2, list1, list2, list3); &#125; &#125; return dummy1.next; &#125; private (ListNode, ListNode) Merge(ListNode dummy, ListNode list1, ListNode list2, ListNode list3) &#123; var prev = dummy; while (list1 != null || list2 != null) &#123; var first = false; if (list1 == null) first = false; else if (list2 == null) first = true; else first = list1.val &lt;= list2.val; if (first) &#123; prev.next = list1; list1 = list1.next; &#125; else &#123; prev.next = list2; list2 = list2.next; &#125; prev = prev.next; &#125; prev.next = list3; return (dummy.next, prev); &#125;&#125; 归并排序，在空间要求上实际上是不合理的 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode prev = null; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; ListNode list1 = sortList(head); ListNode list2 = sortList(slow); return merge(list1, list2); &#125; private ListNode merge(ListNode node1, ListNode node2)&#123; if(node1 == null || node2 == null)return node1 == null ? node2 : node1; if(node1.val &lt; node2.val)&#123; node1.next = merge(node1.next, node2); return node1; &#125;else&#123; node2.next = merge(node2.next, node1); return node2; &#125; &#125;&#125; Method-150. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: 1234&gt; Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]&gt; Output: 9&gt; Explanation: ((2 + 1) * 3) = 9&gt; &gt; Example 2: 1234&gt; Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]&gt; Output: 6&gt; Explanation: (4 + (13 / 5)) = 6&gt; &gt; Example 3: 1234567891011&gt; Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]&gt; Output: 22&gt; Explanation: &gt; ((10 * (6 / ((9 + 3) * -11))) + 17) + 5&gt; = ((10 * (6 / (12 * -11))) + 17) + 5&gt; = ((10 * (6 / -132)) + 17) + 5&gt; = ((10 * 0) + 17) + 5&gt; = (0 + 17) + 5&gt; = 17 + 5&gt; = 22&gt; 真是的，Postfix Expression 后缀表达式，说 逆波兰表达式 我一脸懵逼。。。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 中规中矩的办法class Solution &#123; public int evalRPN(String[] tokens) &#123; if(null == tokens || tokens.length == 0) return 0; Stack&lt;Integer&gt; stack = new Stack(); Set&lt;String&gt; calSign = new HashSet&lt;String&gt;()&#123; &#123; add("+"); add("-"); add("*"); add("/"); &#125; &#125;; for(String token : tokens)&#123; if(calSign.contains(token))&#123; int b = stack.pop(); int a = stack.pop(); stack.push(cal(a, b, token)); &#125;else&#123; stack.push(Integer.parseInt(token)); &#125; &#125; return stack.pop(); &#125; private int cal(int a, int b, String op)&#123; int result = 0; switch(op)&#123; case "+": result = a + b; break; case "-": result = a - b; break; case "*": result = a * b; break; case "/": result = a / b; break; &#125; return result; &#125;&#125; 递归版本 12345678910111213141516171819202122class Solution &#123; private int N =-1; public int evalRPN(String[] tokens) &#123; if(N==-1) N=tokens.length-1; String s = tokens[N--]; char c = s.charAt(0); if(s.length()==1&amp;&amp;"+-*/".indexOf(c)!=-1)&#123; int a = evalRPN(tokens); int b = evalRPN(tokens); switch(c)&#123; case '+':return a+b; case '-':return b-a; case '*':return a*b; case '/':return b/a; default:break; &#125; &#125; return Integer.parseInt(s); &#125;&#125; 151. Reverse Words in a String Given an input string, reverse the string word by word. Example 1: 123&gt; Input: &quot;the sky is blue&quot;&gt; Output: &quot;blue is sky the&quot;&gt; &gt; Example 2: 1234&gt; Input: &quot; hello world! &quot;&gt; Output: &quot;world! hello&quot;&gt; Explanation: Your reversed string should not contain leading or trailing spaces.&gt; &gt; Example 3: 1234&gt; Input: &quot;a good example&quot;&gt; Output: &quot;example good a&quot;&gt; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.&gt; &gt; Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. Follow up: For C programmers, try to solve it in-place in O(1) extra space. 1234567891011121314151617181920// 笨方法class Solution &#123; public String reverseWords(String s) &#123; StringBuilder sb = new StringBuilder(); char pre = ' '; for(int i = 0; i &lt; s.length(); i ++)&#123; char cur = s.charAt(i); if(cur == ' ' &amp;&amp; pre == ' ')continue; pre = cur; sb.append(cur); &#125; String[] words = sb.toString().trim().split(" "); sb = new StringBuilder(); for(int i = words.length -1; i &gt; 0; i --)&#123; sb.append(words[i]).append(" "); &#125; sb.append(words[0]); return sb.toString(); &#125;&#125; 1234567891011121314151617// 通过两个数来定位 单词的 始末位置， 由后往前遍历class Solution &#123; public String reverseWords(String s) &#123; StringBuilder builder = new StringBuilder(s.length()); int i = s.length() - 1; while (i &gt;= 0) &#123; while (i &gt;= 0 &amp;&amp; s.charAt(i) == ' ') i--; if (i == -1) break; int j = s.lastIndexOf(' ', i); //从位置 i 开始， 从后往前找出 ' ' 第一次出现的位置 builder.append(s.substring(j + 1, i + 1) + " "); i = j - 1; &#125; if (builder.length() &gt; 0) builder.deleteCharAt(builder.length() - 1); return builder.toString(); &#125;&#125; Means - 152. Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 1234&gt; Input: [2,3,-2,4]&gt; Output: 6&gt; Explanation: [2,3] has the largest product 6.&gt; &gt; Example 2: 1234&gt; Input: [-2,0,-1]&gt; Output: 0&gt; Explanation: The result cannot be 2, because [-2,-1] is not a subarray.&gt; 动态规划，由于题目要求连续，故而只需保留当前和前一步的状态即可 123456789101112class Solution &#123; public int maxProduct(int[] nums) &#123; int max = Integer.MIN_VALUE, imax = 1, imin = 1; //一个保存最大的，一个保存最小的。 for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i] &lt; 0)&#123; int tmp = imax; imax = imin; imin = tmp;&#125; //如果数组的数是负数，那么会导致最大的变最小的，最小的变最大的。因此交换两个的值。 imax = Math.max(imax*nums[i], nums[i]);// 假如存在 0， 则会刷新当前子集 积 imin = Math.min(imin*nums[i], nums[i]); max = Math.max(max, imax); &#125; return max; &#125;&#125; 自身逻辑不擅长此类—153. Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 123&gt; Input: [3,4,5,1,2] &gt; Output: 1&gt; &gt; Example 2: 123&gt; Input: [4,5,6,7,0,1,2]&gt; Output: 0&gt; 1234567891011121314151617181920class Solution &#123; public int findMin(int[] nums) &#123; if(nums.length == 1)return nums[0]; int start = 0; int end = nums.length -1; if(nums[start] &lt;= nums[end])return nums[start];// 用于过滤有序数组 int mid = 0; while(start &lt; end &amp;&amp; end - start &gt; 1)&#123;// 不添加 end - start &gt; 1 有可能会陷入死循环 mid = start + (end - start) / 2; if(nums[start] &gt; nums[end])&#123; if(nums[mid] &gt; nums[start])&#123; start = mid; // 这里不能写 start = mid + 1; 因为可能nums[mid+1]正好是最小值而陷入死循环 &#125;else&#123; end = mid;// 同理不能写 end = nums[mid - 1],否则可能造成死循环 &#125; &#125; &#125; return Math.min(nums[start], nums[end]); &#125;&#125; 123456789101112131415161718class Solution &#123; public int findMin(int[] nums) &#123; int start = 0; int end = nums.length -1; if(nums[start] &lt;= nums[end])return nums[start]; int mid = 0; while(start &lt;= end)&#123; mid = start + (end - start) / 2;; if(nums[mid] &gt; nums[mid + 1])return nums[mid+1]; // 这一步为了避免造成死循环 if(nums[mid] &gt; nums[start])&#123;// nums[mid] &gt; nums[start]已经保证了 nums[start] &gt; nums[end] start = mid + 1; &#125;else&#123; end = mid - 1; &#125; &#125; return nums[0]; &#125;&#125; 源码的重要性—155. Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. getMin() — Retrieve the minimum element in the stack. Example: 123456789&gt; MinStack minStack = new MinStack();&gt; minStack.push(-2);&gt; minStack.push(0);&gt; minStack.push(-3);&gt; minStack.getMin(); --&gt; Returns -3.&gt; minStack.pop();&gt; minStack.top(); --&gt; Returns 0.&gt; minStack.getMin(); --&gt; Returns -2.&gt; 有很多人使用两个栈解决这个问题，感觉有点投机， 我第一遍做的时候，用的List,后面看答案的时候，觉得下面这个最合题意，某方面来说就是仿的jdk源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MinStack &#123; private int capacity; private int size; private int[] data; private int[] min; public MinStack() &#123; capacity = 4; size = 0; data = new int[capacity]; min = new int[capacity]; &#125; public void push(int x) &#123; if (size &gt;= capacity) &#123; expand(); &#125; int min = size &gt; 0 ?this.min[size-1] : Integer.MAX_VALUE; data[size] = x; this.min[size++] = x &gt; min ? min : x; //记录size为指定值时的最小值，如果移除值，只是根据size移动下标即可 &#125; public void pop() &#123; size--; &#125; public int top() &#123; return size &gt; 0 ? data[size-1] : -1; &#125; public int getMin() &#123; return size &gt; 0 ? min[size-1] : -1; &#125; private void expand() &#123; int newCapacity = capacity * 2; int[] newData = new int[newCapacity]; int[] newMin = new int[newCapacity]; System.arraycopy(data, 0, newData, 0, capacity); System.arraycopy(min, 0, newMin, 0, capacity); capacity = newCapacity; data = newData; min = newMin; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 160. Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: 1234&gt; Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3&gt; Output: Reference of the node with value = 8&gt; Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.&gt; &gt; Example 2: 1234&gt; Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1&gt; Output: Reference of the node with value = 2&gt; Input Explanation: The intersected node&apos;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.&gt; &gt; Example 3: 12345&gt; Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2&gt; Output: null&gt; Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.&gt; Explanation: The two lists do not intersect, so return null.&gt; &gt; Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(null == headA || null == headB)return null; ListNode curA = headA; ListNode curB = headB; while(curA != curB)&#123; curA = curA == null ? headB : curA.next; curB = curB == null ? headA : curB.next; &#125; return curA; &#125;&#125; 162. Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: 1234&gt; Input: nums = [1,2,3,1]&gt; Output: 2&gt; Explanation: 3 is a peak element and your function should return the index number 2.&gt; &gt; Example 2: 12345&gt; Input: nums = [1,2,1,3,5,6,4]&gt; Output: 1 or 5 &gt; Explanation: Your function can return either index number 1 where the peak element is 2, &gt; or index number 5 where the peak element is 6.&gt; &gt; Note: Your solution should be in logarithmic complexity. 二分法在变更起点和终点的时候应结合实际情况灵活变更 O(logN)一般考虑二分搜索 如果nums[i] &gt; nums[i+1]，则在i之前一定存在峰值元素 如果nums[i] &lt; nums[i+1]，则在i+1之后一定存在峰值元素 1234567891011121314151617181920class Solution &#123; public int findPeakElement(int[] nums) &#123; if(nums == null || 0 == nums.length)return 0; int length = nums.length; int start = 0; int end = length - 1; while(start &lt; end)&#123; int mid = start + ((end - start) &gt;&gt;&gt; 1); if( nums[mid] &gt; nums[mid + 1] )&#123; // mid 可能是峰值点，如果此处直接写mid + 1,则应在前面判断mid是否为峰值点 end = mid; &#125;else&#123; // mid 一定不是峰值点，如果此处写mid的话，最后可能需要从 start 和 end 之间判断哪个是峰值点 start = mid + 1; &#125; &#125; return left; &#125;&#125; 165. Compare Version Numbers Compare two version numbers version1 and version2.If version1 &gt; version2 return 1; if version1 &lt; version2 return -1; otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0. Example 1: 123&gt; Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;&gt; Output: -1&gt; &gt; Example 2: 123&gt; Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;&gt; Output: 1&gt; &gt; Example 3: 123&gt; Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;&gt; Output: -1&gt; &gt; Example 4: 1234&gt; Input: version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;&gt; Output: 0&gt; Explanation: Ignoring leading zeroes, both “01” and “001&quot; represent the same number “1”&gt; &gt; Example 5: 1234&gt; Input: version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;&gt; Output: 0&gt; Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to &quot;0&quot;&gt; &gt; Note: Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. Version strings do not start or end with dots, and they will not be two consecutive dots. 最不费脑的方法是用split分成数组，比较烧时间，但是容易理解 12345678910111213141516171819202122232425262728293031class Solution &#123; public int compareVersion(String version1, String version2) &#123; String[] v1 = version1.split("\\."); String[] v2 = version2.split("\\."); int length = v1.length &lt; v2.length ? v1.length : v2.length; int v1product = 0; int v2product = 0; for(int i = 0; i &lt; length; i++)&#123;//先将相同段进行计数计算，如 7.5.2 ==&gt; 752 v1product = v1product * 10 + Integer.parseInt(v1[i]); v2product = v2product * 10 + Integer.parseInt(v2[i]); if(v1product != v2product)return v1product - v2product &gt; 0 ? 1 : -1; &#125; // 如果前面值不等于0 判断后面长度数值 计数值,如果比较大于 if(v1.length &gt; v2.length)&#123; for(int i = v2.length; i &lt; v1.length; i++)&#123; int tmp = Integer.parseInt(v1[i]); if(tmp == 0)continue; return 1; &#125; &#125; if(v1.length &lt; v2.length)&#123; for(int i = v1.length; i &lt; v2.length; i++)&#123; int tmp = Integer.parseInt(v2[i]); if(tmp == 0)continue; return -1; &#125; &#125; return 0; &#125;&#125; 这个是榜单最佳 123456789101112131415class Solution &#123; public int compareVersion(String version1, String version2) &#123; if(version1 == null || version2 == null) return 0; char[] v1 = version1.toCharArray(); char[] v2 = version2.toCharArray(); for (int i = 0,j = 0;i &lt; v1.length || j &lt; v2.length;i++,j++)&#123; int ver1 = 0, ver2 = 0; for (;i&lt;v1.length &amp;&amp; v1[i]!='.';i++) ver1 = ver1 * 10 + v1[i] - '0'; for (;j&lt;v2.length &amp;&amp; v2[j]!='.';j++) ver2 = ver2 * 10 + v2[j] - '0'; if(ver1 &lt; ver2) return -1; else if(ver1 &gt; ver2) return 1; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse-J2EE项目设置]]></title>
    <url>%2F2019%2F04%2F13%2Feclipse-J2EE%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于eclipse建立Web项目后，一些文件夹作用及相关参数设置，做笔记以便后续查阅 当前主要使用两种方式建立Web项目: Maven Project 和 Dynamic Web Project 项目配置文件 Dynamic Web Project 如图，在建立项目后，文件夹内会生成途中的文件夹和相关参数文件，一般在使用Git和Svn同步项目的时候，只会同步src/和WebContent/两个文件夹，其他文件都不做同步。 .settings: 保存项目web的相关参数，如：Project Facets等 build：默认会将编译生成后的内容保存在build/文件夹 src: 存放源码的文件夹，有时候为了方便也会选择自己建立其他文件夹名，只要将其设置为Source Folder就可以了，一般默认会将source Folder的内容生成至classpath(/WEB-INF/classes)。 WebContent：存放除源码等文件外的所有文件，如前端页面、静态资源、部分配置文件等，这个文件夹从文件结构来说，相当于项目发布后的根目录(/)，很多资源文件，都是相对这个文件夹来确定位置。 关于项目根目录下eclipse配置文件的详细介绍 Maven Web Project 与Dynamic Web Project稍有不同的是： WebContent对应这里的Webapp build对应这里的target 同时所在的路径有所不同。不过最后发布后的路径和设置有关，故而实际上是一样的。 需要注意的是：这里的resources默认是source folder，也就是会发布到classpath路径下，一般用于存放配置文件。前端可能会在Webapp下新建resources文件夹，用于存放静态文件和这个是不同的（只是名字一样），注意别放错位置了。 Source Foler：存放源代码及配套的配置文件，默认将其文件夹中的内容发布在classpath下。在idea中也类似如此，只有标记为Source Folder的文件夹里面才可以新建包（本质上都是文件夹，但是显示时不一样） 同理，在配置spring相关配置文件，设计到文件资源路径的时候，主要通过根目录(Webapp/WebContent)和classpath以相对路径描述资源路径。]]></content>
      <categories>
        <category>tools</category>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode note - part 2]]></title>
    <url>%2F2019%2F04%2F09%2FLeetCode-note-part-2%2F</url>
    <content type="text"><![CDATA[刷LeetCode笔记2 54. Spiral Matrix第一次做的时候，会多加或者漏了最里面的行或者列 Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 12345678910&gt; Example 1:&gt; &gt; Input:&gt; [&gt; [ 1, 2, 3 ],&gt; [ 4, 5, 6 ],&gt; [ 7, 8, 9 ]&gt; ]&gt; Output: [1,2,3,6,9,8,7,4,5]&gt; 12345678910&gt; Example 2:&gt; &gt; Input:&gt; [&gt; [1, 2, 3, 4],&gt; [5, 6, 7, 8],&gt; [9,10,11,12]&gt; ]&gt; Output: [1,2,3,4,8,12,11,10,9,5,6,7]&gt; 1234567891011121314151617181920212223242526272829303132333435// my ac with great difficultyclass Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int m = matrix.length; if(m == 0) return list; int n = matrix[0].length; if(n == 0 )return list; int minLength = Math.min(m,n); for(int i = 0; i &lt;= (minLength - 1)/2; i++)&#123; //往右 for(int j = i; j &lt;= n - i -1; j++)&#123; list.add(matrix[i][j]); &#125; //往下 for(int j = i + 1; j &lt;= m - i -1;j++)&#123; list.add(matrix[j][n - i -1]); &#125; //往左 if(i != m -i -1)&#123; // 即当i == ( m-1 )/2,当行数为奇数行时，最后一次只有向右，没有向左 for(int j = n - i -2; j &gt;= i; j--)&#123; list.add(matrix[m -i -1][j]); &#125; &#125; //往上 if(i != n -i -1)&#123;// 即当i == ( n-1 )/2,当列数为奇数列时，最后一次只有向下，没有向上 for(int j = m - i -2; j &gt;= i + 1; j--)&#123; list.add(matrix[j][i]); &#125; &#125; &#125; return list; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list=new ArrayList(); if(matrix.length==0) return list; int startX=0; int startY=0; int endX=matrix[0].length-1; int endY=matrix.length-1; while(startX&lt;=endX&amp;&amp;startY&lt;=endY)&#123; //如果只有一列 if(startX==endX)&#123; for(int i=startY;i&lt;=endY;i++)&#123; list.add(matrix[i][endX]); &#125; return list; &#125; //如果只有一行 if(startY==endY)&#123; for(int i=startX;i&lt;=endX;i++)&#123; list.add(matrix[endY][i]); &#125; return list; &#125; //遍历StartX-&gt;endX for(int i=startX;i&lt;endX;i++)&#123; list.add(matrix[startY][i]); &#125; //遍历startY-&gt;endY for(int i=startY;i&lt;endY;i++)&#123; list.add(matrix[i][endX]); &#125; //遍历endX-&gt;startX for(int i=endX;i&gt;startX;i--)&#123; list.add(matrix[endY][i]); &#125; //遍历endY-&gt;startY for(int i=endY;i&gt;startY;i--)&#123; list.add(matrix[i][startX]); &#125; startX++; startY++; endX--; endY--; &#125; return list; &#125;&#125; 55. Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index. 123456&gt; Example 1:&gt; &gt; Input: [2,3,1,1,4]&gt; Output: true&gt; Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.&gt; 1234567&gt; Example 2:&gt; &gt; Input: [3,2,1,0,4]&gt; Output: false&gt; Explanation: You will always arrive at index 3 no matter what. Its maximum&gt; jump length is 0, which makes it impossible to reach the last index.&gt; 123456789101112131415161718192021222324// my acclass Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length &gt; 1 &amp;&amp; nums[0] == 0)return false; int[] jumped = new int[nums.length]; int curIndex = 0; while(curIndex &lt; nums.length)&#123; int curVal = nums[curIndex]; if(curIndex + curVal &gt;= nums.length -1)&#123; return true; &#125; jumped[curIndex] = 1; curIndex = curIndex + curVal; if(nums[curIndex] == 0)&#123; while(curIndex &gt;= 0 &amp;&amp; jumped[curIndex] == 1)&#123; curIndex --; &#125; &#125; if(curIndex &lt;0)return false; &#125; return true; &#125;&#125; 123456789101112131415// best ac o(n)算法/** * if jumping from index 0 to the end could achieve, * then jumping from the end to index 0 could also achieve. */class Solution &#123; public boolean canJump(int[] nums) &#123; int index = nums.length - 2,right = nums.length - 1; while(index &gt;= 0)&#123; if(index + nums[index] &gt;= right) right = index;//只有满足条件，才更新right 下标值 index--; &#125; return right == 0;//index可能小于0 &#125;&#125; 56. Merge Intervals Given a collection of intervals, merge all overlapping intervals.Attention : the order of list is not ensured123456&gt; Example 1:&gt;&gt; Input: [[1,3],[2,6],[8,10],[15,18]]&gt; Output: [[1,6],[8,10],[15,18]]&gt; Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].&gt; 123456&gt; Example 2:&gt;&gt; Input: [[1,4],[4,5]]&gt; Output: [[1,5]]&gt; Explanation: Intervals [1,4] and [4,5] are considered overlapping.&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041// my ac 17ms, 使用了自定义集合排序/*Definition for an interval.*/public class Interval &#123; int start; int end; Interval() &#123; start = 0; end = 0; &#125; Interval(int s, int e) &#123; start = s; end = e; &#125; &#125;class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; list = new ArrayList&lt;&gt;(); if(0 == intervals.size())return list; Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval o1, Interval o2)&#123; if(o1.start == o2.start)&#123; return o1.end - o2.end; &#125;else&#123; return o1.start -o2.start; &#125; &#125; &#125;); Interval first = intervals.get(0); list.add(new Interval(first.start, first.end)); for(int i = 1 ; i &lt; intervals.size(); i ++)&#123; Interval former = list.get(list.size()-1); Interval latter = intervals.get(i); if(former.end &gt;= latter.start)&#123; former.end = Math.max(former.end, latter.end); former.start = Math.min(former.start, latter.start); &#125;else &#123; list.add(new Interval(latter.start, latter.end)); &#125; &#125; return list; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// 10ms/** * 两层循环，在O(n*n)遍历过程中合并所有能合并的Interval */class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; list=new ArrayList&lt;Interval&gt;(); Interval L=new Interval();//一层循环保存对象 Interval R=new Interval();//二层循环保存对象 for(int i=0;i&lt;intervals.size();i++)&#123; L=intervals.get(i); int j=i+1; for(;j&lt;intervals.size();j++)&#123; R=intervals.get(j); if(R.start==L.start)&#123; intervals.set(j,new Interval(L.start,Math.max(L.end,R.end))); break; &#125;else if(L.start&lt;R.start)&#123; if(L.end&gt;=R.start)&#123; Interval inter=new Interval(L.start,Math.max(L.end,R.end)); intervals.set(j,inter); break; &#125; &#125;else&#123; if(R.end&gt;=L.start)&#123; Interval inter=new Interval(R.start,Math.max(L.end,R.end)); intervals.set(j,inter); break; &#125; &#125; &#125; if(j&gt;=intervals.size())&#123; list.add(intervals.get(i)); &#125; &#125; return list; &#125; &#125; 123456789101112131415161718192021222324252627// 11ms, 通过数域的性质，只用关心起始和终止点，直接进行拼接即可，较难想到class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; res=new ArrayList&lt;&gt;(); int len=intervals.size(); int[] start=new int[len]; int[] end=new int[len]; int i=0; for(Interval interval:intervals)&#123; start[i]=interval.start; end[i]=interval.end; i++; &#125; Arrays.sort(start); Arrays.sort(end); int j=0; for(i=0,j=0;i&lt;len;i++)&#123; if(i&lt;len-1 &amp;&amp; end[i]&lt;start[i+1])&#123; res.add(new Interval(start[j],end[i])); j=i+1; &#125;else if(i==len-1)&#123; res.add(new Interval(start[j],end[i])); &#125; &#125; return res; &#125;&#125; 59. Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3Output:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] matrix = new int[n][n]; int minLength = (n-1)/2; int value = 1; for(int i = 0; i &lt;= minLength; i++)&#123; //right--&gt; for(int j = i; j &lt;= n -i -1; j++)&#123; matrix[i][j] = value; value ++; &#125; //down for(int j = i + 1; j &lt;= n - i -1; j++)&#123; matrix[j][n -i -1] = value; value ++; &#125; if(i != n -i -1 )&#123;//注意，此处和 i != minLength 是两码事，原因在于int计算取证 // left &lt;-- for(int j = n - i -2; j &gt;= i; j--)&#123; matrix[n - i -1][j] = value; value ++; &#125; //up for(int j = n -i -2; j &gt; i; j--)&#123; matrix[j][i] = value; value ++; &#125; &#125; &#125; return matrix; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] matrix = new int[n][n]; int end = n - 1; int start = 0, i = 0, j = 0; int value = 1; while(start &lt;= end)&#123; //right while(j &lt;= end)&#123; matrix[i][j++] = value++; &#125; i++; j--;//每次进行完赋值后，对下标进行修正 //down while(i &lt;= end)&#123; matrix[i++][j] = value ++; &#125; i--; j--;//每次进行完赋值后，对下标进行修正 // left while(j &gt;= start)&#123; matrix[i][j--] = value ++; &#125; j++; i--;//每次进行完赋值后，对下标进行修正 // up while(i &gt; start)&#123; matrix[i--][j] = value ++; &#125; j++; i++;//每次进行完赋值后，对下标进行修正 start ++; end --; &#125; return matrix; &#125;&#125; Mark-60. Permutation Sequence康托展开Mark The set [1,2,3,...,*n*] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: 123&gt; Input: n = 3, k = 3&gt; Output: &quot;213&quot;&gt; &gt; Example 2: 123&gt; Input: n = 4, k = 9&gt; Output: &quot;2314&quot;&gt; 123456789101112131415161718192021222324// 需学习康拓展开class Solution &#123; public String getPermutation(int n, int k) &#123; int[] FAC=&#123;1,1,2,6,24,120,720,5040,40320,362880&#125;; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); StringBuilder sb=new StringBuilder(); for(int i=1;i&lt;=n;i++)&#123; list.add(i); &#125; k=k-1; while(n!=0)&#123; int a=k/FAC[n-1]; int r=k%FAC[n-1]; if(a&lt;list.size())&#123; sb.append(list.get(a)); list.remove(a); &#125; k=r;//余数当被除数 n--; &#125; return sb.toString(); &#125; &#125; 61. Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: 123456&gt; Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2&gt; Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; Explanation:&gt; rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL&gt; rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; &gt; Example 2: 12345678&gt; Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4&gt; Output: 2-&gt;0-&gt;1-&gt;NULL&gt; Explanation:&gt; rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL&gt; rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL&gt; rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL&gt; rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL&gt; 12345678910111213141516171819202122232425262728293031323334// My Ac/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if(null ==head)return head; if(head.next == null)return head; int listSize = 1; ListNode pointer = head; while(pointer.next != null)&#123; pointer = pointer.next; listSize++; &#125; k = k % listSize; for(int i = 0; i &lt; k ; i++)&#123; pointer = head; while(pointer.next.next != null)&#123; pointer = pointer.next; &#125; ListNode last = pointer.next; pointer.next = null; last.next = head; head = last; &#125; return head; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// best ac// 将链表先收尾相连成一个环，位移后，再重新拆环/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;public ListNode rotateRight(ListNode head, int k) &#123; if(head==null||k==0)&#123; return head; &#125; ListNode cursor=head; ListNode tail=null;//尾指针 int length=1; while(cursor.next!=null)//循环 得到总长度 &#123; cursor=cursor.next; length++; &#125; int loop=length-(k%length);//得到循环的次数 tail=cursor;//指向尾结点 cursor.next=head;//改成循环链表 cursor=head;//指向头结点 for(int i=0;i&lt;loop;i++)&#123;//开始循环 cursor=cursor.next; tail=tail.next; &#125; tail.next=null;//改成单链表 return cursor;//返回当前头 &#125;&#125; Mark-62. Unique PathsMark,结果溢出 A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: 12345678&gt; Input: m = 3, n = 2&gt; Output: 3&gt; Explanation:&gt; From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:&gt; 1. Right -&gt; Right -&gt; Down&gt; 2. Right -&gt; Down -&gt; Right&gt; 3. Down -&gt; Right -&gt; Right&gt; &gt; Example 2: 123&gt; Input: m = 7, n = 3&gt; Output: 28&gt; 12345678910111213// 不假思索就想到的方法多半是坑，因为阶乘数据太大，很容易计算结果溢出class Solution &#123; public int uniquePaths(int m, int n) &#123; return fac(m + n -2)/(fac(m-1)*fac(n-1)); &#125; public int fac(int n)&#123; if(n == 0 || n== 1)&#123; return 1; &#125;else&#123; return n * fac(n-1); &#125; &#125;&#125; 分析（1）： 由于机器人智能往右或者往下，所以到达(i,j)的方式只有两种：从（i-1,j）往右和从(i,j-1)往下；从而易得出到达（i,j）的路径总数为dp[i][j]=dp[i-1][j]+dp[i][j-1] 分析（2）： 由高中数学可知答案就是$C{m+n-2}^{m-1}$或者$C{m+n-2}^{n-1}$。其中 C_m^n=\frac{m!}{n!*(m-n)!}(1) 如果m或者n较小，结果容易得出，但是由于m，n最大可能100，使用阶乘计算的话溢出是必定的。 同时有性质：$C_{m+1}^{n+1}=C_m^n+C_m^{n+1}$(2)和$C_n^0+C_n^1+C_n^2+C_n^3+…+C_n^n=2^n$(3) 通过式（2），很容易想到这题使用动态规划计算。 假设使用数组dp存储结果，则有：dp[m][n]=$C{m+n-2}^{n-1}=C{m+n-3}^{n-2}+C_{m+n-3}^{n-1}$ 结合公式（2）得出：dp[m][n]=dp[m-1][n]+dp[m][n-1] 注意：dp[m-1][n-1]=$C_{m+n-4}^{n-2}$ 123456789101112131415class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i==0 || j==0)&#123; dp[i][j] = 1; &#125;else&#123; dp[i][j] = dp[i][j-1] + dp[i-1][j]; // dp[i][j]记录着i行j列时的路径数 &#125; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 63. Unique Paths II A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: 12345678910111213&gt; Input:&gt; [&gt; [0,0,0],&gt; [0,1,0],&gt; [0,0,0]&gt; ]&gt; Output: 2&gt; Explanation:&gt; There is one obstacle in the middle of the 3x3 grid above.&gt; There are two ways to reach the bottom-right corner:&gt; 1. Right -&gt; Right -&gt; Down -&gt; Down&gt; 2. Down -&gt; Down -&gt; Right -&gt; Right&gt; 分析：与之前不同，需要判断是否有障碍，有障碍则无法到达该点，即到达该点的路径数为0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; if(obstacleGrid[0][0] ==1)return 0; if(m==1 || n==1)&#123;//这里不额外判断也可以 for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(obstacleGrid[i][j] == 1)&#123; return 0; &#125; &#125; &#125; return 1; &#125; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0 ; j &lt; n; j++)&#123; if(i == 0 &amp;&amp; j &gt; 0)&#123; if(obstacleGrid[i][j] ==0)&#123;//Java创建二维数组的代价非常大，能用现成的尽可能别新建 obstacleGrid[i][j] = obstacleGrid[i][j-1]; &#125;else&#123; obstacleGrid[i][j] = 0; &#125; &#125;else if(i &gt; 0 &amp;&amp; j ==0)&#123; if(obstacleGrid[i][j] ==0)&#123; obstacleGrid[i][j] = obstacleGrid[i-1][j]; &#125;else&#123; obstacleGrid[i][j] = 0; &#125; &#125;else if(i ==0 &amp;&amp; j==0)&#123; obstacleGrid[i][j] = 1; &#125;else&#123; if(obstacleGrid[i][j] ==0)&#123; obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]; &#125;else&#123; obstacleGrid[i][j] = 0; &#125; &#125; &#125; &#125; return obstacleGrid[m-1][n-1]; &#125;&#125; 64. Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: 123456789&gt; Input:&gt; [&gt; [1,3,1],&gt; [1,5,1],&gt; [4,2,1]&gt; ]&gt; Output: 7&gt; Explanation: Because the path 1→3→1→1→1 minimizes the sum.&gt; 分析：这道题，和前面两道题，换汤不换药，一样做。也可以使用递归形式熟悉额，道理都一样 123456789101112131415161718192021// 循环方式class Solution &#123; public int minPathSum(int[][] grid) &#123; //利用dp记录到达某个点的最短长度，因为题目要求只会往右或者往下，不会往回走，只是单向遍历，可以使用动态规划 int row = grid.length; int col = grid[0].length; for(int i = 1; i &lt; row; i++)&#123; grid[i][0] += grid[i-1][0]; &#125; for(int i = 1; i &lt; col; i++)&#123; grid[0][i] += grid[0][i-1]; &#125; for(int i = 1; i &lt; row; i++)&#123; for(int j = 1; j &lt; col; j++)&#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125; &#125; return grid[row-1][col-1]; &#125;&#125; 12345678910111213141516171819202122232425// 递归方式class Solution &#123; private int[][] dp; private int core(int[][] m,int row,int col)&#123; if (row == m.length - 1 &amp;&amp; col == m[0].length - 1) return m[row][col]; if (dp[row][col] != 0) return dp[row][col]; int result = m[row][col]; if (row == m.length - 1)&#123; // 只能右走 result += core(m,row,col + 1); &#125;else if (col == m[0].length - 1)&#123; // 只能向下走 result += core(m,row + 1,col); &#125;else&#123; result += Math.min(core(m,row,col + 1) , core(m,row + 1,col)); &#125; dp[row][col] = result; return result; &#125; public int minPathSum(int[][] grid) &#123; dp = new int[grid.length][grid[0].length]; return core(grid,0,0); &#125;&#125; 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shorteststring representing the absolute path. Example 1: 1234&gt; Input: &quot;/home/&quot;&gt; Output: &quot;/home&quot;&gt; Explanation: Note that there is no trailing slash after the last directory name.&gt; &gt; Example 2: 1234&gt; Input: &quot;/../&quot;&gt; Output: &quot;/&quot;&gt; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.&gt; &gt; Example 3: 1234&gt; Input: &quot;/home//foo/&quot;&gt; Output: &quot;/home/foo&quot;&gt; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.&gt; &gt; Example 4: 123&gt; Input: &quot;/a/./b/../../c/&quot;&gt; Output: &quot;/c&quot;&gt; &gt; Example 5: 123&gt; Input: &quot;/a/../../b/../c//.//&quot;&gt; Output: &quot;/c&quot;&gt; &gt; Example 6: 123&gt; Input: &quot;/a//b////c/d//././/..&quot;&gt; Output: &quot;/a/b/c&quot;&gt; 一开始想到的比较笨的方式，将字符串转换为数组进行判断 每个位置有三个可能：/ . 字母 / + 字母 ： 追加 / + / : 跳过 . + / : 跳过 . + . : 通过lastIndexOf(“/“)定位剔除最后一段 但是死于输入 “/…”，喵的， “…”在linux还真能建立，但是用ll都查看不到，但是确实能通过 cd … 进入该文件夹 所以，换种方式： 通过 split将字符串分割，只需判断是否为空，是否为“.”和”..”三种情况，其他的追加上去就好。 1234567891011121314151617181920212223242526class Solution &#123; public String simplifyPath(String path) &#123; String[] StrArr = path.split("/"); StringBuilder sb = new StringBuilder(); for(String str :StrArr)&#123; if("".equals(str))continue; if(".".equals(str))&#123; continue; &#125;else if("..".equals(str))&#123; int lindex = sb.lastIndexOf("/"); if(lindex == -1)&#123; continue; &#125; String tmp = sb.toString().substring(0, lindex); sb = new StringBuilder(tmp); &#125;else&#123; sb.append("/" + str); &#125; &#125; if(sb.length()==0)&#123; sb.append("/"); &#125; return sb.toString(); &#125;&#125; 1234567891011121314151617181920// 最短用时 2msclass Solution &#123; public String simplifyPath(String path) &#123; int i = path.length() - 1, count = 0; StringBuilder builder = new StringBuilder(i); while (i &gt; 0) &#123; int j = path.lastIndexOf('/', i);// 从i开始向前搜索 "/" if (i == j) i--; //说明 i 处 正好是 "/" else &#123; String x = path.substring(j + 1, i + 1); i = j - 1; if (".".equals(x)) ; else if ("..".equals(x)) count++; else if (count &gt; 0) count--; else builder.insert(0, "/" + x); &#125; &#125; return builder.length() == 0 ? "/" : builder.toString(); &#125;&#125; 73. Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: 12345678910111213&gt; Input: &gt; [&gt; [1,1,1],&gt; [1,0,1],&gt; [1,1,1]&gt; ]&gt; Output: &gt; [&gt; [1,0,1],&gt; [0,0,0],&gt; [1,0,1]&gt; ]&gt; &gt; Example 2: 12345678910111213&gt; Input: &gt; [&gt; [0,1,2,0],&gt; [3,4,5,2],&gt; [1,3,1,5]&gt; ]&gt; Output: &gt; [&gt; [0,0,0,0],&gt; [0,4,5,0],&gt; [0,3,1,0]&gt; ]&gt; &gt; Follow up: A straight forward solution using O(m**n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 12345678910111213141516171819202122232425262728293031323334353637383940// O(m+n) space 2msclass Solution &#123; public void setZeroes(int[][] matrix) &#123; int row = matrix.length; int col = matrix[0].length; int[] rowZero = new int[row]; int[] colZero = new int[col]; for(int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if(matrix[i][j] == 0)&#123; rowZero[i] = 1; colZero[j] = 1; &#125; &#125; &#125; for(int i = 0; i &lt; row; i++)&#123; if(rowZero[i] == 1)&#123; setRowZero(matrix, i); &#125; &#125; for(int j = 0; j &lt; col; j++)&#123; if(colZero[j] == 1)&#123; setColZero(matrix, j); &#125; &#125; &#125; public void setRowZero(int[][] matrix, int row)&#123; int col = matrix[0].length; for(int i = 0; i &lt; col; i++)&#123; matrix[row][i] = 0; &#125; &#125; public void setColZero(int[][] matrix, int col)&#123; int row = matrix.length; for(int i = 0; i &lt; row; i++)&#123; matrix[i][col] = 0; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 少于 O(m+n)额外空间的，将首行和首列用来存储对应行列是否存在0class Solution &#123; public void setZeroes(int[][] matrix) &#123; //如果首行或首列有元素为0，在最后将行或列置为0 boolean rowFlag = false; //判断首行 for (int i = 0; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; rowFlag=true; break; &#125; &#125; //判断首列 boolean colFlag = false; for (int i = 0; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; matrix[0][0]=0; break; &#125; &#125; //把对应的首行首列置为0，从[1][1]开始遍历 for (int i = 1; i &lt; matrix.length; i++) &#123; for (int j = 1; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; //行置0 for (int i = 1; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; matrix[j][i] = 0; &#125; &#125; &#125; //列置0 for (int i = 1; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[i][j] = 0; &#125; &#125; &#125; //如果首列中有0，将首列置为0 if (matrix[0][0]==0)&#123; for (int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; //如果首行有0，将首行置为0 if (rowFlag)&#123; for (int i = 0; i &lt; matrix[0].length; i++) &#123; matrix[0][i] = 0; &#125; &#125; &#125; &#125; 74. Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: 123456789&gt; Input:&gt; matrix = [&gt; [1, 3, 5, 7],&gt; [10, 11, 16, 20],&gt; [23, 30, 34, 50]&gt; ]&gt; target = 3&gt; Output: true&gt; &gt; Example 2: 123456789&gt; Input:&gt; matrix = [&gt; [1, 3, 5, 7],&gt; [10, 11, 16, 20],&gt; [23, 30, 34, 50]&gt; ]&gt; target = 13&gt; Output: false&gt; 1234567891011121314151617181920212223242526272829303132333435// 日常判断 传入的值可能为 null 或者 长度为0class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(null == matrix)return false; int row = matrix.length; if(0 == row)return false; int col = matrix[0].length; if(0 == col)return false; for(int i = 0; i &lt; row; i++)&#123; if (matrix[i][col-1] == target || matrix[i][0] == target) &#123; return true; &#125; else if(matrix[i][col-1] &gt; target)&#123; return rowFind(matrix[i], target); &#125; &#125; return false; &#125;// 行查找使用二分查找，对于更长的矩阵，具有更高的效率 public boolean rowFind(int[] row, int target)&#123; int left = 0; int right = row.length - 1; int mid = -1; while (left &lt;= right) &#123; mid = (right + left) / 2; if (row[mid] == target) &#123; return true; &#125; else if (row[mid] &gt; target) &#123; right = mid - 1; &#125; else if (row[mid] &lt; target) &#123; left = mid + 1; &#125; &#125; return false; &#125;&#125; 75. Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? 1234567891011121314151617181920212223242526// 遍历，把红的往前放，蓝的往后放，每次交换两处索引的值就可以了。class Solution &#123; public void sortColors(int[] nums) &#123; //遍历，把红的往前放，把蓝的往后放 int left = 0; int right = nums.length -1; int index = 0; while(left &lt; right &amp;&amp; index &lt;=right)&#123; if(left &lt; index &amp;&amp; nums[index] == 0)&#123; swap(nums, left, index); left ++; &#125;else if(nums[index] == 2)&#123; swap(nums, right, index); right --; &#125;else&#123; index ++; &#125; &#125; &#125; public void swap(int[] nums, int index1, int index2)&#123; int tmp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = tmp; &#125;&#125; 77. CombinationsGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. Example: 12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 12345678910111213141516171819202122// 最先想到的办法，回溯class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; combine(n, k, new ArrayList&lt;Integer&gt;()); return list; &#125; public void combine(int n, int k, List&lt;Integer&gt; combine)&#123; if(k == 0)&#123; list.add(new ArrayList(combine)); return; &#125; if(n &lt; 1)return; for(int i = n; i &gt; 0 &amp;&amp; i &gt;= k; i--)&#123; // 注意，添加 i &gt;= k 可以节约很多时间，避免大量无用功，差不多是5ms和57ms的区别 combine.add(i); combine(i-1, k-1, combine); combine.remove((Object)i); // 或 combine.remove(combine.size()-1); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 原理差不多，一个从大到小组合，一个从小到大组合class Solution &#123; private int max; private int num; private List&lt;List&lt;Integer&gt;&gt; res; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; max = n; num = k; res = new ArrayList&lt;&gt;(); if (k == 0) &#123; return res; &#125; getCombine(1, new ArrayList&lt;&gt;()); return res; &#125; private void getCombine(int index, List&lt;Integer&gt; form) &#123; if (form.size() == num) &#123; res.add(new ArrayList&lt;&gt;(form)); return; &#125; // 剪枝，[i, n]区间至少需要有k - form.size()个元素，否则跳过 int range = max - num + form.size() + 1; for (int i = index; i &lt;= range; i++) &#123; form.add(i); getCombine(i + 1, form); form.remove(form.size() - 1); &#125; &#125;&#125; 78. Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910111213&gt; Input: nums = [1,2,3]&gt; Output:&gt; [&gt; [3],&gt; [1],&gt; [2],&gt; [1,2,3],&gt; [1,3],&gt; [2,3],&gt; [1,2],&gt; []&gt; ]&gt; 12345678910111213141516171819class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = null; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; res = new ArrayList&lt;&gt;(); ArrayList &lt;Integer&gt; temp = new ArrayList&lt;&gt;(); sub(nums,temp, 0); return res; &#125; public void sub(int[] nums, List temp, int index) &#123; if(index == nums.length) &#123; res.add(new ArrayList(temp)); return; &#125; temp.add(nums[index]); sub(nums, temp, index + 1); temp.remove(temp.size() - 1); sub(nums, temp, index + 1); &#125;&#125; 123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); result.add(new ArrayList&lt;Integer&gt;()); for(int n:nums)&#123; int size = result.size(); for(int i=0;i&lt;size;i++)&#123; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(result.get(i)); temp.add(n); result.add(temp); &#125; &#125; return result; &#125;&#125; 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: 1234567891011&gt; board =&gt; [&gt; [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],&gt; [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],&gt; [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]&gt; ]&gt; &gt; Given word = &quot;ABCCED&quot;, return true.&gt; Given word = &quot;SEE&quot;, return true.&gt; Given word = &quot;ABCB&quot;, return false.&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 10 ms 38.7MBclass Solution &#123; private char[][] board = null; private int[][] mark = null; private String word = null; public boolean exist(char[][] board, String word) &#123; // 通过遍历定位首字母位置，然后再逐步递归调用比较旁边位置， 将起始坐标都保存 // 同时还需要标记 相应位置 是否已经使用过（由于可能多个方向可能相同，需要使用到回溯） this.board = board; this.word = word; int row = board.length; int col = board[0].length; mark = new int[row][col]; List&lt;int[]&gt; starts = find(word.charAt(0)); for(int[] point : starts)&#123; mark[point[0]][point[1]] = 1; if(exist(point[0], point[1], 0))&#123; return true; &#125; mark[point[0]][point[1]] = 0; &#125; return false; &#125; private boolean exist(int curRow, int curCol, int curIndex)&#123; if(word.charAt(curIndex) == board[curRow][curCol] &amp;&amp; curIndex == word.length() -1)&#123; return true; &#125; if( word.charAt(curIndex) == board[curRow][curCol])&#123; //判断四个方向是否可行 // 上 if(curRow - 1 &gt;= 0 &amp;&amp; mark[curRow-1][curCol] ==0)&#123; mark[curRow -1][curCol] = 1; boolean exist = exist(curRow -1, curCol, curIndex + 1); mark[curRow -1][curCol] = 0; if(exist)return exist; &#125; // 下 if(curRow + 1 &lt; board.length &amp;&amp; mark[curRow+1][curCol] ==0)&#123; mark[curRow + 1][curCol] = 1; boolean exist = exist(curRow + 1, curCol, curIndex + 1); mark[curRow + 1][curCol] = 0; if(exist)return exist; &#125; // 左 if(curCol -1 &gt;= 0 &amp;&amp; mark[curRow][curCol -1] == 0)&#123; mark[curRow][curCol - 1] = 1; boolean exist = exist(curRow, curCol -1, curIndex + 1); mark[curRow][curCol - 1] = 0; if(exist)return exist; &#125; // 右 if(curCol + 1 &lt; board[0].length &amp;&amp; mark[curRow][curCol + 1] == 0)&#123; mark[curRow][curCol + 1] = 1; boolean exist = exist(curRow, curCol + 1, curIndex + 1); mark[curRow][curCol + 1] = 0; if(exist)return exist; &#125; &#125;else&#123; return false; &#125; return false; &#125; // 查找首字母的位置 private List&lt;int[]&gt; find(char head)&#123; List&lt;int[]&gt; list = new ArrayList(); for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == head)&#123; list.add(new int[]&#123;i, j&#125;); &#125; &#125; &#125; return list; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 将上面的逻辑统一简化处理 14ms 43.9MBclass Solution &#123; private char[][] board = null; private int[][] mark = null; private String word = null; public boolean exist(char[][] board, String word) &#123; // 通过遍历定位首字母位置，然后再逐步递归调用比较旁边位置， 将起始坐标都保存 // 同时还需要标记 相应位置 是否已经使用过（由于可能多个方向可能相同，需要使用到回溯） this.board = board; this.word = word; int row = board.length; int col = board[0].length; mark = new int[row][col]; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == word.charAt(0))&#123; if(exist(i, j, 0))return true; &#125; &#125; &#125; return false; &#125; private boolean exist(int curRow, int curCol, int curIndex)&#123; if( curIndex == word.length())&#123; return true; &#125; if(curRow &lt; 0 || curRow == board.length || curCol &lt; 0 || curCol == board[0].length || mark[curRow][curCol] == 1)&#123; return false; &#125; if( word.charAt(curIndex) == board[curRow][curCol])&#123; //判断四个方向是否可行 mark[curRow][curCol] = 1; if(exist(curRow - 1, curCol, curIndex + 1) || exist(curRow + 1, curCol, curIndex + 1) || exist(curRow, curCol -1, curIndex + 1) || exist(curRow, curCol + 1, curIndex + 1))&#123; return true; &#125; mark[curRow][curCol] = 0; &#125; return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// 由于是比较值是相同，所以可以通过临时改变值使不相同来做标记，节省内存 8ms 39.6MBclass Solution &#123; private char[][] board = null; private String word = null; public boolean exist(char[][] board, String word) &#123; // 通过遍历定位首字母位置，然后再逐步递归调用比较旁边位置 // 同时还需要标记 相应位置 是否已经使用过（由于可能多个方向可能相同，需要使用到回溯） this.board = board; this.word = word; int row = board.length; int col = board[0].length; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == word.charAt(0))&#123; if(exist(i, j, 0))return true; &#125; &#125; &#125; return false; &#125; private boolean exist(int curRow, int curCol, int curIndex)&#123; if( curIndex == word.length())&#123; return true; &#125; if(curRow &lt; 0 || curRow == board.length || curCol &lt; 0 || curCol == board[0].length)&#123; return false; &#125; if( word.charAt(curIndex) == board[curRow][curCol])&#123; //判断四个方向是否可行 board[curRow][curCol] ^= 256; // 使用位运算，加快计算速度，同时计算后不是字母，相当于标记了已遍历 if(exist(curRow - 1, curCol, curIndex + 1) || exist(curRow + 1, curCol, curIndex + 1) || exist(curRow, curCol -1, curIndex + 1) || exist(curRow, curCol + 1, curIndex + 1))&#123; return true; &#125; board[curRow][curCol] ^= 256; // 二次异或，回复原值 &#125; return false; &#125;&#125; 80. Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 123456&gt; Given nums = [1,1,1,2,2,3],&gt; &gt; Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.&gt; &gt; It doesn&apos;t matter what you leave beyond the returned length.&gt; &gt; Example 2: 123456&gt; Given nums = [0,0,1,1,1,1,2,3,3],&gt; &gt; Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.&gt; &gt; It doesn&apos;t matter what values are set beyond the returned length.&gt; &gt; Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 123456789&gt; // nums is passed in by reference. (i.e., without making a copy)&gt; int len = removeDuplicates(nums);&gt; &gt; // any modification to nums in your function would be known by the caller.&gt; // using the length returned by your function, it prints the first len elements.&gt; for (int i = 0; i &lt; len; i++) &#123;&gt; print(nums[i]);&gt; &#125;&gt; 1234567891011121314151617181920212223242526272829// 理解容易，写起来绕class Solution &#123; public int removeDuplicates(int[] nums) &#123; if( 0 == nums.length)return 0; int newLength = 0; int count = 0; int preVal = nums[0]; for(int i = 1; i &lt; nums.length; i++)&#123; if(preVal == nums[i]) &#123; count ++; &#125;else&#123; count = 0; &#125; preVal = nums[i]; if(count &lt; 2)&#123;//在这里控制重复的个数是多少 newLength++;; &#125; if(i &gt; newLength)&#123;//如果没有超过3个的重复数，则没必要交换 swap(nums, i, newLength); &#125; &#125; return newLength + 1;//长度是最后索引+1 &#125; private void swap(int[] nums, int index1, int index2)&#123; int tmp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = tmp; &#125;&#125; 12345678910111213141516class Solution &#123; public int removeDuplicates(int[] nums) &#123; int flag = 0; if (nums == null || nums.length &lt;= 0)&#123; return flag; &#125; for (int i = 0;i &lt; nums.length;i++)&#123; if (flag &lt; 2 || nums[i] &gt; nums[flag - 2])&#123; //flag 指向有效值赋值后一位置，（即newLength）,因而flag-2指向上一个值 // 可以通过修改 flag 减少 num 来控制多少个重复 nums[flag++] = nums[i]; &#125; &#125; return flag; &#125;&#125; Mark-81. Search in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: 123&gt; Input: nums = [2,5,6,0,0,1,2], target = 0&gt; Output: true&gt; &gt; Example 2: 123&gt; Input: nums = [2,5,6,0,0,1,2], target = 3&gt; Output: false&gt; &gt; Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean search(int[] nums, int target) &#123; if(nums.length == 0)return false; return find(nums, 0, nums.length - 1, target); &#125; public boolean find(int[] nums, int left, int right, int target)&#123; if(left &gt; right)return false; if(nums[left] == target || nums[right] == target)&#123; return true; &#125; if(left == right )return false; int mid = left + (right - left) / 2; if(nums[mid] == target)return true; if(nums[left] &lt; nums[mid])&#123; if(nums[left] &lt;=target &amp;&amp; target &lt;= nums[mid])&#123; return find(nums, left, mid -1, target); &#125;else&#123; return find(nums, mid+1, right, target); &#125; &#125;else if(nums[right] &gt; nums[mid])&#123; if(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right])&#123; return find(nums, mid +1, right, target); &#125;else&#123; return find(nums, left, mid -1, target); &#125; &#125;else&#123; if(nums[mid] == nums[left])&#123; return find(nums, left +1, right, target); &#125;else&#123; return find(nums, left, right -1, target); &#125; &#125; &#125;&#125; 123456789101112131415161718192021class Solution &#123; public boolean search(int[] nums, int target) &#123; int l = 0, r = nums.length-1; while(l&lt;=r)&#123; //处理重复数字 while(l&lt;r&amp;&amp;nums[l]==nums[l+1]) ++l; while(l&lt;r&amp;&amp;nums[r]==nums[r-1]) --r; int mid = l+(r-l)/2; if(nums[mid]==target) return true; //左半部分有序 if(nums[mid]&gt;=nums[l])&#123; if(target&lt;nums[mid]&amp;&amp;target&gt;=nums[l]) r = mid-1;//target落在左半边 else l = mid+1; &#125;else&#123;//右半部分有序 if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[r]) l = mid+1;//target落在右半边 else r = mid-1; &#125; &#125; return false; &#125;&#125; Mark-82. Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinctnumbers from the original list. Example 1: 123&gt; Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5&gt; Output: 1-&gt;2-&gt;5&gt; &gt; Example 2: 123&gt; Input: 1-&gt;1-&gt;1-&gt;2-&gt;3&gt; Output: 2-&gt;3&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 先虚拟一个前节点，用于获取指针class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(null == head || null == head.next)return head; ListNode dHead = new ListNode(0); dHead.next = head; ListNode pointer = head; ListNode prePoint = dHead; while(pointer!= null &amp;&amp; pointer.next != null)&#123; if(pointer.val == pointer.next.val)&#123; while(null != pointer.next &amp;&amp; pointer.val == pointer.next.val)&#123; pointer.next = pointer.next.next; &#125; prePoint.next = pointer.next; pointer = pointer.next; &#125;else&#123; prePoint = prePoint.next; pointer = pointer.next; &#125; &#125; return dHead.next; &#125;&#125;// 递归调用class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(null == head || null == head.next)return head; if(head.val == head.next.val)&#123; while(null != head.next &amp;&amp; head.val == head.next.val)&#123; head.next = head.next.next; &#125; head = head.next; return deleteDuplicates(head); &#125;else&#123; head.next = deleteDuplicates(head.next); return head; &#125; &#125;&#125;class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode prev = null; ListNode cur = head; while( null != cur)&#123; if(cur.next != null &amp;&amp; cur.val == cur.next.val)&#123; while(null != cur.next &amp;&amp; cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125; cur = cur.next; if(prev == null)&#123; head = cur; &#125;else&#123; prev.next = cur;// 修改节点的next，否则还是指向重复的 &#125; &#125;else&#123; prev = cur; cur = cur.next; &#125; &#125; return head; &#125;&#125; 86. Partition ListMark Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 123&gt; Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3&gt; Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5&gt; 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode partition(ListNode head, int x) &#123; // 建立两个虚拟头部来链接值 ListNode less_head = new ListNode(0);//用来链接比x更小的值 ListNode more_head = new ListNode(0);//用来链接比x更大或相等的值 ListNode less_cur = less_head;// 插入点 ListNode more_cur = more_head;//插入点 while(head != null)&#123; if(head.val &lt; x)&#123; less_cur.next = head; less_cur = less_cur.next; &#125; else&#123; more_cur.next = head; more_cur = more_cur.next; &#125; head = head.next; &#125; less_cur.next = more_head.next; more_cur.next = null; return less_head.next; &#125;&#125; 89. Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: 12345678910111213141516&gt; Input: 2&gt; Output: [0,1,3,2]&gt; Explanation:&gt; 00 - 0&gt; 01 - 1&gt; 11 - 3&gt; 10 - 2&gt; &gt; For a given n, a gray code sequence may not be uniquely defined.&gt; For example, [0,2,3,1] is also a valid gray code sequence.&gt; &gt; 00 - 0&gt; 10 - 2&gt; 11 - 3&gt; 01 - 1&gt; &gt; Example 2: 123456&gt; Input: 0&gt; Output: [0]&gt; Explanation: We define the gray code sequence to begin with 0.&gt; A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.&gt; Therefore, for n = 0 the gray code sequence is [0].&gt; 这道题如果了解格雷码构成的原理就很简单了 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; grayCode(int n) &#123; if(n == 0)&#123; List&lt;Integer&gt; list = new ArrayList(); list.add(0); return list; &#125; List&lt;Integer&gt; list = new ArrayList(); List preList = grayCode(n - 1); for(Object val : preList)&#123; list.add((int)val); &#125; int addVal = 1 &lt;&lt;(n-1); for(int i = preList.size() - 1; i&gt;=0; i--)&#123; list.add((int)preList.get(i) + addVal); &#125; return list; &#125;&#125; 90. Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 1234567891011&gt; Input: [1,2,2]&gt; Output:&gt; [&gt; [2],&gt; [1],&gt; [1,2,2],&gt; [2,2],&gt; [1,2],&gt; []&gt; ]&gt; 123456789101112131415161718192021222324252627282930class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; result.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(nums); for(int i = 1; i &lt;= nums.length; i ++)&#123; genSub(nums, 0, i, new ArrayList(i)); &#125; return result; &#125; private void genSub(int[] nums, int sIndex, int len, List&lt;Integer&gt; sub)&#123; if(len == sub.size())&#123; result.add(new ArrayList(sub)); return; &#125; for(int i = sIndex; i + len - sub.size() &lt;= nums.length; i++)&#123; // 判断条件很重要 i + len - sub.size() &lt;= nums.length sub.add(nums[i]); genSub(nums, i + 1, len , sub); sub.remove(sub.size() -1); while(i &lt; nums.length -1 &amp;&amp; nums[i] == nums[i+1])&#123; i++ ; &#125; &#125; &#125;&#125; 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); Arrays.sort(nums); helper(nums,res,tmp,0); return res; &#125; public void helper(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, int start)&#123; res.add(new ArrayList&lt;Integer&gt;(tmp)); for (int i = start; i &lt; nums.length; i++)&#123; if (i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; tmp.add(nums[i]); helper(nums,res,tmp,i+1); tmp.remove(tmp.size()-1); &#125; &#125;&#125; 91. Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 12345&gt; &apos;A&apos; -&gt; 1&gt; &apos;B&apos; -&gt; 2&gt; ...&gt; &apos;Z&apos; -&gt; 26&gt; &gt; Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: 1234&gt; Input: &quot;12&quot;&gt; Output: 2&gt; Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).&gt; &gt; Example 2: 1234&gt; Input: &quot;226&quot;&gt; Output: 3&gt; Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).&gt; 组合相关基本使用 动态规划、回溯、分治等 123456789101112131415161718192021222324class Solution &#123; public int numDecodings(String s) &#123; char[] ss=s.toCharArray(); int n=ss.length; if(n==0) &#123;//没有数字的情况 return 0; &#125; int[] dp=new int[n+1];//dp[i]表示前i个数字的组合数 dp[0]=1;//为了后面的好计算 for(int i=1;i&lt;=n;i++) &#123; int t=ss[i-1]-'0'; if(t&gt;=1&amp;&amp;t&lt;=9) &#123;//最后一个数字 dp[i]+=dp[i-1]; &#125; if(i&gt;=2) &#123;//最后两个组合成数字 t=(ss[i-2]-'0')*10+(ss[i-1]-'0'); if(t&gt;=10&amp;&amp;t&lt;=26) &#123; dp[i]+=dp[i-2]; &#125; &#125; &#125; return dp[n]; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536class Solution: # 原型还是斐波那契的思路，第i的个数由i-1和i-2的个数决定 def numDecodings(self, s: str) -&gt; int: # '0'开头的全部违规 if s[0] == '0': return 0 # '0'结尾的，前一位比2大也全部违规，受测试用例'230'的启发 # 其实下面的循环也实现了，但就是想早点剔除违规的哈哈哈 if s[-1] == '0' and s[-2] &gt; '2': return 0 # 这有点斐波那契的意思，因为第i位在不违规的情况下， # 要么自己成一位，要么和前一位组成两位的字母，所以可就是f(i) = f(i-1) + f(i-2) a = 1 # 第i-1位的组合个数 b = 1 # 第i-2位的组合个数 for i in range(1, len(s)): # 连续两个0肯定违规 if s[i-1] == '0' and s[i] == '0': return 0 # 小于26就有可能i和i+1配对变斐波那契 elif s[i-1]+s[i] &lt;= '26': # i为0，就只能f(i) = f(i-2),和前一个合体，不能自己单独 if s[i] == '0': a, b = b, a # 如果前一个为0，而自己为不为0，f(i) = f(i-1) elif s[i-1] == '0': a = b # 一切正常，f(i) = f(i-1) + f(i-2) else: a, b = b, a+b # 删除任何30，40，50这种出现在尾部，中部的违规组合 elif s[i] == '0': return 0 else: a = b return b 92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 123&gt; Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4&gt; Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(m == n || head == null || head.next == null)return head; ListNode prev = null; ListNode cur = head; ListNode part1Start = head; ListNode part1End = null, part2Start = null, part2End = null, part3Start = null; for(int i = 1; cur != null; i++)&#123; if(i == m )&#123; part1End = prev; part2End = cur; &#125; if(i == n)&#123; part2Start = cur; part3Start = cur.next; &#125; if( i &gt;= m &amp;&amp; i &lt;= n)&#123; ListNode next = cur.next; cur.next = prev; prev = cur; cur = next; &#125;else&#123; prev = cur; cur = cur.next; &#125; &#125; if(m == 1)&#123; head = part2Start; part2End.next = part3Start; &#125;else&#123; part1End.next = part2Start; part2End.next = part3Start; &#125; return head; &#125;&#125; 93. Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 123&gt; Input: &quot;25525511135&quot;&gt; Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 4ms 37.4MBclass Solution &#123; private List&lt;String&gt; result = new ArrayList(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; restore(s, "", 4); return result; &#125; private void restore(String s, String sb, int len)&#123; if(len == 0 &amp;&amp; s.length() == 0)&#123; result.add(sb.substring(0, sb.length() -1)); return; &#125; if(s.length() &gt; len * 3 || len == 0 || s.length() &lt; 1)&#123; return; &#125; restore(s.substring(1), sb + s.substring(0,1) +".", len -1); if(s.length() &gt;= 2 )&#123; int val = Integer.parseInt(s.substring(0, 2)); if(val &gt; 9)&#123; restore(s.substring(2), sb + s.substring(0,2) +".", len -1); &#125; &#125; if(s.length() &gt;= 3)&#123; int val = Integer.parseInt(s.substring(0, 3)); if( val &gt; 99 &amp;&amp; val &lt; 256)&#123; restore(s.substring(3), sb + s.substring(0,3) +".", len -1); &#125; &#125; &#125;&#125;// 也可以用 StringBuilder 4ms 34.7MBclass Solution &#123; private List&lt;String&gt; result = new ArrayList(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; restore(s, new StringBuilder(), 4); return result; &#125; private void restore(String s, StringBuilder sb, int len)&#123; if(len == 0 &amp;&amp; s.length() == 0)&#123; result.add(sb.toString().substring(0, sb.length() -1)); return; &#125; if(s.length() &gt; len * 3 || len == 0 || s.length() &lt; 1)&#123; return; &#125; sb.append(s.substring(0,1)).append("."); restore(s.substring(1), sb, len -1); sb.delete(sb.length()-2, sb.length()); if(s.length() &gt;= 2 )&#123; int val = Integer.parseInt(s.substring(0, 2)); if(val &gt; 9)&#123; sb.append(s.substring(0,2)).append("."); restore(s.substring(2), sb, len -1); sb.delete(sb.length()-3, sb.length()); &#125; &#125; if(s.length() &gt;= 3)&#123; int val = Integer.parseInt(s.substring(0, 3)); if( val &gt; 99 &amp;&amp; val &lt; 256)&#123; sb.append(s.substring(0,3)).append("."); restore(s.substring(3), sb, len -1); sb.delete(sb.length()-4, sb.length()); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// 2ms 37.2MBclass Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; int[] splits = new int[5]; //分割的每一段的开始位置，从1开始 List&lt;String&gt; ips = new ArrayList&lt;&gt;(); restoreIpAddresses(0,splits,s,ips); return ips; &#125; //通过寻找原IP地址的四个分段的起始位置来确定新的IP地址 private void restoreIpAddresses(int level,int[] s,String ip,List&lt;String&gt; ips)&#123; if(level == 4 &amp;&amp; s[4] != ip.length())&#123; //生成的ip地址的长度不和原ip地址长度相同则退出 return; &#125; if(level == 4 &amp;&amp; s[4] == ip.length())&#123; String r = ip.substring(s[0],s[1])+"."+ip.substring(s[1],s[2])+"."+ip.substring(s[2],s[3])+"."+ip.substring(s[3]); ips.add(r); &#125; int num = 0; for(int i = s[level];i&lt;ip.length();i++)&#123; num = num*10+ip.charAt(i)-'0'; if((num == 0 &amp;&amp; i==s[level]) || (num&gt;0 &amp;&amp; num&lt;=255))&#123; //越界检查，当num为0时，i必须与该段的开始位置相等 s[level+1]=i+1; restoreIpAddresses(level+1,s,ip,ips); if(num == 0 &amp;&amp; i==s[level]) //如果是0，则0后面不能有其他数字 break; continue; &#125; break; &#125; &#125; &#125; 94. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes’ values. Example: 123456789&gt; Input: [1,null,2,3]&gt; 1&gt; \&gt; 2&gt; /&gt; 3&gt; &gt; Output: [1,3,2]&gt; &gt; Follow up: Recursive solution is trivial, could you do it iteratively? 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;Integer&gt; result = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null)return result; if(root.left == null &amp;&amp; root.right == null)&#123; result.add(root.val); return result; &#125; if(root.left != null)&#123; inorderTraversal(root.left); &#125; result.add(root.val); if(root.right != null)&#123; inorderTraversal(root.right); &#125; return result; &#125;&#125; 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;Integer&gt; result = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null)return result; TreeNode curRoot = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(curRoot != null || !stack.isEmpty())&#123; while(curRoot != null)&#123; stack.push(curRoot); curRoot = curRoot.left; &#125; curRoot = stack.pop(); result.add(curRoot.val); curRoot = curRoot.right; &#125; return result; &#125;&#125; 95. Unique Binary Search Trees II Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 123456789101112131415161718&gt; Input: 3&gt; Output:&gt; [&gt; [1,null,3,2],&gt; [3,2,null,1],&gt; [3,1,null,null,2],&gt; [2,1,3],&gt; [1,null,2,null,3]&gt; ]&gt; Explanation:&gt; The above output corresponds to the 5 unique BST&apos;s shown below:&gt; &gt; 1 3 3 2 1&gt; \ / / / \ \&gt; 3 2 1 1 3 2&gt; / / \ \&gt; 2 1 2 3&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n == 0) return new ArrayList(); return generate(1, n); &#125; private List&lt;TreeNode&gt; generate(int start, int end) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if (start &gt; end) &#123; res.add(null); return res; &#125; if (start == end) &#123; res.add(new TreeNode(start)); return res; &#125; for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; leftSubTrees = generate(start, i-1); List&lt;TreeNode&gt; rightSubTrees = generate(i+1, end); for (TreeNode left : leftSubTrees) &#123; for(TreeNode right : rightSubTrees) &#123; TreeNode node = new TreeNode(i); node.left = left; node.right = right; res.add(node); &#125; &#125; &#125; return res; &#125;&#125; 96. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 1234567891011&gt; Input: 3&gt; Output: 5&gt; Explanation:&gt; Given n = 3, there are a total of 5 unique BST&apos;s:&gt; &gt; 1 3 3 2 1&gt; \ / / / \ \&gt; 3 2 1 1 3 2&gt; / / \ \&gt; 2 1 2 3&gt; 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt;= n; i ++)&#123; for(int j = 0; j &lt; i; j++)&#123; dp[i] += dp[j]* dp[i - j -1]; &#125; &#125; return dp[n]; &#125;&#125; 98. Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456&gt; Input:&gt; 2&gt; / \&gt; 1 3&gt; Output: true&gt; &gt; Example 2: 123456789&gt; 5&gt; / \&gt; 1 4&gt; / \&gt; 3 6&gt; Output: false&gt; Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value&gt; is 5 but its right child&apos;s value is 4.&gt; 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 注意：Double.MIN_VALUE 不是最小负数，而是最小非负数 double preVal = -Double.MAX_VALUE; public boolean isValidBST(TreeNode root) &#123; //不仅要保证 左节点&lt;根节点&lt;右节点，同时左节点的所有节点都得小于根节点；右节点同理 if(root == null)return true; if(isValidBST(root.left))&#123; if(preVal &lt; root.val)&#123; preVal = root.val; return isValidBST(root.right); &#125; &#125; return false; &#125;&#125; 100. Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 12345678&gt; Input: 1 1&gt; / \ / \&gt; 2 3 2 3&gt; &gt; [1,2,3], [1,2,3]&gt; &gt; Output: true&gt; &gt; Example 2: 12345678&gt; Input: 1 1&gt; / \&gt; 2 2&gt; &gt; [1,2], [1,null,2]&gt; &gt; Output: false&gt; &gt; Example 3: 12345678&gt; Input: 1 1&gt; / \ / \&gt; 2 1 1 2&gt; &gt; [1,2,1], [1,1,2]&gt; &gt; Output: false&gt; 1234567891011121314151617/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q==null)return true; if(p == null | q == null)return false; if(p.val != q.val)return false; return isSameTree(p.left, q.left)&amp;&amp; isSameTree(p.right, q.right); &#125;&#125; 101. Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 123456&gt; 1&gt; / \&gt; 2 2&gt; / \ / \&gt; 3 4 4 3&gt; &gt; But the following [1,2,2,null,3,null,3] is not: 123456&gt; 1&gt; / \&gt; 2 2&gt; \ \&gt; 3 3&gt; &gt; Note:Bonus points if you could solve it both recursively and iteratively. 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null)return true; return isSymmetric(root.left, root.right); &#125; public boolean isSymmetric(TreeNode left, TreeNode right)&#123; if(left == null &amp;&amp; right == null)return true; if(left == null || right == null)return false; if(left.val == right.val)&#123; return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客踩坑]]></title>
    <url>%2F2019%2F04%2F08%2Fhexo%E5%8D%9A%E5%AE%A2-bug-making-debug%2F</url>
    <content type="text"><![CDATA[每次写完markdown笔记后上传到csdn都是件恼火的事情，如果没有图片，倒也方便，若是有较多图片，那就脑壳疼了。起意很久，还是用github&amp;gitee实践一波自己的博客吧。期间遇到很多bug，感谢文末链接中的大佬们，前人踩坑，后来者接着踩。 环境搭建 安装Git 在Windows系统，部署相关指令主要在Git Bash中运行 博客发布在Gitee/Github上都需要使用到Git 安装Node.js 安装hexo及初始化本地博客 Hexo相关指令介绍 hexo init ：初始化本地博客 123&gt; $ hexo init &lt;folder&gt; # 在指定文件夹初始化项目&gt; $ hexo init # 在当前文件夹初始化项目&gt; hexo generate： 通过markdown文件生成静态网页 hexo deploy：将public文件夹中的静态资源发布到指定仓库 1234&gt; $ hexo generate --watch # 一般默认自带--watch，根据文件的sha1值以比对文件是否改动，从而及时刷新&gt; $ hexo generate --deploy&gt; $ hexo deploy --generate # 两者的效果一样，生成完毕后自动部署&gt; &gt; 123&gt; $ hexo g -d&gt; $ hexo d -g # 上面两个指令的简写，同理，hexo server 可以简写为 hexo s&gt; hexo server：在本地发布服务，提供访问 123456&gt; # 安装服务器模块，3.0默认是个别模块&gt; $ npm install hexo-server --save&gt; $ hexo server -p 5000 # 指定端口发布&gt; $ hexo server -s # 静态模式，不会动态跟进source文件夹文件变动&gt; $ hexo server -i ip_addr # 一般不会用到这种骚操作&gt; &gt; hexo new：新建页面或者blog 1234&gt; $ hexo new [layout] &lt;title&gt; &gt; # layout默认是_post,可以在_config.yml中的default_layout修改对应参数，&gt; # 同时如果标题包含空格，用括号将内容包裹 &gt; &gt; 12&gt; $ hexo new page page_name # 新建页面，提供访问，可以在主题的 _config.yml中修改提供访问 &gt; hexo clean: 清除缓存文件(db.json)和已生成的静态文件(public文件夹中内容)，在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 其他命令详情见 12345# 在指定文件夹中新建所需要的文件，如果后续不接参数，则在当前文件夹建立hexo init &lt;folder&gt; cd &lt;folder&gt;# 根据对应的package.json安装相关的npm依赖包npm install 建立完成后，指定文件夹目录如下 12345678.├── _config.yml # 网站的相关配置信息├── package.json # 应用程序的信息，及相关依赖├── scaffolds # 模板文件夹，新建页面和文章时，会根据模板初始化├── source # 资源文件夹，_posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。| ├── _drafts | └── _posts └── themes # 主题文件夹，hexo根据不同的主题生成静态页面 将本地博客同步到仓库（Gitee/Coding/Github等） 发布前预备工作，以git为例，其他代码托管网站原理一致 安装 hexo-deployer-git 12&gt; $ npm install hexo-deployer-git --save&gt; 修改_config.yml配置文件,冒号后务必有空格12345678910&gt; deploy:&gt; - type: git&gt; repo: &lt;repository url&gt;&gt; branch: [branch]&gt; message: [message]&gt; - type: git&gt; repo: &lt;repository url&gt;&gt; branch: [branch]&gt; message: [message]&gt; 仓库取名：默认情况不是子目录，需要将仓库名取为: &lt;用户名&gt;.github.io 这样命名，github的page服务会自动识别处理，否则需要额外设置子目录，如果想在子目录发布，需要额外在_config.yml中配置 分支名称：如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。也可以在仓库中的setting中勾选GitHub Pages勾选分支 其他如Heroku、Netlify、Rsync等详见官网文档 附：在子目录中发布参数修改 123&gt; url: &lt;github仓库地址&gt; # 仓库访问地址&gt; root: &lt;子目录&gt; # 一般子目录也就是项目名&gt; &gt; 主题选择与优化主题有多种，各种折腾后，最后我选择的next主题。 hexo的next主题个性化教程：打造炫酷网站 相关插件配置 本地搜索 评论 评论系统从Disqus到Valine - 简书 公式支持 hexo next主题解决无法显示数学公式 - MrYx - CSDN博客 在Hexo中使用mathjax渲染数学公式 - DH’s Den - CSDN博客 相关参考链接Hexo主题更改以及小功能的添加 Hexo博客教程(二):基本功能和网站优化 hexo生成博文插入图片 Hexo添加categories页面 hexo的next主题个性化教程：打造炫酷网站 Hexo 博客优化之博客美化（看板娘/鼠标点击爱心字体烟花爆炸效果/自定义鼠标指针样式/彩色滚动变换字体/背景音乐/网页标题恶搞/动态线条/人体时钟挂件/雪花飘落/背景动态彩带……） hexo添加小功能 - 青花猪的忧伤的博客 - CSDN博客 hexo next主题解决无法显示数学公式 - MrYx - CSDN博客 在Hexo中使用mathjax渲染数学公式 - DH’s Den - CSDN博客 遇见西门 - simon96.online Hexo使用细节及各种问题 - Selier的博客 - CSDN博客 Hexo博客之速度优化 - 简书]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker学习笔记]]></title>
    <url>%2F2019%2F04%2F05%2Fdocker-learning-note%2F</url>
    <content type="text"><![CDATA[当前更多是集群环境，从部署到运维相对工作量大。Docker一次构建，处处运行。 实验室相关项目最终也决定使用docker部署 一、Docker安装参考链接: http://www.docker.org.cn/book/install/linux.html https://docs.docker.com/install/linux/docker-ce/centos/ 1、依赖检查 CentOS 7 安装 依赖要求：Docker需要一个64位系统的Linux系统，内核的版本必须大于3.10 可以通过 uname -r 来检查内核版本 2、安装（1）脚本安装1234sudo yum update # 更新现有yum包curl -sSL https://get.docker.com/ | sh # 脚本安装sudo service docker start # 启动docker服务sudo docker version # 查看是否启动成功 （2）yum指令安装123456789101112131415sudo yum update # 更新现有yum包# 安装需要的工具和依赖包sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 添加repositorysudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 安装docker-cesudo yum install docker-ce docker-ce-cli containerd.io# 查看可安装的docker版本yum list docker-ce --showduplicates | sort -r# 安装指定版本的dockersudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io# 启动 dockersudo systemctl start docker# 通过运行 hello-image 镜像，测试是否正确安装sudo docker run hello-world （3）离线安装参考链接：https://blog.csdn.net/u013058742/article/details/80075633 1、下载所需的docker安装包 https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 2、下载所需的依赖 http://mirrors.163.com/centos/7/os/x86_64/Packages/ 下载如下8个依赖 audit-libs-python-2.7.6-3.el7.x86_64.rpm checkpolicy-2.5-4.el7.x86_64.rpm libcgroup-0.41-13.el7.x86_64.rpm libseccomp-2.3.1-3.el7.x86_64.rpm libsemanage-python-2.5-8.el7.x86_64.rpm policycoreutils-python-2.5-17.1.el7.x86_64.rpm python-IPy-0.75-6.el7.noarch.rpm setools-libs-3.3.8-1.1.el7.x86_64.rpm http://mirror.centos.org/centos/7/extras/x86_64/Packages/container-selinux-2.95-2.el7_6.noarch.rpm 下载 container-selinux-2.95-2.el7_6.noarch.rpm 12345678910# 安装依赖rpm -ivh *.rpm# 安装containerrpm -ivh container-selinux-2.9-4.el7.noarch.rpm# 安装dockerrpm -ivh docker-ce-17.12.0.ce-1.el7.centos.x86_64.rpm# 启动dockerservice dockerstart# 查看版本及是否已运行docker version 3、卸载123456# 列出安装包yum list installed |grep docker# 删除安装包yum -y remove docker-XXX# 删除镜像、容器等rm -rf /var/lib/docker 二、Docker镜像1、切换为阿里云镜像源进入阿里云镜像仓库库 参考链接： https://www.cnblogs.com/zhxshseu/p/5970a5a763c8fe2b01cd2eb63a8622b2.html 进入后，根据提示操作，如图： 2、Docker状态查询123456docker version # 查看docker版本信息# 查看docker运行状态service docker status systemctl is-active docker# 查看运行情况,ps指令和linux类似docker ps 3、镜像操作 就镜像拉取、提交来说，其实和Git一样，只不过把git换成了docker （1）镜像查看1234567891011# 添加 -a 后会将悬空镜像（none:none）的镜像一并列举出来docker images [-a]docker image ls [-a]# 只显示镜像的id,可以用于批量删除docker image ls -q# 只显示仓库名和对应的Tag，首字母大写 &#123;&#123;.Size&#125;&#125;docker image ls --format "&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"# 只查看悬空镜像，除dangling外还有 before、since、label docker image ls --filter dangling=true# 也可以使用reference过滤,如仅显示标签为latest的镜像docker image ls --filter=reference="*:latest" （2）镜像查询与拉取 要注意的是latest是一个非强制标签，不保证支线跟仓库中最新的镜像，只能说大多是指向最新的。 由于镜像是分层的，所以为节省空间和提升性能，多个镜像之间会共享镜像层，这意味着镜像下载多了后，后面的镜像由于共享镜像层，所需下载的新的数据量就更少。 12345678# 搜索镜像docker search tomcatdocker search tomcat --filter "is-official=true" # 只显示官方镜像docker search tomcat --filter "is-automated=true" # 自动创建的仓库# 拉取镜像, [image] 为可选项，可写可不写,写时去掉中括号，如：docker image pull tomcatdocker [image] pull tomcat # 默认拉取tag为latest的版本docker [image] pull nginx:1.17 # 拉取tag为1.17的nginxdocker [image] pull mysql:5.6.31 1234# 为准确拉取镜像，也可以通过镜像签名值下载docker image ls --digests mysql # 查看mysql镜像签名# 通过镜像签名拉取对应镜像docker pull mysql:d99ad1a8a2f8859dc986566cc31741c00a050d5fbf9305e7cd74398ade79f36 12# 镜像查看,能够查看详细信息及镜像层信息，docker history有类似功能，不过没有inspect严谨docker image inspect centos:latest （3）镜像删除 docker image rm [OPTIONS] IMAGE [IMAGE…] 可以多个一起删除，后面可以增加参数： -f, —force Force removal of the image—no-prune Do not delete untagged parents 1234# 删除指定的镜像docker image rm mysql:5.6.31 centos:latest# 批量删除, -f 代表强制删除，因为镜像有实例在运行的话，默认不让删除docker image rm $(docker image ls -q) -f （4）镜像导出与导入123456# 镜像导出 docker save [--help] [-o|--output[=OUTPUT]] IMAGE [IMAGE...]docker save centos &gt; centos.tardocker save --output=centos.tar centos:latest# 镜像导入 docker load [--help] [-i|--input[=INPUT]] [-q|--quiet]docker load &lt; centos.tardocker load --input centos.tar 三、Docker容器1、容器启动（run） 详细内容 参考链接：https://www.cnblogs.com/vikings-blog/p/4238062.html 或者 输入： docker run —help 调用格式：docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 常用的参数主要有： -it : 启动容器后会自动进入容器交互命令行，快捷键Ctrl+PQ 断开容器shell连接但是容器后台运行 -d : 启动容器后，不进入容器命令交互行 —name : 指定容器运行后的名字，若不指定，随机生成 -p ：指定交互的端口映射, -p linux_port:docker_container_port -P ：随机分配端口，一般不这样用 -v : 挂在指定volume，用于容器与实际文件交互 -v linux_absolut_path:container_absolute_path —link ：使容器与容器能够互相通信，—link [容器名/id]:[连接名] —restart :利用重启策略自我修复容器，always在重启docker服务后，会自动重启容器(即使在重启服务前停止了该容器)，unless-stopped则不会；on-failure会在容器退出并且返回值不是0的时候重启容器。 123456# 以指定镜像运行容器docker run -d --name tomcat -p 8080:8080 tomcat:latestdocker run -d -p 3306:3306 --name mysql selfbuild_mysql# 指定挂载volumecur_path=`pwd` # "="前后别加空格docker run -d -p 8080:8080 --name tomcat --link mysql:docker_mysql -v $&#123;cur_path&#125;/webapps:/opt/apache-tomcat-9.0.20/webapps centos_tomcat 说明：从其他主机访问docker部署的主机8080端口，能够得到docker centos_tomcat镜像实例容器tomcat8080端口的内容，由于项目需要访问mysql，故而需要mysql容器与tomcat容器能够通信，在tomcat中，访问mysql数据库的连接url可以为： 1jdbc:mysql://docker_mysql:3306/database?useUnicode=true&amp;characterEncoding=UTF-8 2、容器其他操作12345678910111213141516171819# 查看所有在运行的容器docker container lsdocker ps# 查看所有容器，已停止的容器也会显示docker container ls -adocker ps -a# 停止运行容器docker kill container_id/container_namedocker stop container_id/container_name# 启动停止了的容器docker start container_id/container_name# 删除未运行的容器docker container rm docker stop container_id/container_name# 查看容器配置的细节和运行时信息docker container inspect docker stop container_id/container_name# 对运行时的容器，运行bash命令docker container exec docker stop container_id/container_name bash_commands# 后面添加 -it 会连接到容器的shell进程docker container exec -it docker stop container_id/container_name bash_commands 四、应用容器化(Docker镜像构建)1、镜像构建常用指令 ADD 将主机目录下文件拷贝到镜像，且会自动处理url和tar压缩包 COPY 和ADD类似，区别是不会自动解压，从源路径到镜像内目标路径 FROM 基础镜像，当前新镜像基于那个镜像拓展 RUN 构建容器时要运行的bash命令 EXPOSE 创建容器后对外暴露出的端口 WORKDIR 创建容器后，终端默认登陆进入的工作目录 ENV 构建镜像过程中设置的环境变量 VOLUME 容器数据卷，用于数据保存和持久化工作 CMD 指定容器启动时要运行的命令，可以有多个，但是只有最后一个会生效，可在docker run 后通过指令进行参数替换 ENTRYPOINT 容器启动时要运行的命令，目的和CMD一样 ONBUILD 当前镜像被继承使用时，出发该语句后的内容 MAINTAINER 镜像维护者的姓名和邮箱地址 2、tomcat mysql构建 Dockerfile五、Docker Compose部署六、Docker Swarm七、Docker网络八、Docker卷与持久化]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js创建流媒体服务器]]></title>
    <url>%2F2018%2F10%2F28%2Fnode.js%E5%88%9B%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[系统：linuxnpm安装Ubuntu：123456# 安装 npmsudo apt-get install npm # npm 升级sudo npm install -g npm# 切换到淘宝镜像源npm install -g cnpm --registry=http://registry.npm.taobao.org 安装express1234# 先安装generatorsudo npm install -g express-generator# 安装expresssudo npm instal -g express 通过express创建工程1234# 新建工程express --view=ejs nodeServer# 进入到工程目录cd nodeServer 123456789101112131415161718&lt;!-- 打开 package.json 并在dependencies 添加相关依赖 --&gt; &#123; "name": "nodeServer", "version": "0.0.0", "private": true, "scripts": &#123; "start": "node ./bin/www" &#125;, "dependencies": &#123; "cookie-parser": "~1.4.3", "debug": "~2.6.9", "ejs": "~2.5.7", "express": "~4.16.0", "http-errors": "~1.6.2", "morgan": "~1.9.0", "node-media-server": "~1.4.3" &#125;&#125; 123# 利用npm安装所有依赖npm install # 至此 node.js 环境配置完成 在NodeServer文件夹中新建js文件，如：nodeServerTest.js并设置内容如下123456789101112131415161718const &#123; NodeMediaServer &#125; = require('node-media-server');const config = &#123; rtmp: &#123; port: 1935, chunk_size: 60000, gop_cache: true, ping: 60, ping_timeout: 30 &#125;, http: &#123; port: 8000, allow_origin: '*' &#125;&#125;;var nms = new NodeMediaServer(config);nms.run(); 在该文件夹下终端运行如下指令：12# 以非严格模式运行node --harmony nodeServerTest.js 得到结果如下：至此，node.js已创建服务器，相关端口参数如果后来者不明白，自己百度科普 安装ffmpeg并推送流数据Ubuntu下安装ffmpeg比较方便：1sudo apt-get install ffmpeg 查找摄像头设备：12sudo ls /dev/video*# 若只有一个摄像头，得到的一般是 /dev/video0 ffmpeg推送流12ffmpeg -f video4linux2 -i /dev/video0 -vcodec libx264 -acodec libvo_aacenc -b 1080k -r 33 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://localhost:1935/live/STREAM_NAME# 附注：在Windows系统下，-f后面的参数多为dshow，-i后面的参数video="摄像头名":audio="麦克风名"，在Windows系统中，多为虚拟设备 运行效果如下：参考链接链接备用：（https://oainin.wordpress.com/2018/06/09/nodejs%E5%88%9B%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/）至此在其他主机上能够访问实时流 在网页上访问流数据新建html文件，如：videoPlay.html123456789101112131415&lt;!-- 将192.168.128.112换成服务器实际ip --&gt;&lt;script src="https://cdn.bootcss.com/flv.js/1.4.0/flv.min.js"&gt;&lt;/script&gt;&lt;video id="videoElement" width="720" height="400" controls&gt;&lt;/video&gt;&lt;script&gt; if (flvjs.isSupported()) &#123; var videoElement = document.getElementById('videoElement'); var flvPlayer = flvjs.createPlayer(&#123; type: 'flv', url: 'http://192.168.128.112:8000/live/STREAM_NAME.flv' &#125;); flvPlayer.attachMediaElement(videoElement); flvPlayer.load(); flvPlayer.play(); &#125;&lt;/script&gt; 用浏览器打开该html文件即可实时查看流数据。1、视频延迟比较久，原因暂未知，貌似和缓冲区大小无关2、打开的浏览器用高端点的，需要能够支持html5，否则自己该页面代码3、视频未加载音频，若需加载详情百度ffserver.conf相关配置以及linux音频输入设备查找]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>流媒体</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode note - part 1]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-note-part-1%2F</url>
    <content type="text"><![CDATA[刷LeetCode的笔记，方便自己查看做题遇到的坑 Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1:1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2:12345Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3:123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 12345678910111213141516171819202122232425262728293031class Solution &#123; public int maxProfit(int[] prices) &#123; return calculate(prices, 0); &#125; public int calculate(int prices[], int s) &#123; if (s &gt;= prices.length) return 0; int max = 0; for (int start = s; start &lt; prices.length; start++) &#123; System.out.println("======new start== "+start+" ===="); int maxprofit = 0; for (int i = start + 1; i &lt; prices.length; i++) &#123; if (prices[start] &lt; prices[i]) &#123; System.out.println("index :"+start+"--"+i+" buy: "+prices[start] +" sell: " + prices[i]); int profit = calculate(prices, i + 1) + prices[i] - prices[start]; if (profit &gt; maxprofit)&#123; System.out.println("profit change:"+ maxprofit +" --&gt; " +profit); maxprofit = profit; &#125; &#125; &#125; if (maxprofit &gt; max)&#123; System.out.println("max profit change:"+ max +" --&gt; " +maxprofit); max = maxprofit; &#125; &#125; System.out.println("profit:"+max); return max; &#125;&#125; 12int[] price = new int[]&#123;7,1,5,3,6,4&#125;;new Solution().maxProfit(price); ======new start== 0 ==== ======new start== 1 ==== index :1--2 buy: 1 sell: 5 ======new start== 3 ==== index :3--4 buy: 3 sell: 6 ======new start== 5 ==== profit:0 profit change:0 --&gt; 3 index :3--5 buy: 3 sell: 4 max profit change:0 --&gt; 3 ======new start== 4 ==== ======new start== 5 ==== profit:3 profit change:0 --&gt; 7 index :1--3 buy: 1 sell: 3 ======new start== 4 ==== ======new start== 5 ==== profit:0 index :1--4 buy: 1 sell: 6 ======new start== 5 ==== profit:0 index :1--5 buy: 1 sell: 4 max profit change:0 --&gt; 7 ======new start== 2 ==== index :2--4 buy: 5 sell: 6 ======new start== 5 ==== profit:0 profit change:0 --&gt; 1 ======new start== 3 ==== index :3--4 buy: 3 sell: 6 ======new start== 5 ==== profit:0 profit change:0 --&gt; 3 index :3--5 buy: 3 sell: 4 ======new start== 4 ==== ======new start== 5 ==== profit:7 125. Valid PalindromeGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1:12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true Example 2:12Input: &quot;race a car&quot;Output: false 12345678910111213141516171819202122232425// 自己的解决方案class Solution &#123; public boolean isPalindrome(String s) &#123; //利用正则，去除空格和无关符号，倒转看知否相等 String pattern = "^[a-z0-9]"; s = s.toLowerCase(); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i =0 ; i&lt; s.length(); i++)&#123; if(String.valueOf(s.charAt(i)).matches(pattern))&#123; list.add(s.charAt(i)); &#125; &#125; Object[] strArray = list.toArray(); return isPalindromeArray(strArray); &#125; private boolean isPalindromeArray(Object[] array)&#123; int length = array.length; for(int i = 0; i&lt; array.length /2; i++)&#123; if( array[i] != array[length-1-i])&#123; return false; &#125; &#125; return true; &#125;&#125; 12345678910111213141516171819202122232425262728293031// 最好的解决方案class Solution &#123; private static final int[] map = new int[256]; static&#123; for(int i = 0; i &lt; 10; i++)&#123; map[i + '0'] = (i + 1); &#125; for(int i = 0; i &lt; 26; i++)&#123; map[i + 'a'] = map[i + 'A'] = (i + 11); &#125; &#125; public boolean isPalindrome(String s) &#123; char[] arrays = s.toCharArray(); int start = 0, end = arrays.length - 1; int startVal, endVal; while(start &lt; end)&#123; startVal = map[arrays[start]]; endVal = map[arrays[end]]; if(startVal != 0 &amp;&amp; endVal != 0)&#123; if(startVal != endVal) return false; start++; end--; &#125;else&#123; if(startVal == 0) start++; else end--; &#125; &#125; return true; &#125;&#125; 136. Single NumberGiven a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1:12Input: [2,2,1]Output: 1 Example 2:12Input: [4,1,2,1,2]Output: 4 123456789101112131415161718192021//自己写的错误方法class Solution &#123; public int singleNumber(int[] nums) &#123; int[] positive = new int[Integer.MAX_VALUE]; int[] negative = new int[Integer.MAX_VALUE]; for( int i = 0; i &lt; nums.length; i++ )&#123; if( nums[i] &gt;=0 )&#123; positive[nums[i]]++; &#125; else&#123; negative[-nums[i]]++; &#125; &#125; for( int i = 0; i &lt; Integer.MAX_VALUE; i++)&#123; if(positive[i] == 1 )return i; if(negative[i] == 1 )return i; &#125; return nums[0]; &#125;&#125; 12345678910// 推荐的方法class Solution &#123; public int singleNumber(int[] nums) &#123; int a = 0; for( int i = 0; i &lt; nums.length; i++ )&#123; a ^= nums[i]; &#125; return a; &#125;&#125; 141. Linked List CycleGiven a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 12345678910111213141516171819202122232425262728293031323334// my Code //错误原因：有环，但是不一定首尾相连，可能是中间部位/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125; &#125;public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode head_bak = head; if( null == head || head.next == null )return false; while(null != head.next)&#123; head = head.next; if( head_bak == head)&#123; return true; &#125; &#125; return false; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** 正确解法有两种： *一种通过Set来逐个加入，判断是否已含有，如果有则表示有环 *双指针解法，一个一次走一步，一个一次走两步，如果有环，总有一次会遇上**//** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125; &#125;public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if( null == head || head.next == null )return false; ListNode walker = head; ListNode runner = head.next; while(walker != runner)&#123; if( null == walker.next || null== runner.next)&#123; return false; &#125; walker = walker.next; runner = runner.next.next; &#125; return true; &#125;&#125; 8. String to Integer (atoi)Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.Example 1:12Input: &quot;42&quot;Output: 42 Example 2:1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3:123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. Example 4:1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5:1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 123456789101112131415161718192021222324252627282930//我的答案class Solution &#123; public int myAtoi(String str) &#123; if(null == str)return 0; String toInt = str.trim(); if( 0 == toInt.length())return 0; int start = 0; int end = 0; if(toInt.startsWith("-") || toInt.startsWith("+"))start ++; for(end = start; end &lt; toInt.length(); )&#123; if('0'&lt;= toInt.charAt(end) &amp;&amp; '9'&gt;= toInt.charAt(end))&#123; end++; &#125;else&#123; break; &#125; &#125; if(end - start &lt; 1)return 0; int value = 0; try&#123; value = Integer.parseInt(toInt.substring(0,end)); &#125;catch(Exception e)&#123; if(toInt.startsWith("-"))&#123; return Integer.MIN_VALUE; &#125;else&#123; return Integer.MAX_VALUE; &#125; &#125; return value; &#125;&#125; 123456789101112131415161718192021222324252627282930313233// 推荐答案class Solution &#123; public int myAtoi(String str) &#123; if(str==null || str.length() == 0) return 0; int index = 0; while(index &lt; str.length() &amp;&amp; str.charAt(index) == ' ') index++; int sign = 1; // 正负只能有一个，同时及时判断是否out of index if(index &lt; str.length() &amp;&amp; str.charAt(index) == '-') &#123; sign = -1; index++; &#125; else if (index &lt; str.length() &amp;&amp; str.charAt(index) == '+') &#123; index++; &#125; int total = 0; while(index &lt; str.length()) &#123; int digit = str.charAt(index) - '0'; if(digit &lt; 0 || digit &gt; 9) break; if((Integer.MAX_VALUE - digit) / 10 &lt; total) &#123;//判断是否超过int值范围 return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; total = total * 10 + digit; index++; &#125; return total * sign; &#125;&#125; 5. Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1:123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2:12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 12345678910111213141516171819202122232425262728// 我的答案class Solution &#123; public String longestPalindrome(String s) &#123; if(null == s || s.length() == 0 ) return ""; if(s.length() == 1) return s; int start = 0; int end = 1; String palindromeStr = ""; while(start !=s.length())&#123; String temp = s.substring(start,end); if(isPalindromic(temp))&#123; if(temp.length() &gt;= palindromeStr.length())&#123; palindromeStr = temp; &#125; &#125; end++; if(end &gt; s.length())&#123; start++; end = start +1; &#125; &#125; return palindromeStr; &#125; public boolean isPalindromic(String s)&#123; StringBuilder sb = new StringBuilder(s); return s.equals(sb.reverse().toString()); &#125;&#125; 12345678910111213141516171819202122232425//推荐答案class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt;= 1) return s; int len = s.length(); for (int i = 0; i &lt; len - 1; i++) &#123; extendPalindrome(s, i, i); // assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i + 1); // assume even length &#125; return s.substring(lo, lo + maxLen); &#125; private void extendPalindrome(String s, int i, int j) &#123; while (i &gt;= 0 &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i--; j++; &#125; if (maxLen &lt; j - i - 1) &#123;//j-i+1 -2 maxLen = j - i - 1; lo = i + 1; &#125; &#125;&#125; 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Example 1:123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2:123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3:1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 注释部分是自己写ac的答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; /*char[] sArray = s.toCharArray(); int maxLength = 0; for(int i = 0; i &lt; sArray.length; i++)&#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int j = i; j &lt; sArray.length; j++)&#123; if(set.contains(sArray[j])) break; set.add(sArray[j]); &#125; maxLength = maxLength &gt; set.size() ? maxLength : set.size(); &#125; return maxLength;*/ /* int len = 0; if(s==null || s.length() == 0) return len; int start = 0; int end = 1; len++; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); char[] c = s.toCharArray(); set.add(c[0]); int max = len; while( end != c.length)&#123; if( set.contains(c[end]))&#123; set.remove(c[start]); start++; len--; continue; &#125; set.add(c[end]); len++; end++; max = max &gt; len ? max : len; &#125; return max; */ int[] arr = new int[256]; int rep = 0; int max = 0; for(int i = 1; i &lt;= s.length(); i++)&#123; int c = s.charAt(i-1); rep = Math.max(rep,arr[c]); int count = i -rep ;//如果没有重复，rep等于0，count等于i，相当于count++ max = max &gt; count ? max : count; arr[c] = i; &#125; return max; &#125;&#125; 11. Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example:12Input: [1,8,6,2,5,4,8,3,7]Output: 49 1234567891011121314151617181920//逐个遍历求面积然后取最大值，肯定能做出来，但是效率太差class Solution &#123; public int maxArea(int[] height) &#123; int start = 0; int end = height.length -1; int cap = 0; while (start &lt; end)&#123; int min_height = Math.min(height[start], height[end]); int tempCap = min_height * (end -start); if(height[start] &lt; height[end])&#123;//我用的比较左右面积来移动，得出结果是错的；需思考为何用高度是对的 start ++; &#125;else&#123; end --; &#125; cap = cap &gt; tempCap ? cap : tempCap; &#125; return cap; &#125;&#125; 15. 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example:1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 我的acclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if(3 &gt; nums.length) return list; int num1Index = 0; int num2Index = 1; boolean is3Zero = false; boolean isAllZero = true; for(int i = 0; i &lt; nums.length; i++)&#123;//需要考虑全是0的特殊情况，避免大量判断 if(nums[i] != 0)&#123; isAllZero = false; break; &#125; &#125; if(isAllZero)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.add(0); tmp.add(0); tmp.add(0); list.add(tmp); return list; &#125; while(num1Index &lt; nums.length-2)&#123; for(int i = num2Index + 1; i &lt; nums.length; i++)&#123; if(nums[num1Index] + nums[num2Index] + nums[i] == 0)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.add(nums[num1Index]); tmp.add(nums[num2Index]); tmp.add(nums[i]); if(nums[num1Index] == 0 &amp;&amp; nums[num2Index] == 0 &amp;&amp; !is3Zero)&#123; list.add(tmp); is3Zero = true; continue; &#125; if(isDuplicated(list,tmp))continue; list.add(tmp); &#125; &#125; if(num2Index == nums.length-2)&#123; num1Index ++; num2Index = num1Index +1; &#125;else&#123; num2Index ++; &#125; &#125; return list; &#125; public boolean isDuplicated(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; list2)&#123; for(List&lt;Integer&gt; temp : list)&#123; if(temp.containsAll(list2))return true; &#125; return false; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 推荐答案，先进行排序，然后进行相关判断（子对队列首、尾相加并进行判断）class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; resultArray=new ArrayList&lt;&gt;(); if(nums==null||nums.length&lt;3) return resultArray; Arrays.sort(nums); for(int i=0;i&lt;nums.length-2;i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])continue; List&lt;List&lt;Integer&gt;&gt; result=find(nums,i+1,nums.length-1,nums[i]); resultArray.addAll(result); &#125; return resultArray; &#125; public List&lt;List&lt;Integer&gt;&gt; find(int[] nums,int start,int end,int target)&#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); int left=start,right=end; while(left&lt;right)&#123; if(nums[left]+nums[right]+target==0)&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); list.add(nums[left]); list.add(nums[right]); list.add(target); result.add(list); while(left&lt;right&amp;&amp;nums[left]==nums[left+1])left++; while(left&lt;right&amp;&amp;nums[right]==nums[right-1])right--; left++; right--; &#125; else if(nums[left]+nums[right]&lt;-1*target)//要使和大一些，那么right保持不动，left向右移动 &#123; left++; &#125; else &#123; right--; &#125; &#125; return result; &#125;&#125; 16. 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example:123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 123456789101112131415161718192021222324252627282930313233//我的答案class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int diff = 0; while(true)&#123; for(int i = 0; i &lt;nums.length; i++)&#123; // nums[i] + num[start] + nums[end] = target + diff if(find(nums, i+1, nums.length-1, target + diff - nums[i]))&#123; return target + diff; &#125; // nums[i] + num[start] + nums[end] = target - diff if(find(nums, i+1, nums.length-1, target - diff - nums[i]))&#123; return target - diff; &#125; &#125; diff++; &#125; &#125; public boolean find(int[] nums, int start, int end, int target)&#123; while(start &lt; end)&#123; if(nums[start] + nums[end] == target)&#123; return true; &#125;else if(nums[start] + nums[end] &lt; target)&#123; start++; &#125;else&#123; end--; &#125; &#125; return false; &#125;&#125; 1234567891011121314151617181920212223242526//使用空间最小的答案class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if(nums==null || nums.length&lt;3) return 0; Arrays.sort(nums); int len = nums.length; int result = nums[0]+nums[1]+nums[len-1]; for(int i=0; i&lt;len-2; i++)&#123; int val1 = nums[i]; int j=i+1; int k=len-1; while(j&lt;k)&#123; int sum = val1+nums[j]+nums[k]; if(sum &gt;target)&#123; k--; &#125;else&#123; j++; &#125; if(Math.abs(target-result) &gt; Math.abs(target-sum))&#123; result = sum; &#125; &#125; &#125; return result; &#125;&#125; 17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example:12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 123456789101112131415161718192021222324252627// 我的方法，使用循环实现class Solution &#123; public String[] letterTable = &#123;"","","abc", "def", "ghi", "jkl", "mno", "qprs", "tuv", "wxyz"&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if(digits.length() == 0)return list; for(int i = 0; i &lt; letterTable[digits.charAt(0) - '0'].length(); i++)&#123; list.add(letterTable[digits.charAt(0) - '0'].charAt(i) + ""); &#125; for(int i = 1; i &lt; digits.length(); i++)&#123; int digit = digits.charAt(i) - '0'; String numStr = letterTable[digit]; List&lt;String&gt; tmpList = new ArrayList(); for(String str : list)&#123; for(int j = 0; j &lt; numStr.length(); j++)&#123; tmpList.add(str + numStr.charAt(j)); &#125; &#125; list = tmpList; &#125; return list; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 当前排名使用最少空间的，使用的是递归的方法，其实原理和循环类似，通过substring方法完成递归实现class Solution &#123; Map&lt;Character, String&gt; phone = new HashMap&lt;Character, String&gt;() &#123;&#123; put('2', "abc"); put('3', "def"); put('4', "ghi"); put('5', "jkl"); put('6', "mno"); put('7', "pqrs"); put('8', "tuv"); put('9', "wxyz"); &#125;&#125;; List&lt;String&gt; output; public void backtrack(String combination, String next_digits)&#123; // if there is no more digits to check if(next_digits.length() == 0)&#123; // the combination is done output.add(combination); &#125; // if there are still digits to check else &#123; // iterate over all letters which map // the next available digit char digit = next_digits.charAt(0); String letters = phone.get(digit); for(int i = 0 ; i &lt; letters.length() ; i++)&#123; char letter = phone.get(digit).charAt(i); // append the current letter to the combination // and proceed to the next digits backtrack(combination + letter, next_digits.substring(1)); &#125; &#125; &#125; public List&lt;String&gt; letterCombinations(String digits) &#123; output = new ArrayList&lt;&gt;(); if(digits.length() != 0)&#123; backtrack("", digits); &#125; return output; &#125;&#125; 18. 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example:12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 123456789101112131415161718192021222324252627282930313233343536373839//我的ac 25 msclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); Arrays.sort(nums); if(nums.length &lt; 4)return result; for(int i = 0; i &lt; nums.length - 3; i++)&#123; for(int j = i + 1; j &lt; nums.length -2; j++)&#123; List&lt;List&lt;Integer&gt;&gt; tmpresult =find(nums, i, j, j + 1, nums.length - 1, target -nums[i] - nums[j]); result.addAll(tmpresult); while(j&lt;nums.length-2 &amp;&amp; nums[j] == nums[j+1])j++;//注意重复数值可能导致添加重复组合 &#125; while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1]) i++;//注意重复数值可能导致添加重复组合 &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; find (int[] nums, int ind1, int ind2, int left, int right, int target)&#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; List&lt;Integer&gt; tmp = new ArrayList(); tmp.add(nums[ind1]); tmp.add(nums[ind2]); tmp.add(nums[left]); tmp.add(nums[right]); result.add(tmp); while(left&lt;right&amp;&amp;nums[left] == nums[left+1])left++;//注意重复数值可能导致添加重复组合 while(left&lt;right&amp;&amp;nums[right] == nums[right-1])right--;//注意重复数值可能导致添加重复组合 left ++;//注意，这里还是得前进，因为前面只是排除重复的 right --;//注意，这里还是得前进，因为前面只是排除重复的 &#125;else if(nums[left] + nums[right] &lt; target)&#123; left ++; &#125;else&#123; right --; &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//查看其它ac后的改良版本 10 msclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); Arrays.sort(nums); if(nums.length &lt; 4)return result; for(int i = 0; i &lt; nums.length - 3; i++)&#123; // 此处为改良处，提前判断后续是否有合适的结果，减少不必要的计算 if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target) break; if(nums[i]+nums[nums.length-1]+nums[nums.length-2]+nums[nums.length-3]&lt;target) continue; for(int j = i + 1; j &lt; nums.length -2; j++)&#123; // 此处为改良处，提前判断后续是否有合适的结果，减少不必要的计算 if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[nums.length-1]+nums[nums.length-2]&lt;target) continue; List&lt;List&lt;Integer&gt;&gt; tmpresult =find(nums, i, j, j + 1, nums.length - 1, target -nums[i] - nums[j]); result.addAll(tmpresult); while(j&lt;nums.length-2 &amp;&amp; nums[j] == nums[j+1])j++; &#125; while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1]) i++; &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; find (int[] nums, int ind1, int ind2, int left, int right, int target)&#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; List&lt;Integer&gt; tmp = new ArrayList(); tmp.add(nums[ind1]); tmp.add(nums[ind2]); tmp.add(nums[left]); tmp.add(nums[right]); result.add(tmp); while(left&lt;right&amp;&amp;nums[left] == nums[left+1])left++; while(left&lt;right&amp;&amp;nums[right] == nums[right-1])right--; left ++; right --; &#125;else if(nums[left] + nums[right] &lt; target)&#123; left ++; &#125;else&#123; right --; &#125; &#125; return result; &#125;&#125; 1// 最少空间的ac 19. Remove Nth Node From End of ListGiven a linked list, remove the n-th node from the end of list and return its head. Example:123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. 12345678910111213141516171819202122232425262728293031323334353637// my ac/** Definition for singly-linked list.*/ public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode point = head; int size = 1; while(point.next != null)&#123; size ++; point = point.next; &#125; if(size ==1 &amp;&amp; n&gt;=1)return null; if(size == n)return head.next; point = head; for(int i = 0; i &lt; size - n -1; i++)&#123; point = point.next; &#125; if(point == head)&#123; if(size &gt; 2)&#123; head.next = head.next.next; &#125;else&#123; head.next = null; &#125; &#125;else&#123; if(null != point.next)&#123; point.next = point.next.next; &#125; &#125; return head; &#125;&#125; 1234567891011121314151617181920212223242526272829303132// min space ,使用的递归方法class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head == null || head.next == null) &#123; return null; &#125; int i = getNodeIndex(head,n); if(i == n) &#123; head = head.next; &#125; return head; &#125; private int getNodeIndex(ListNode node, int n) &#123; if(node.next == null) &#123; return 1; &#125; int i = 1 + getNodeIndex(node.next,n); if( n == i-1) &#123; node.next = node.next.next; return i ; &#125; return i; &#125;&#125; 22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 1234567891011121314151617181920212223// 第一次错误方法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList(); if(n == 0)return list; list.add("()"); for(int i = 1; i &lt; n; i++)&#123; List&lt;String&gt; tmp = new ArrayList(); for(String str : list)&#123; tmp.add("(" + str +")"); String tmpstr = str + "()"; if(tmpstr.equals("()"+str))&#123; tmp.add(tmpstr); &#125;else&#123; tmp.add(str + "()"); tmp.add("()" + str); &#125; &#125; list = tmp; &#125; return list; &#125;&#125; 12345678910111213141516171819202122232425262728293031//第二次错误方法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; listAll = new ArrayList(); List&lt;String&gt; tmp = new ArrayList(); if(n == 0)return tmp; tmp.add("()"); listAll.add(tmp); for(int i = 1; i &lt; n; i++)&#123; tmp = new ArrayList(); for(int j = 1; j &lt;= i/2 + 1; j++)&#123; if( j==1 )&#123; for(String str : listAll.get(i-1))&#123; tmp.add("(" + str + ")"); &#125; &#125; for(String str1:listAll.get(j-1))&#123; for(String str2 : listAll.get(i - j))&#123; tmp.add(str2 + str1); &#125; &#125; &#125; if(i&gt;=2)tmp.remove(tmp.size() -1); listAll.add(tmp); &#125; return listAll.get(n-1); &#125;&#125; 123456789101112131415161718// 推荐方法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList(); if(n == 0)&#123; list.add(""); &#125;else&#123; for(int i = 0; i &lt; n; i++)&#123; for(String left : generateParenthesis(i))&#123; for(String right : generateParenthesis(n - i -1))&#123; list.add("(" + left + ")" + right);//此处添加了一对括号 &#125; &#125; &#125; &#125; return list; &#125;&#125; 1234567891011121314151617181920//回溯法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList(); backtrack(ans, "", 0, 0, n); return ans; &#125; public void backtrack(List&lt;String&gt; ans, String cur, int open, int close, int max)&#123; if (cur.length() == max * 2) &#123; ans.add(cur); return; &#125; if (open &lt; max) backtrack(ans, cur+"(", open+1, close, max); if (close &lt; open) backtrack(ans, cur+")", open, close+1, max); &#125;&#125; 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; combinations = new ArrayList(); generateAll(new char[2 * n], 0, combinations); return combinations; &#125; public void generateAll(char[] current, int pos, List&lt;String&gt; result) &#123; if (pos == current.length) &#123; if (valid(current)) result.add(new String(current)); &#125; else &#123; current[pos] = '('; generateAll(current, pos+1, result); current[pos] = ')'; generateAll(current, pos+1, result); &#125; &#125; public boolean valid(char[] current) &#123; int balance = 0; for (char c: current) &#123; if (c == '(') balance++; else balance--; if (balance &lt; 0) return false; &#125; return (balance == 0); &#125;&#125; 24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example:1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 1234567891011121314151617181920212223242526272829303132// my ac// Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; public ListNode swapPairs(ListNode head) &#123; return douExchange(head); &#125; public ListNode douExchange(ListNode left)&#123; if(left == null)return null; if(left.next ==null)return left; ListNode point = left.next.next; ListNode right = left.next; // 如果右边是最后一个，需要额外考虑 if(null == right.next)&#123; left.next = null; right.next = left; return right; &#125;else&#123; left.next = right.next.next; right.next = left; &#125; left.next = douExchange(point); return right; &#125;&#125; 12345678910111213// better acclass Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head ==null || head.next ==null)return head; ListNode tmp = head; head = head.next; tmp.next = head.next; head.next = tmp; // tmp.next = swapPairs(tmp.next); head.next.next = swapPairs(head.next.next);//这样写，即使是head.next是最后一个节点也可以解决 return head; &#125; &#125; 29. Divide Two IntegersGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1:12Input: dividend = 10, divisor = 3Output: 3 Example 2:12Input: dividend = 7, divisor = -3Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^{31}$,$2^{31}$ − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. 12345678910111213//MY ACclass Solution &#123; public int divide(int dividend, int divisor) &#123; if(dividend == Integer.MIN_VALUE &amp;&amp; divisor ==-1)return Integer.MAX_VALUE; try&#123; int result = dividend/divisor; if(result &lt; Integer.MIN_VALUE || result &gt;= Integer.MAX_VALUE)return Integer.MAX_VALUE; return result; &#125;catch(Exception e) &#123; return Integer.MAX_VALUE; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233// BETTER AC class Solution &#123; public int divide(int dividend, int divisor) &#123; if (dividend == 0) &#123; return 0; &#125; if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; boolean isPositive = true; if (dividend &gt; 0 &amp;&amp; divisor &lt; 0 || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) &#123; isPositive = false; &#125; long a = Math.abs((long) dividend); long b = Math.abs((long) divisor); int shift = 0; int result = 0; // 所有的整数都能用2的若干次幂求和得到，同时采用位移操作，能加快运算效率 while (a &gt;= b) &#123; while (a &gt;= b &lt;&lt; shift) &#123; shift++; &#125; a -= b &lt;&lt; (shift - 1); result += 1 &lt;&lt; (shift - 1); shift = 0; &#125; return isPositive ? result : -result; &#125;&#125; 33. Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1:12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2:12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int search(int[] nums, int target) &#123; if(nums.length ==0)return -1; if(nums[0] == target)return 0; return find(nums, 0, nums.length-1, target); &#125; public int find(int[] nums, int left, int right, int target)&#123; if(right &lt;left)return -1; if(nums[left] == target)return left; if(nums[right] == target)return right; int mid = left + (right -left)/2; if(nums[mid] == target)return mid; //判断右边的数值是否比左边的小，如果是，则说明翻转过 if(nums[mid] &lt; nums[right])&#123; //判断target落在哪个区间 //一定只会有两种可能，要么在左边，要么在右边 if(nums[mid] &lt; target &amp;&amp; target &lt; nums[right]) &#123; return find(nums, mid+1, right, target); &#125;else&#123; return find(nums, left, mid-1, target); &#125; &#125;else&#123; if(nums[left] &lt; target &amp;&amp; target &lt; nums[mid]) &#123; return find(nums, left, mid-1, target); &#125;else&#123; return find(nums, mid+1, right, target); &#125; &#125; &#125;&#125; 34. Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1:12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2:12Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 1234567891011121314151617181920212223242526// my acclass Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int tindex = find(nums, 0, nums.length-1, target); int left = tindex, right = tindex; while(left &gt;0 &amp;&amp;nums[left -1] == target)&#123; left --; &#125; while(right &lt; nums.length-1 &amp;&amp; nums[right +1] == target)&#123; right ++; &#125; return new int[]&#123;left, right&#125;; &#125; public int find(int[] nums, int left, int right, int target)&#123; if(left &gt; right)return -1; if(nums[left] == target)return left; if(nums[right] == target)return right; int mid = left + (right - left)/2; if(nums[mid] == target)return mid; if( nums[mid] &lt; target &amp;&amp; target &lt; nums[right])&#123; return find(nums, mid +1, right, target); &#125;else&#123; return find(nums, left, mid-1, target); &#125; &#125;&#125; 36. Valid SudokuDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. Example 1:12345678910111213Input:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true Example 2:12345678910111213141516Input:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. 1234567891011121314151617181920212223242526272829303132333435363738394041// my acclass Solution &#123; public boolean isValidSudoku(char[][] board) &#123; // 先进行判断 for(int i = 0; i &lt;9; i++)&#123; Set&lt;Character&gt; set = new HashSet(); for(int j = 0; j&lt;9; j++)&#123; if(!(board[i][j] == '.'))&#123; if(set.contains(board[i][j]))return false; set.add(board[i][j]); &#125; &#125; &#125; // 进行列判断 for(int i = 0; i &lt;9; i++)&#123; Set&lt;Character&gt; set = new HashSet(); for(int j = 0; j&lt;9; j++)&#123; if(! (board[j][i] == '.'))&#123; if(set.contains(board[j][i]))return false; set.add(board[j][i]); &#125; &#125; &#125; // 九宫格判断 for(int i = 0; i &lt;9; i = i + 3)&#123; for(int j = 0; j&lt;9; j = j + 3)&#123; Set&lt;Character&gt; set = new HashSet(); for(int k = 0; k&lt;3; k++)&#123; for(int h=0; h&lt;3; h++)&#123; if(!(board[i+k][j+h] == '.'))&#123; if(set.contains(board[i+k][j+h]))return false; set.add(board[i+k][j+h]); &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536// suggested acclass Solution &#123; public boolean isValidSudoku(char[][] board) &#123; // init data HashMap&lt;Integer, Integer&gt; [] rows = new HashMap[9]; HashMap&lt;Integer, Integer&gt; [] columns = new HashMap[9]; HashMap&lt;Integer, Integer&gt; [] boxes = new HashMap[9]; for (int i = 0; i &lt; 9; i++) &#123; rows[i] = new HashMap&lt;Integer, Integer&gt;(); columns[i] = new HashMap&lt;Integer, Integer&gt;(); boxes[i] = new HashMap&lt;Integer, Integer&gt;(); &#125; // validate a board for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char num = board[i][j]; if (num != '.') &#123; int n = (int)num; int box_index = (i / 3 ) * 3 + j / 3; // keep the current cell value rows[i].put(n, rows[i].getOrDefault(n, 0) + 1); columns[j].put(n, columns[j].getOrDefault(n, 0) + 1); boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1); // check if this value has been already seen before if (rows[i].get(n) &gt; 1 || columns[j].get(n) &gt; 1 || boxes[box_index].get(n) &gt; 1) return false; &#125; &#125; &#125; return true; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// my preferred acclass Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; int[] row = new int[9]; int[] col = new int[9]; int[] cube = new int[9]; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != '.') &#123; if (row[board[i][j] - '1'] == 1) &#123; return false; &#125; else &#123; row[board[i][j] - '1'] = 1; &#125; &#125; if (board[j][i] != '.') &#123; if (col[board[j][i] - '1'] == 1) &#123; return false; &#125; else &#123; col[board[j][i] - '1'] = 1; &#125; &#125; // 每一宫内行列的变化 int cubeX = 3 * (i / 3) + j / 3; int cubeY = 3 * (i % 3) + j % 3; if (board[cubeX][cubeY] != '.') &#123; if (cube[board[cubeX][cubeY] - '1'] == 1) &#123; return false; &#125; else &#123; cube[board[cubeX][cubeY] - '1'] = 1; &#125; &#125; &#125; &#125; return true; &#125;&#125; 39. Combination SumMark Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations. Example 1:123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 2:1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); Arrays.sort(candidates);//貌似本身排好序的，加上无伤大雅 find(candidates, 0, result, tmp, target); return result; &#125; public void find(int[] candidates, int sIndex, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int target )&#123; if(target == 0)&#123; result.add(tmp); return ; &#125; if(target &lt; 0)&#123; return; &#125; for(int i = sIndex; i &lt; candidates.length; i++)&#123; List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(candidates[i]); find(candidates, i, result, tmpc, target - candidates[i]); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031// better answer ，利用数组替换List能够节省空间class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;(); int [] path=new int[100];//记录答案 int len=0; public void robot(int idx,int [] nums,int target)&#123;//idx是扫描到数组哪个数字 if(target==0)&#123; //拼答案,把记录在path里的数字拿出来 List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); for(int i=0;i&lt;len;i++)&#123; res.add(path[i]); &#125; ans.add(res); return; &#125; if(target&lt;0||idx&gt;=nums.length) return; //写递归,两种策略取和不取nums[idx] path[len]=nums[idx]; len++; robot(idx,nums,target-nums[idx]);//取但是idx不加1，因为下一次还可以取这个数 len--;//必须加这行，因为递归结束后不满足条件的数要从刚加入的删除掉，也就是指针回滚 robot(idx+1,nums,target);//不在取前面的数 &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; robot(0,candidates,target); return ans; &#125;&#125; 40. Combination Sum IIMark Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.Example 1:12345678Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Example 2:123456Input: candidates = [2,5,2,1,2], target = 5,A solution set is:[ [1,2,2], [5]] 1234567891011121314151617181920212223242526272829303132// my extreme difficult acclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); find(candidates, 0, result, tmp, target); return result; &#125; public void find(int[] candidates, int sidx, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int target)&#123; if(target ==0)&#123; result.add(tmp); return; &#125; if(target &lt; candidates[0])&#123;//相比小于0，能更快结束递归 return ; &#125; for(int i = sidx; i &lt; candidates.length &amp;&amp; candidates[i] &lt;= target; i++)&#123; /* if (i &gt; sidx &amp;&amp; candidates[i] == candidates[i-1])&#123;//达到的效果和后面while一样 continue; &#125;*/ List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(candidates[i]); find(candidates, i+1, result, tmpc, target - candidates[i]); while(i &lt; candidates.length -1 &amp;&amp; candidates[i] == candidates[i+1])&#123; i++; &#125; &#125; &#125;&#125; 43. Multiply StringsGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1:12Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot; Example 2:12Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// my acclass Solution &#123; public String multiply(String num1, String num2) &#123; if("0".equals(num1) || "0".equals(num2))return "0"; return bigMul(num1, num2).toString(); &#125; public StringBuilder bigMul(String num1, String num2)&#123; StringBuilder result = new StringBuilder(); // 先将字符串翻转，方便计算 String num1rev = new StringBuilder(num1).reverse().toString(); String num2rev = new StringBuilder(num2).reverse().toString(); for(int i = 0; i &lt; num1rev.length(); i++ )&#123; StringBuilder tmp = new StringBuilder(); int carry = 0; for(int count = 0; count &lt; i; count++)&#123; tmp.append("0"); &#125; int mul1 = num1rev.charAt(i) - '0'; for(int j = 0; j &lt; num2rev.length(); j++)&#123; int mul2 = num2rev.charAt(j) - '0'; int product = mul1 * mul2 + carry; carry = product /10; tmp.append(product % 10); &#125; if(carry &gt; 0)tmp.append(carry); result = bigAdd(result.toString(), tmp.reverse().toString()); &#125; return result; &#125; public StringBuilder bigAdd(String num1, String num2)&#123; StringBuilder result = new StringBuilder(); // 先将字符串翻转，方便计算 String num1rev = new StringBuilder(num1).reverse().toString(); String num2rev = new StringBuilder(num2).reverse().toString(); int carry = 0; int i = 0; for(i = 0; i &lt; num1rev.length() &amp;&amp; i&lt; num2rev.length(); i++)&#123; int add1 = num1rev.charAt(i) - '0'; int add2 = num2rev.charAt(i) - '0'; int sum = add1 + add2 +carry; carry = sum /10; result.append(sum %10); &#125; while(i &lt; num1rev.length())&#123; int add = num1rev.charAt(i) - '0'; int sum = add + carry; carry = sum /10; result.append(sum %10); i++; &#125; while(i &lt; num2rev.length())&#123; int add = num2rev.charAt(i) - '0'; int sum = add + carry; carry = sum /10; result.append(sum %10); i++; &#125; if(carry &gt;0)result.append(carry); return result.reverse(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536// better ac，利用数组处理结果能够良好节省计算过程空间和时间class Solution &#123; public String multiply(String num1, String num2) &#123; StringBuilder res = new StringBuilder(); char[] a = num1.toCharArray(); char[] b = num2.toCharArray(); if ((num1.length()==1&amp;&amp;num1.equals("0"))||(num2.length()==1&amp;&amp;num2.equals("0")))return "0"; //两数相乘最大不会超过两位相加的位数 int[] result = new int[a.length + b.length]; //两数倒向相乘 for (int i = a.length-1; i &gt;=0; i--) &#123; for (int j=b.length-1; j &gt;=0; j--) &#123; result[a.length-1-i + b.length-1-j]+= (a[i] - 48) * (b[j] - 48); &#125; &#125; for (int i = 0; i &lt; result.length - 1; i++) &#123; if (result[i] &gt;= 10) &#123; result[i + 1] += result[i] / 10; result[i] = result[i] % 10; &#125; &#125; //从前向后判断是否可以读取也就是第一位是不是为零 boolean juge = false; for (int i = result.length - 1; i &gt;= 0; i--) &#123; if (result[i] != 0) &#123; juge = true; &#125; if (juge) &#123; res.append(result[i]); &#125; &#125; return res.toString(); &#125;&#125; 46. PermutationsGiven a collection of distinct integers, return all possible permutations. Example:12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 1234567891011121314151617181920212223// my acclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); combine(result, tmp, nums); return result; &#125; public void combine(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int[] nums)&#123; if(tmp.size() == nums.length)&#123; result.add(tmp); return; &#125;else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tmp.contains(nums[i]))continue; List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(nums[i]); combine(result, tmpc, nums); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// seems better ac ? 利用数组记录该数是否已包含该数字，而不是用list判断class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; numList; private boolean[] isContain; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; numList = new ArrayList&lt;&gt;(); isContain = new boolean[nums.length]; for (int i = 0; i &lt; isContain.length; i++) &#123; isContain[i] = false; &#125; List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); getPermute(nums, 0 , integerList); return numList; &#125; /** * * @param nums * @param index * @param result */ private void getPermute(int[] nums, int index, List&lt;Integer&gt; result)&#123; if(index == nums.length)&#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(result); numList.add(tempList); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if(!isContain[i])&#123; result.add(nums[i]); isContain[i] = true; getPermute(nums, index + 1, result); //判断完后回溯 result.remove(result.size() - 1); isContain[i] = false; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// 不是很好理解 2ms/**每次将已经选过的数字换在前面去，如第n个数是nums[m],则将nums[m]和nums[n]互换未利用额外空间，同时只对数组进行操作*/class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if(nums ==null)return result; int len = nums.length; sortNums(nums, 0, len); return result; &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public void sortNums(int[] nums, int n, int len)&#123; List&lt;Integer&gt; list = new ArrayList(); if(len-1 ==n)&#123; for(int i =0; i &lt;len; i++)&#123; list.add(nums[i]); &#125; result.add(list); return; &#125; for(int j =n; j &lt;len; j++)&#123; swap(nums,n,j); sortNums(nums,n+1,len); swap(nums,n,j); //不还原，for不同次的循环使用的nums不同 &#125; &#125; public void swap(int[] nums, int n, int j)&#123; int temp = 0; temp = nums[n]; nums[n] = nums[j]; nums[j] = temp; &#125;&#125; 47. Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations. Example:1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 1234567891011121314151617181920212223242526272829// my ac,实验证明用数组记录是否已包含该数值会比用list.contains效果更好，因为前者可以定位到具体位置的数字，而不是判断值是否相等class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); boolean[] isContained = new boolean[nums.length]; combine(result, tmp, nums, isContained); return result; &#125; public void combine(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int[] nums, boolean[] isContained)&#123; if( tmp.size() == nums.length )&#123; result.add(tmp); return; &#125; for(int i = 0; i &lt; nums.length; i++)&#123; if(isContained[i])continue; List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(nums[i]); isContained[i] = true; combine(result, tmpc, nums, isContained); isContained[i] = false; while(i &lt; nums.length -1 &amp;&amp; nums[i] == nums[i+1])&#123; i++; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// 使用的回溯，相比之下，比我的方法能节约多次new ArrayList(tmp)的空间import java.util.Arrays;import java.util.List;import java.util.ArrayList;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (nums == null || nums.length == 0) &#123; return ret; &#125; Arrays.sort(nums); boolean[] visited = new boolean[nums.length]; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); dfs(nums, visited, list, ret); return ret; &#125; public void dfs(int[] nums, boolean[] visited, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (list.size() == nums.length) &#123; ret.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) &#123; continue; &#125; if (!visited[i]) &#123; list.add(nums[i]); visited[i] = true; dfs(nums, visited, list, ret); list.remove(list.size() - 1); visited[i] = false; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 和上一题一样，还是这货，用的换值的方法 3msclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); traceback(nums,0,nums.length-1,result); return result; &#125; private void traceback(int[] nums, int start, int length, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (start==length)&#123; List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); for (int num:nums) &#123; item.add(num); &#125; res.add(item); return; &#125; for (int i = start; i &lt;=length; i++) &#123; if(isDuplicate(nums,start,i))&#123; swap(nums,start,i); traceback(nums,start+1,length,res); swap(nums,start,i); &#125; &#125; &#125; private boolean isDuplicate(int[] nums, int start, int end) &#123; for (int j = start; j &lt;end; j++) &#123; if (nums[j]==nums[end])&#123; return false; &#125; &#125; return true; &#125; private void swap(int[] nums, int i, int start) &#123; int temp = nums[i]; nums[i] = nums[start]; nums[start] = temp; &#125;&#125; 48. Rotate ImageYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1:12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2:123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 123456789101112131415161718192021222324252627// my ac 2msclass Solution &#123; public void rotate(int[][] matrix) &#123; // 先逐行将数据倒转顺序 int sideLen = matrix.length; int evenOdd = sideLen %2; for(int row = 0; row &lt; matrix.length; row++)&#123; for(int col = 0; col &lt; matrix[0].length /2 + evenOdd; col ++)&#123; int tmp = matrix[row][col]; matrix[row][col] = matrix[row][sideLen - col -1] ; matrix[row][sideLen - col -1] = tmp; &#125; &#125; // 将数组matrix对折，matrix[i][j]与matrix[n-j][n-i] //将数组matrix对折，matrix[i][j]与matrix[j][i]交换为逆时针 for(int row = 0; row &lt; matrix.length ; row++)&#123; for(int col = 0; col &lt; sideLen - row ; col ++)&#123; int tmp = matrix[row][col]; matrix[row][col] = matrix[sideLen -1 - col][sideLen - row -1]; matrix[sideLen -1 - col][sideLen - row -1] = tmp; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728// shortest time 1msclass Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; float translate = (n - 1) / 2.0f; int last; int col, row;// 剥洋葱 for (int i = 0; i &lt; n / 2; i++) &#123; // 圈 for (int j = i; j &lt; n - i - 1; j++) &#123; // 边 last = matrix[i][j];// 为第一次交换存值 row = i; col = j; //加上后面三次，四条边，交换四次 for (int k = 0; k &lt; 3; k++) &#123; // 点// pre_point int pre_col = row; int pre_row = (int) (2 * translate - col); matrix[row][col] = matrix[pre_row][pre_col]; row = pre_row; col = pre_col; &#125; matrix[row][col] = last; &#125; &#125; &#125;&#125; 49. Group AnagramsGiven an array of strings, group anagrams together. Example:1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase. The order of your output does not matter. 1234567891011121314151617181920212223242526272829303132333435363738394041// my ac 1741msclass Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList(); if(strs.length == 0)return result; List&lt;String&gt; temp = new ArrayList(); temp.add(strs[0]); result.add(temp); for(int i = 1; i &lt; strs.length; i++)&#123; boolean added = false; for(int j = 0; j &lt; result.size(); j++)&#123; temp = result.get(j); if(compareString(temp.get(0), strs[i]))&#123; temp.add(strs[i]); added = true; &#125; &#125; if(!added)&#123; temp = new ArrayList(); temp.add(strs[i]); result.add(temp); &#125; &#125; return result; &#125; public boolean compareString(String a, String b)&#123; if(a.length() != b.length() ) return false; int[] countA = new int[26]; int[] countB = new int[26]; int len = a.length(); for(int i = 0; i &lt; len; i++)&#123; countA[a.charAt(i) - 'a'] ++; countB[b.charAt(i) - 'a'] ++; &#125; for(int i = 0; i &lt; 26; i++ )&#123; if(countA[i] != countB[i])return false; &#125; return true; &#125;&#125; 123456789101112131415161718192021222324252627282930// best acclass Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; //只有质数才能保证相乘的结果是真的唯一 int[] prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;;//最多10609个z List&lt;List&lt;String&gt;&gt; resultList = new ArrayList&lt;List&lt;String&gt;&gt;(); // // key = 唯一键值， value = resultList 中的 Key 的下标； HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (String s : strs) &#123; int key = 1; for (char c : s.toCharArray()) &#123;// 获得唯一Key key *= prime[c - 'a']; &#125; List&lt;String&gt; targetList; if (map.containsKey(key)) &#123; targetList = resultList.get(map.get(key)); &#125; else &#123; targetList = new ArrayList&lt;String&gt;(); resultList.add(targetList); map.put(key, resultList.size() - 1); &#125; targetList.add(s); &#125; return resultList; &#125;&#125; 50. Pow(x, n)Implement pow(x, n), which calculates x raised to the power n (xn). Example 1:12Input: 2.00000, 10Output: 1024.00000 Example 2:12Input: 2.10000, 3Output: 9.26100 Example 3:123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [$−2^{31}$, $2^{31}$ − 1] 1234567891011121314// 这道题的关键在于超时和效率class Solution &#123; public double myPow(double x, int n) &#123; double result = 1.0; for(int i = n; i != 0; i = i/2)&#123;//i==0时结束，n可能小于0，所以判断不等于0是最好的方式。 if(i%2 !=0)&#123; result *= x; &#125; x *= x; &#125; return n &gt; 0 ? result : 1.0/result; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cypher学习笔记]]></title>
    <url>%2F2018%2F07%2F26%2Fcypher%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[neo4j操作语言，cypher常用操作笔记 参考博文： https://blog.csdn.net/weixin_39012047/article/details/82348881 https://blog.csdn.net/qq_32662595/article/details/79876345 https://www.cnblogs.com/shangbingbing/p/5052964.html 一、查(match)查询节点 cypher 在很多方面比较相似，如order by、asc/desc、limit、distinct 12345678// 这种方式很像 sqlstart n = node(*) // 该端很多时候省略，表示遍历时在图中的起点，可以通过节点id或者查找获得match (n:Person) // 选择指定类型的节点where n.name = &quot;Jane&quot; //使用相关属性进行筛选and n.age = 19return n// 也可以以另一种方式书写match (n:Person&#123;name:&quot;Jane&quot;, age:19&#125;) return n 如果放在mysql里差不多是这样 1select * from Person n where n.name = &quot;Jane&quot; and n.age= 19 对结果进行排序、升降序 1match (n:Person) return n order by n.age desc limit 25 分页查询 1match (n:Person) return n order by n.age desc skip 1 limit 25 // skip 1 limit 25 第一条不返回 where 后条件中的操作符 数学操作符： + 、 - 、 * 、 / 、 % 比较操作符号 含义 = 相等 &lt;&gt; 不等于（字符串等比对等不使用 != 而使用 &lt;&gt;） &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 根据索引检索（待验证） 12START n=node:N_INDEX (USER_NAME=&apos;tom&apos;) RETURN n SKIP 0 LIMIT 20START n=node:N_INDEX(&apos;USER_NAME:*tom*&apos;) RETURN n SKIP 0 LIMIT 20 查询关系（链） 通用查询(注意：关系是有方向的) 1match p = ()-[]-() return p //返回所有关系链 指定关系类型查询 1match p = ()-[r:has_father]-&gt;() return p // 返回所有父子关系对 指定关系层数 目前没发现怎么限定r的方法 12345match p = ()-[r*2]-() return p //返回固定层数match p = ()-[r*2..4]-() return p // 返回2到4层关系链match p = ()-[r*..4]-() return p // 返回4层以下关系链match p = ()-[r*2..]-() return p // 返回2层以上关系链match p = ()-[*]-() return p // 不限长度 指定节点到节点的关系 123match (a:Person),(b:Person),p=(a)-[r:has_father]-&gt;(b)where a.name = &quot;son&quot; and b.name = &quot;father&quot;return p 模糊查询123match (n:N)where n.attr =~ &apos;.*a1.*|.*a2.*&apos; // 尽量不要分成两个orreturn n 二、更新（set/remove） cypher更新与mysql类似，都需要先定位需要修改的节点或者关系位置 不同的是，cypher中，如果对已有属性进行set时为更新该属性的值，如果没有该属性，则会新增该属性并设值 在mysql中如果没有对应字段，则会报错。 1234match (a:Person),(b:Person),p=(a)-[r:has_father]-&gt;(b)where a.name = &quot;son&quot; and b.name = &quot;father&quot;set r.new_type = `has_son` //如果已有属性new_type则更新值，如果没有，则新增该属性并设值return p 123match (n:Person&#123;name:&quot;Jane&quot;, age:19&#125;) set n.nickName = &quot;J&quot; //如果已有属性 nickName 则更新值，如果没有，则新增该属性并设值return n set1234567// 使用 键值对 添加属性merge (n:Student&#123;name:&quot;小明&quot;&#125;) SET n += &#123; hungry: TRUE , position: &apos;outside the classroom&apos; &#125; return n// 使用set 设置多个属性match(n:Student) where n.name=&quot;小明&quot; set n.hungry=&quot;True&quot;, n.position=&quot;outside the classroom&quot; return n// 给节点添加标签MATCH (n &#123; name: &apos;Stefan&apos; &#125;) SET n :German RETURN nMATCH (n &#123; name: &apos;Emil&apos; &#125;) SET n :Swedish:Bossman RETURN n remove1234// 删除属性match (n:Student) where n.name=&quot;小明&quot; REMOVE n.age return n// 删除节点的标签,其写法与set的设置标签一样match (n:Student:Person:LeagueMember) where n.name=&quot;小明&quot; REMOVE n:Student:LeagueMember return n 三、增（create、merge） 不同于mysql，在neo4j中，即使数据库中已有数据完全一致的节点，使用create依旧会创建新节点，原因在于neo4j中的每一个节点都有一个独一无二的id，使用id(n)可以获得其id。因而也就有了merge，merge会先检查是否已存在满足条件的节点，然后再进行操作。 create 创建节点 123create (n:Person:Student) set n.name = &quot;小明&quot; return n //创建带多个标签的节点，小明既是人，也是学生 create (n:Person &#123;name:&quot;weiw&quot;,age:23&#125;) return n create (n:Person) set n.name = &quot;weiw&quot;, n.age =23 return n //创建节点并对属性设值 创建关系 值得注意的是，neo4j中，关系也可以和节点一样，设置properties 1234567// 创建两个节点间关系match (a:Person),(b:Person) where a.name=&quot;zhangs&quot; and b.name=&quot;lisi&quot; create (a)-[r:RELTYPE]-&gt;(b) return r// 创建关系，并对关系设值match (a:Person),(b:Person) where a.name=&quot;zhangs&quot; and b.name=&quot;lisi&quot; create (a)-[r:RELTYPE &#123;name:a.name +&quot;&lt;-&gt;&quot; + b.name&#125;]-&gt;(b) return r// 设置多个节点间的关系,最好通过match来定位节点create p=(an &#123;name:&quot;an&quot;&#125;)-[:WORKS_AT]-&gt;(neo)&lt;-[:WORKS_AT]-(mach &#123;name:&quot;mach&quot;&#125;) return p; merge 和create不同的是，对不存在的节点进行创建，存在的直接返回。 合并 节点 12merge (n:Person&#123;name:&quot;小明&quot;&#125;) set n.age = 23 return nmerge (n:Person) where n.name = &quot;小明&quot; set n.age = 23 return n 条件 合并 123456// 找到节点就设值merge (keanu:Person &#123;name:&quot;Keanu&quot;&#125;) on match set person.found=true return person;// 在创建节点的时候，进行set设值merge (keanu:Person &#123;name:&quot;Keanu&quot;&#125;) on create set keanu.created=timestamp() return keanu;// 找到就设值，没找到就创建节点并设值merge (keanu:Person &#123;name:&quot;Keanu&quot;&#125;) on create set keanu.created=timestamp() on match set keanu.lastSeen=timestamp() return keanu; 合并 关系 123456// 一般先match 节点，再进行merge/creatematch (charlie:Person &#123;name:&quot;Charlie&quot;&#125;),(wall:Movie &#123;title:&quot;Wall&quot;&#125;)merge (charlie)-[r:ACTED_AT]-&gt;(wall) return r;// 合并非直接关系(在创建关系的时候必须有方向，merge 创建关系时，默认的方式是前者指向后者)MATCH (charlie:Person &#123; name:&apos;Charlie Sheen&apos; &#125;),(oliver:Person &#123; name:&apos;Oliver Stone&apos; &#125;) MERGE (charlie)-[r:KNOWS]-(oliver) RETURN r 约束 123CREATE CONSTRAINT ON (n:Person) ASSERT n.name IS UNIQUE; CREATE CONSTRAINT ON (n:Person) ASSERT n.role IS UNIQUE;MERGE (laurence:Person &#123; name: &apos;Laurence Fishburne&apos; &#125;) RETURN laurence ； 四、删(delete) 删和查有点类似，只不过将对应的return换成delete即可, 需要注意的是，在neo4j中，如果有关系没有删除，节点是不允许删除的 123456// 删除节点MATCH (n:Student) where n.name=&quot;小明&quot; DELETE n;// 删除关系MATCH (a:Studeng)-[r:love]-(b:Studeng) where a.name=&quot;小明&quot; and b.name=&quot;小红&quot; DELETE r// 删除 关系和节点MATCH (a:Studeng)-[r:love]-(b:Studeng) where a.name=&quot;小明&quot; and b.name=&quot;小红&quot; DELETE r，a, b 五、其他特殊关键字与函数当前用得不多，待后面继续更新。]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>cypher</tag>
        <tag>neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 基本配置]]></title>
    <url>%2F2018%2F07%2F26%2FCentOS%207%20%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[CentOS7 从新装到常用软件、常用配置指令等的配置笔记 [TOC] 一、 预备工作1、图形界面安装1234# 安装 "X Window System"yum groupinstall "X Window System" -y# 查看支持的软件（已安装的和可安装的）yum grouplist 1234# 安装图形界面yum groupinstall "GNOME Desktop" "Graphical Administration Tools" -y# 启动图形界面startx 可能遇到的报错 分析出错提示可以看出是在安装fwupdate-efi-12-5.e17.centosx86_64这个软件包时和系统自带的grub2-common1:2.02-0.64.e17.centos.noarch软件包有冲突。将该包更新，然后安装fwupdate-efi-12-5.e17.centosx86_64。最后重新执行“X Window System”安装。测试如下： 123&gt; yum update grub2-commonn&gt; yum install fwupdate-efi -y&gt; 2、配置阿里云yum源来源：https://www.cnblogs.com/aiaiduo/p/8093898.html 1234567891011# 下载Centos7对应的repo文件wget http://mirrors.aliyun.com/repo/Centos-7.repo# 备份并替换系统原有的repo文件cp Centos-7.repo /etc/yum.repos.d/cd /etc/yum.repos.d/mv CentOS-Base.repo CentOS-Base.repo.bakmv Centos-7.repo CentOS-Base.repo# 更新yum源yum clean allyum makecacheyum update 二、相关软件安装配置1、VNC 远程连接配置 vnc安装与配置 12345678910111213141516# 检查是否已安装vnc相关服务ps -eaf | grep vnc# 检查 vnc相关的包是否已安装rpm -qa | grep vnc# 安装 vncviewer,vncserver， 我使用的 yum -y install vnc *vnc-server*# 部分设置参数文件位置为 /lib/systemd/system/vncserver@.serviceyum install tigervnc-vncserver vnc# 添加端口，vnc默认从5901端口开始，用户1位5901，用户2位5902，以此类推firewall-cmd --zone=public --add-port=5901/tcp --permanent# 重新载入配置参数firewall-cmd --reload# 启动 vnc 服务器,首次启动会要求输入密码，同时会提示是否设置一个只可以查看，但无法操作的密码# 相关参数可以通过help指令获取vncserver -geometry 1440x900 # 注意，默认以当前用户创建远程服务# 关闭 vncservervncserver -kill :2 客户端连接，如windows 客户端下载地址 其中 VNC Server 可以填写 ip:port 也可以 ip:用户序号 如192.168.128.118:1 192.168.128.118:5901 192.168.128.118::5901(两个冒号也可以…) 2、ssh互信 修改配置文件 1234567sudo vim /etc/ssh/sshd_config#将以下内容前的#号去掉RSAAuthentication yesPubkeyAuthentication yes#重启ssh服务systemctl restart sshdAuthorizedKeysFile .ssh/authorized_keys 传输公钥并追加到认证文件中 123456# 将master的公钥复制到worker1中scp /root/.ssh/id_rsa.pub root@worker1:/root/.ssh/id_rsa.pub.master# 登陆到worker1后执行，将master公钥追加到认证文件后cat /root/.ssh/id_rsa.pub.master &gt;&gt;/root/.ssh/authorized_keys# 也可以使用ssh-copy-id来完成以上两步,第一次使用时，需要密码ssh-copy-id -i .ssh/id_rsa.pub root@worker1 3、MySQL安装12345678910111213141516171819202122232425262728293031#before installation,we need to uninstall mariadbrpm -qa | grep -i mariadb# the edition might be differentrpm -e --nodeps mariadb-libs-5.5.52-1.el7.x86_64#download the mysql wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar#mysql need the support by perlyum install perl -y# installationrpm -ivh mysql-community-common-5.7.23-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.23-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.23-1.el7.x86_64.rpmrpm install libaiorpm -ivh mysql-community-server-5.7.23-1.el7.x86_64.rpm#initsystemctl start mysqld.service# query the temporary passwordcat /var/log/mysqld.log |grep temporary# log in mysql -u root -p # change the passwordset password = passsord('ScuImage@502');# allow the remote access grant all privileges on *.* to 'root' @'%' identified by 'ScuImage@502';flush privileges;#开启3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanent #刷新防火墙firewall-cmd --reload #设置开机自启动chkconfig mysqld on 三、防火墙操作人懒，直接转载别人的 https://www.cnblogs.com/moxiaoan/p/5683743.html，侵删&gt; firewalld的基本使用 启动： systemctl start firewalld 关闭： systemctl stop firewalld 查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld 开机启用 ： systemctl enable firewalld systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。 启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl —failed 配置firewalld-cmd 查看版本： firewall-cmd —version 查看帮助： firewall-cmd —help 显示状态： firewall-cmd —state 查看所有打开的端口： firewall-cmd —zone=public —list-ports 更新防火墙规则： firewall-cmd —reload 查看区域信息: firewall-cmd —get-active-zones 查看指定接口所属区域： firewall-cmd —get-zone-of-interface=eth0 拒绝所有包：firewall-cmd —panic-on 取消拒绝状态： firewall-cmd —panic-off 查看是否拒绝： firewall-cmd —query-panic 端口配置 添加 firewall-cmd —zone=public —add-port=80/tcp —permanent （—permanent永久生效，没有此参数重启后失效） 重新载入 firewall-cmd —reload 查看 firewall-cmd —zone=public —query-port=80/tcp 删除 firewall-cmd —zone=public —remove-port=80/tcp —permanent 四、主题优化五、常用其他指令1、查看端口占用12# 查看端口 88 端口占用情况netstat -lnp | grep 88]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-web项目建立及配置]]></title>
    <url>%2F2018%2F01%2F22%2FMaven-web%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[环境配置eclipse自带Maven一般在eclipse中自带maven通过Windows-&gt;Preference-&gt;Maven-&gt;Installations可以查看其中EMBEDDED为自带的版本，截图如下 图1 使用指定版本官网下载链接 : http://maven.apache.org/download.cgi对于Linux系统： 123456789101112131415sudo mkdir /opt/maven# 解压maven到指定目录sudo tar zxvf apache-maven-×.×.×-bin.tar.gz -C /opt/maven# 配置maven环境sudo gedit /etc/profile# 在文件内容后追加如下内容export M2_HOME=/opt/maven/apache-maven-3.5.0export CLASSPATH=$CLASSPATH:$M2_HOME/libexport PATH=$PATH:$M2_HOME/bin# 保存后使配置文件生效source /etc/profile# 运行以下指令以验证是否安装成功mvn -v# 修改maven源为阿里云及仓库存放路径，以加快下载速度sudo gedit /opt/maven/apache-maven-3.5.0/conf/settings.xml 123456789&lt;!-- 添加或修改 标签在home目录下生成对应文件夹maven/repository --&gt;&lt;localRepository&gt;maven/repository&lt;/localRepository&gt;&lt;!-- # 添加或修改 标签 以修改源 --&gt;&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 对于 Windows系统：1、下载对应版本文件2、解压到指定路径 如：D:\Program Files\Apache\maven3、配置环境变量：123456MAVEN_HOME:D:\Program Files\Apache\maven# 追加到Path变量如下内容（注意前面分号问题）%MAVEN_HOME%\bin\# 新开cmd窗口并验证mvn -v# 配置D:\Program Files\Apache\maven\conf\settings.xml 同Ubuntu 通过点击图1 Add 按钮添加指定版本，配置安装路径即可：图2至此，环境配置完成 新建maven项目通过New-&gt;Project 并输入maven，到如下界面：图3路径设置，一般使用默认，也可自己选择图4可以使用默认的archetype，也可自行添加archetype（该操作当前不详述）图5Group Id：唯一就好，个人项目随意Artifact Id：差不多就项目名的意思图6点击finish后项目路径分布如下：图7右击项目选择 Build Path-&gt;Configure Build Path:图8点击 Add Library，添加Server Runtime，如有需要可修改Jre System Library图9点击刷新，红色叉号就消失了。右击，运行，则在浏览器金收入 Hello World！ 页面至此 maven项目建立完成（关于修改 maven项目名，webapp版本暂不详述） 下载jar包在 图7 中可以看到 pom.xml 通过修改该文件并保存，maven会自动下载或添加对应jar包其初始内容如下：123456789101112131415161718192021&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.liang.maven&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;MavenTest Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;MavenTest&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 百度输入，maven进入其依赖查询官网 : https://mvnrepository.com/ 搜索 如：mysql 并在结果中点击第一个链接：图10点击后会进入版本选择页面，一般我选择使用人数最多的版本，如5.1.6图11点击对应版本链接后，会进入如下页面：图12将图中如下内容复制粘贴到 pom.xml 中的 dependencies 标签内：123456&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 粘贴后，pom.xml 内容如下：12345678910111213141516171819202122232425262728&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.liang.maven&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;MavenTest Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;MavenTest&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 点击保存，并等待下载完成，下载进度在Progress中查看，下载完成后，可在项目中查看相应jar包：图13在此项目基础之上，可以轻松下载想要的jar包（如果要拷贝jar包给其他人的话） Maven切换阿里云镜像源修改 $MAVEN_HOME/conf/settings.xml在中添加至如下1234567891011121314151617181920 &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt;&lt;mirror&gt; &lt;id&gt;AliMaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; &lt;/mirrors&gt; 在eclipse中 Window—&gt;Preference—&gt;Maven—&gt;User Settings 将user setting或者Global Settings路径只想settings.xml,再点击apply即可。settings.xml可以复制到其他路径，只要eclipse设置和settings.xml路径一一对应即可 Maven报错1Failure to transferorg.apache.maven.plugins:maven-surefire-plugin:pom: 报类似错，找到目录 ~/.m2/repository/org/apache/maven/plugins将该目录下所有文件都删除，然后右击项目 Maven—&gt;Update Project 即可其中 ~ 表示用户目录]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
</search>
