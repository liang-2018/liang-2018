<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode note - part 3]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode-note-part-3%2F</url>
    <content type="text"><![CDATA[刷LeetCode笔记3 102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; return its level order traversal as: 123456&gt; [&gt; [3],&gt; [9,20],&gt; [15,7]&gt; ]&gt; 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; levelOrder(root,0); return result; &#125; public void levelOrder(TreeNode root, int level)&#123; if(root == null)return ; if(level &gt;= result.size())&#123; result.add(new ArrayList&lt;Integer&gt;()); &#125; List&lt;Integer&gt; list = result.get(level); list.add(root.val); levelOrder(root.left, level + 1); levelOrder(root.right, level + 1); &#125;&#125; 103. Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; return its zigzag level order traversal as: 123456&gt; [&gt; [3],&gt; [20,9],&gt; [15,7]&gt; ]&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 4ms 34.4MB/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; if(null == root)return result; Stack&lt;TreeNode&gt; stack1 = new Stack(); Stack&lt;TreeNode&gt; stack2 = new Stack(); stack2.push(root); boolean flag = false; while(!(stack1.isEmpty() &amp;&amp; stack2.isEmpty()))&#123; List&lt;Integer&gt; list = new ArrayList(); if(flag)&#123; flag = false; while(!stack1.isEmpty())&#123; TreeNode tree = stack1.pop(); list.add(tree.val); if(tree.right != null)&#123; stack2.push(tree.right); &#125; if(tree.left != null)&#123; stack2.push(tree.left); &#125; &#125; &#125;else&#123; flag = true; while(!stack2.isEmpty())&#123; TreeNode tree = stack2.pop(); list.add(tree.val); if(tree.left != null)&#123; stack1.push(tree.left); &#125; if(tree.right != null)&#123; stack1.push(tree.right); &#125; &#125; &#125; result.add(list); &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031// 2ms 34.8MB/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; zigzagLevelOrder(root, 0); return result; &#125; public void zigzagLevelOrder(TreeNode root, int level)&#123; if(null == root)return ; if(level &gt;= result.size())&#123; result.add(new LinkedList()); &#125; LinkedList&lt;Integer&gt; list = (LinkedList&lt;Integer&gt;)result.get(level); if(level % 2 == 0)&#123; list.addLast(root.val); &#125;else&#123; list.addFirst(root.val); &#125; zigzagLevelOrder(root.left, level + 1); zigzagLevelOrder(root.right, level + 1); &#125;&#125; 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; &gt; return its depth = 3. 123456789101112131415/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(null == root)return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125;&#125; 105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 123&gt; preorder = [3,9,20,15,7]&gt; inorder = [9,3,15,20,7]&gt; &gt; Return the following binary tree: 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); &#125; private TreeNode buildTree(int[] preorder, int ps, int pe, int[] inorder, int is, int ie) &#123; if(ps &gt; pe)return null; int val = preorder[ps]; TreeNode root = new TreeNode(val); int iroot = is; while(iroot &lt; ie &amp;&amp; val != inorder[iroot])&#123; iroot ++; &#125; root.left = buildTree(preorder, ps +1, ps + iroot -is, inorder, is, iroot -1); root.right = buildTree(preorder, ps + iroot - is + 1, pe, inorder, iroot +1, ie); return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse-J2EE项目设置]]></title>
    <url>%2F2019%2F04%2F13%2Feclipse-J2EE%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于eclipse建立Web项目后，一些文件夹作用及相关参数设置，做笔记以便后续查阅 当前主要使用两种方式建立Web项目: Maven Project 和 Dynamic Web Project 项目配置文件 Dynamic Web Project 如图，在建立项目后，文件夹内会生成途中的文件夹和相关参数文件，一般在使用Git和Svn同步项目的时候，只会同步src/和WebContent/两个文件夹，其他文件都不做同步。 .settings: 保存项目web的相关参数，如：Project Facets等 build：默认会将编译生成后的内容保存在build/文件夹 src: 存放源码的文件夹，有时候为了方便也会选择自己建立其他文件夹名，只要将其设置为Source Folder就可以了，一般默认会将source Folder的内容生成至classpath(/WEB-INF/classes)。 WebContent：存放除源码等文件外的所有文件，如前端页面、静态资源、部分配置文件等，这个文件夹从文件结构来说，相当于项目发布后的根目录(/)，很多资源文件，都是相对这个文件夹来确定位置。 关于项目根目录下eclipse配置文件的详细介绍 Maven Web Project 与Dynamic Web Project稍有不同的是： WebContent对应这里的Webapp build对应这里的target 同时所在的路径有所不同。不过最后发布后的路径和设置有关，故而实际上是一样的。 需要注意的是：这里的resources默认是source folder，也就是会发布到classpath路径下，一般用于存放配置文件。前端可能会在Webapp下新建resources文件夹，用于存放静态文件和这个是不同的（只是名字一样），注意别放错位置了。 Source Foler：存放源代码及配套的配置文件，默认将其文件夹中的内容发布在classpath下。在idea中也类似如此，只有标记为Source Folder的文件夹里面才可以新建包（本质上都是文件夹，但是显示时不一样） 同理，在配置spring相关配置文件，设计到文件资源路径的时候，主要通过根目录(Webapp/WebContent)和classpath以相对路径描述资源路径。]]></content>
      <categories>
        <category>tools</category>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode note - part 2]]></title>
    <url>%2F2019%2F04%2F09%2FLeetCode-note-part-2%2F</url>
    <content type="text"><![CDATA[刷LeetCode笔记2 54. Spiral Matrix第一次做的时候，会多加或者漏了最里面的行或者列 Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 12345678910&gt; Example 1:&gt; &gt; Input:&gt; [&gt; [ 1, 2, 3 ],&gt; [ 4, 5, 6 ],&gt; [ 7, 8, 9 ]&gt; ]&gt; Output: [1,2,3,6,9,8,7,4,5]&gt; 12345678910&gt; Example 2:&gt; &gt; Input:&gt; [&gt; [1, 2, 3, 4],&gt; [5, 6, 7, 8],&gt; [9,10,11,12]&gt; ]&gt; Output: [1,2,3,4,8,12,11,10,9,5,6,7]&gt; 1234567891011121314151617181920212223242526272829303132333435// my ac with great difficultyclass Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int m = matrix.length; if(m == 0) return list; int n = matrix[0].length; if(n == 0 )return list; int minLength = Math.min(m,n); for(int i = 0; i &lt;= (minLength - 1)/2; i++)&#123; //往右 for(int j = i; j &lt;= n - i -1; j++)&#123; list.add(matrix[i][j]); &#125; //往下 for(int j = i + 1; j &lt;= m - i -1;j++)&#123; list.add(matrix[j][n - i -1]); &#125; //往左 if(i != m -i -1)&#123; // 即当i == ( m-1 )/2,当行数为奇数行时，最后一次只有向右，没有向左 for(int j = n - i -2; j &gt;= i; j--)&#123; list.add(matrix[m -i -1][j]); &#125; &#125; //往上 if(i != n -i -1)&#123;// 即当i == ( n-1 )/2,当列数为奇数列时，最后一次只有向下，没有向上 for(int j = m - i -2; j &gt;= i + 1; j--)&#123; list.add(matrix[j][i]); &#125; &#125; &#125; return list; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list=new ArrayList(); if(matrix.length==0) return list; int startX=0; int startY=0; int endX=matrix[0].length-1; int endY=matrix.length-1; while(startX&lt;=endX&amp;&amp;startY&lt;=endY)&#123; //如果只有一列 if(startX==endX)&#123; for(int i=startY;i&lt;=endY;i++)&#123; list.add(matrix[i][endX]); &#125; return list; &#125; //如果只有一行 if(startY==endY)&#123; for(int i=startX;i&lt;=endX;i++)&#123; list.add(matrix[endY][i]); &#125; return list; &#125; //遍历StartX-&gt;endX for(int i=startX;i&lt;endX;i++)&#123; list.add(matrix[startY][i]); &#125; //遍历startY-&gt;endY for(int i=startY;i&lt;endY;i++)&#123; list.add(matrix[i][endX]); &#125; //遍历endX-&gt;startX for(int i=endX;i&gt;startX;i--)&#123; list.add(matrix[endY][i]); &#125; //遍历endY-&gt;startY for(int i=endY;i&gt;startY;i--)&#123; list.add(matrix[i][startX]); &#125; startX++; startY++; endX--; endY--; &#125; return list; &#125;&#125; 55. Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index. 123456&gt; Example 1:&gt; &gt; Input: [2,3,1,1,4]&gt; Output: true&gt; Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.&gt; 1234567&gt; Example 2:&gt; &gt; Input: [3,2,1,0,4]&gt; Output: false&gt; Explanation: You will always arrive at index 3 no matter what. Its maximum&gt; jump length is 0, which makes it impossible to reach the last index.&gt; 123456789101112131415161718192021222324// my acclass Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length &gt; 1 &amp;&amp; nums[0] == 0)return false; int[] jumped = new int[nums.length]; int curIndex = 0; while(curIndex &lt; nums.length)&#123; int curVal = nums[curIndex]; if(curIndex + curVal &gt;= nums.length -1)&#123; return true; &#125; jumped[curIndex] = 1; curIndex = curIndex + curVal; if(nums[curIndex] == 0)&#123; while(curIndex &gt;= 0 &amp;&amp; jumped[curIndex] == 1)&#123; curIndex --; &#125; &#125; if(curIndex &lt;0)return false; &#125; return true; &#125;&#125; 123456789101112131415// best ac o(n)算法/** * if jumping from index 0 to the end could achieve, * then jumping from the end to index 0 could also achieve. */class Solution &#123; public boolean canJump(int[] nums) &#123; int index = nums.length - 2,right = nums.length - 1; while(index &gt;= 0)&#123; if(index + nums[index] &gt;= right) right = index;//只有满足条件，才更新right 下标值 index--; &#125; return right == 0;//index可能小于0 &#125;&#125; 56. Merge Intervals Given a collection of intervals, merge all overlapping intervals.Attention : the order of list is not ensured123456&gt; Example 1:&gt;&gt; Input: [[1,3],[2,6],[8,10],[15,18]]&gt; Output: [[1,6],[8,10],[15,18]]&gt; Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].&gt; 123456&gt; Example 2:&gt;&gt; Input: [[1,4],[4,5]]&gt; Output: [[1,5]]&gt; Explanation: Intervals [1,4] and [4,5] are considered overlapping.&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041// my ac 17ms, 使用了自定义集合排序/*Definition for an interval.*/public class Interval &#123; int start; int end; Interval() &#123; start = 0; end = 0; &#125; Interval(int s, int e) &#123; start = s; end = e; &#125; &#125;class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; list = new ArrayList&lt;&gt;(); if(0 == intervals.size())return list; Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval o1, Interval o2)&#123; if(o1.start == o2.start)&#123; return o1.end - o2.end; &#125;else&#123; return o1.start -o2.start; &#125; &#125; &#125;); Interval first = intervals.get(0); list.add(new Interval(first.start, first.end)); for(int i = 1 ; i &lt; intervals.size(); i ++)&#123; Interval former = list.get(list.size()-1); Interval latter = intervals.get(i); if(former.end &gt;= latter.start)&#123; former.end = Math.max(former.end, latter.end); former.start = Math.min(former.start, latter.start); &#125;else &#123; list.add(new Interval(latter.start, latter.end)); &#125; &#125; return list; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// 10ms/** * 两层循环，在O(n*n)遍历过程中合并所有能合并的Interval */class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; list=new ArrayList&lt;Interval&gt;(); Interval L=new Interval();//一层循环保存对象 Interval R=new Interval();//二层循环保存对象 for(int i=0;i&lt;intervals.size();i++)&#123; L=intervals.get(i); int j=i+1; for(;j&lt;intervals.size();j++)&#123; R=intervals.get(j); if(R.start==L.start)&#123; intervals.set(j,new Interval(L.start,Math.max(L.end,R.end))); break; &#125;else if(L.start&lt;R.start)&#123; if(L.end&gt;=R.start)&#123; Interval inter=new Interval(L.start,Math.max(L.end,R.end)); intervals.set(j,inter); break; &#125; &#125;else&#123; if(R.end&gt;=L.start)&#123; Interval inter=new Interval(R.start,Math.max(L.end,R.end)); intervals.set(j,inter); break; &#125; &#125; &#125; if(j&gt;=intervals.size())&#123; list.add(intervals.get(i)); &#125; &#125; return list; &#125; &#125; 123456789101112131415161718192021222324252627// 11ms, 通过数域的性质，只用关心起始和终止点，直接进行拼接即可，较难想到class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; res=new ArrayList&lt;&gt;(); int len=intervals.size(); int[] start=new int[len]; int[] end=new int[len]; int i=0; for(Interval interval:intervals)&#123; start[i]=interval.start; end[i]=interval.end; i++; &#125; Arrays.sort(start); Arrays.sort(end); int j=0; for(i=0,j=0;i&lt;len;i++)&#123; if(i&lt;len-1 &amp;&amp; end[i]&lt;start[i+1])&#123; res.add(new Interval(start[j],end[i])); j=i+1; &#125;else if(i==len-1)&#123; res.add(new Interval(start[j],end[i])); &#125; &#125; return res; &#125;&#125; 59. Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3Output:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] matrix = new int[n][n]; int minLength = (n-1)/2; int value = 1; for(int i = 0; i &lt;= minLength; i++)&#123; //right--&gt; for(int j = i; j &lt;= n -i -1; j++)&#123; matrix[i][j] = value; value ++; &#125; //down for(int j = i + 1; j &lt;= n - i -1; j++)&#123; matrix[j][n -i -1] = value; value ++; &#125; if(i != n -i -1 )&#123;//注意，此处和 i != minLength 是两码事，原因在于int计算取证 // left &lt;-- for(int j = n - i -2; j &gt;= i; j--)&#123; matrix[n - i -1][j] = value; value ++; &#125; //up for(int j = n -i -2; j &gt; i; j--)&#123; matrix[j][i] = value; value ++; &#125; &#125; &#125; return matrix; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] matrix = new int[n][n]; int end = n - 1; int start = 0, i = 0, j = 0; int value = 1; while(start &lt;= end)&#123; //right while(j &lt;= end)&#123; matrix[i][j++] = value++; &#125; i++; j--;//每次进行完赋值后，对下标进行修正 //down while(i &lt;= end)&#123; matrix[i++][j] = value ++; &#125; i--; j--;//每次进行完赋值后，对下标进行修正 // left while(j &gt;= start)&#123; matrix[i][j--] = value ++; &#125; j++; i--;//每次进行完赋值后，对下标进行修正 // up while(i &gt; start)&#123; matrix[i--][j] = value ++; &#125; j++; i++;//每次进行完赋值后，对下标进行修正 start ++; end --; &#125; return matrix; &#125;&#125; Mark-60. Permutation Sequence康托展开Mark The set [1,2,3,...,*n*] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: 123&gt; Input: n = 3, k = 3&gt; Output: &quot;213&quot;&gt; &gt; Example 2: 123&gt; Input: n = 4, k = 9&gt; Output: &quot;2314&quot;&gt; 123456789101112131415161718192021222324// 需学习康拓展开class Solution &#123; public String getPermutation(int n, int k) &#123; int[] FAC=&#123;1,1,2,6,24,120,720,5040,40320,362880&#125;; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); StringBuilder sb=new StringBuilder(); for(int i=1;i&lt;=n;i++)&#123; list.add(i); &#125; k=k-1; while(n!=0)&#123; int a=k/FAC[n-1]; int r=k%FAC[n-1]; if(a&lt;list.size())&#123; sb.append(list.get(a)); list.remove(a); &#125; k=r;//余数当被除数 n--; &#125; return sb.toString(); &#125; &#125; 61. Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: 123456&gt; Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2&gt; Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; Explanation:&gt; rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL&gt; rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; &gt; Example 2: 12345678&gt; Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4&gt; Output: 2-&gt;0-&gt;1-&gt;NULL&gt; Explanation:&gt; rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL&gt; rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL&gt; rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL&gt; rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL&gt; 12345678910111213141516171819202122232425262728293031323334// My Ac/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if(null ==head)return head; if(head.next == null)return head; int listSize = 1; ListNode pointer = head; while(pointer.next != null)&#123; pointer = pointer.next; listSize++; &#125; k = k % listSize; for(int i = 0; i &lt; k ; i++)&#123; pointer = head; while(pointer.next.next != null)&#123; pointer = pointer.next; &#125; ListNode last = pointer.next; pointer.next = null; last.next = head; head = last; &#125; return head; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// best ac// 将链表先收尾相连成一个环，位移后，再重新拆环/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;public ListNode rotateRight(ListNode head, int k) &#123; if(head==null||k==0)&#123; return head; &#125; ListNode cursor=head; ListNode tail=null;//尾指针 int length=1; while(cursor.next!=null)//循环 得到总长度 &#123; cursor=cursor.next; length++; &#125; int loop=length-(k%length);//得到循环的次数 tail=cursor;//指向尾结点 cursor.next=head;//改成循环链表 cursor=head;//指向头结点 for(int i=0;i&lt;loop;i++)&#123;//开始循环 cursor=cursor.next; tail=tail.next; &#125; tail.next=null;//改成单链表 return cursor;//返回当前头 &#125;&#125; Mark-62. Unique PathsMark,结果溢出 A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: 12345678&gt; Input: m = 3, n = 2&gt; Output: 3&gt; Explanation:&gt; From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:&gt; 1. Right -&gt; Right -&gt; Down&gt; 2. Right -&gt; Down -&gt; Right&gt; 3. Down -&gt; Right -&gt; Right&gt; &gt; Example 2: 123&gt; Input: m = 7, n = 3&gt; Output: 28&gt; 12345678910111213// 不假思索就想到的方法多半是坑，因为阶乘数据太大，很容易计算结果溢出class Solution &#123; public int uniquePaths(int m, int n) &#123; return fac(m + n -2)/(fac(m-1)*fac(n-1)); &#125; public int fac(int n)&#123; if(n == 0 || n== 1)&#123; return 1; &#125;else&#123; return n * fac(n-1); &#125; &#125;&#125; 分析（1）： 由于机器人智能往右或者往下，所以到达(i,j)的方式只有两种：从（i-1,j）往右和从(i,j-1)往下；从而易得出到达（i,j）的路径总数为dp[i][j]=dp[i-1][j]+dp[i][j-1] 分析（2）： 由高中数学可知答案就是$C_{m+n-2}^{m-1}$或者$C_{m+n-2}^{n-1}$。其中 C_m^n=\frac{m!}{n!*(m-n)!}(1) 如果m或者n较小，结果容易得出，但是由于m，n最大可能100，使用阶乘计算的话溢出是必定的。 同时有性质：$C_{m+1}^{n+1}=C_m^n+C_m^{n+1}$(2)和$C_n^0+C_n^1+C_n^2+C_n^3+…+C_n^n=2^n$(3) 通过式（2），很容易想到这题使用动态规划计算。 假设使用数组dp存储结果，则有：dp[m][n]=$C_{m+n-2}^{n-1}=C_{m+n-3}^{n-2}+C_{m+n-3}^{n-1}$ 结合公式（2）得出：dp[m][n]=dp[m-1][n]+dp[m][n-1] 注意：dp[m-1][n-1]=$C_{m+n-4}^{n-2}$ 123456789101112131415class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i==0 || j==0)&#123; dp[i][j] = 1; &#125;else&#123; dp[i][j] = dp[i][j-1] + dp[i-1][j]; // dp[i][j]记录着i行j列时的路径数 &#125; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 63. Unique Paths II A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: 12345678910111213&gt; Input:&gt; [&gt; [0,0,0],&gt; [0,1,0],&gt; [0,0,0]&gt; ]&gt; Output: 2&gt; Explanation:&gt; There is one obstacle in the middle of the 3x3 grid above.&gt; There are two ways to reach the bottom-right corner:&gt; 1. Right -&gt; Right -&gt; Down -&gt; Down&gt; 2. Down -&gt; Down -&gt; Right -&gt; Right&gt; 分析：与之前不同，需要判断是否有障碍，有障碍则无法到达该点，即到达该点的路径数为0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; if(obstacleGrid[0][0] ==1)return 0; if(m==1 || n==1)&#123;//这里不额外判断也可以 for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(obstacleGrid[i][j] == 1)&#123; return 0; &#125; &#125; &#125; return 1; &#125; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0 ; j &lt; n; j++)&#123; if(i == 0 &amp;&amp; j &gt; 0)&#123; if(obstacleGrid[i][j] ==0)&#123;//Java创建二维数组的代价非常大，能用现成的尽可能别新建 obstacleGrid[i][j] = obstacleGrid[i][j-1]; &#125;else&#123; obstacleGrid[i][j] = 0; &#125; &#125;else if(i &gt; 0 &amp;&amp; j ==0)&#123; if(obstacleGrid[i][j] ==0)&#123; obstacleGrid[i][j] = obstacleGrid[i-1][j]; &#125;else&#123; obstacleGrid[i][j] = 0; &#125; &#125;else if(i ==0 &amp;&amp; j==0)&#123; obstacleGrid[i][j] = 1; &#125;else&#123; if(obstacleGrid[i][j] ==0)&#123; obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]; &#125;else&#123; obstacleGrid[i][j] = 0; &#125; &#125; &#125; &#125; return obstacleGrid[m-1][n-1]; &#125;&#125; 64. Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: 123456789&gt; Input:&gt; [&gt; [1,3,1],&gt; [1,5,1],&gt; [4,2,1]&gt; ]&gt; Output: 7&gt; Explanation: Because the path 1→3→1→1→1 minimizes the sum.&gt; 分析：这道题，和前面两道题，换汤不换药，一样做。也可以使用递归形式熟悉额，道理都一样 123456789101112131415161718192021// 循环方式class Solution &#123; public int minPathSum(int[][] grid) &#123; //利用dp记录到达某个点的最短长度，因为题目要求只会往右或者往下，不会往回走，只是单向遍历，可以使用动态规划 int row = grid.length; int col = grid[0].length; for(int i = 1; i &lt; row; i++)&#123; grid[i][0] += grid[i-1][0]; &#125; for(int i = 1; i &lt; col; i++)&#123; grid[0][i] += grid[0][i-1]; &#125; for(int i = 1; i &lt; row; i++)&#123; for(int j = 1; j &lt; col; j++)&#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125; &#125; return grid[row-1][col-1]; &#125;&#125; 12345678910111213141516171819202122232425// 递归方式class Solution &#123; private int[][] dp; private int core(int[][] m,int row,int col)&#123; if (row == m.length - 1 &amp;&amp; col == m[0].length - 1) return m[row][col]; if (dp[row][col] != 0) return dp[row][col]; int result = m[row][col]; if (row == m.length - 1)&#123; // 只能右走 result += core(m,row,col + 1); &#125;else if (col == m[0].length - 1)&#123; // 只能向下走 result += core(m,row + 1,col); &#125;else&#123; result += Math.min(core(m,row,col + 1) , core(m,row + 1,col)); &#125; dp[row][col] = result; return result; &#125; public int minPathSum(int[][] grid) &#123; dp = new int[grid.length][grid[0].length]; return core(grid,0,0); &#125;&#125; 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shorteststring representing the absolute path. Example 1: 1234&gt; Input: &quot;/home/&quot;&gt; Output: &quot;/home&quot;&gt; Explanation: Note that there is no trailing slash after the last directory name.&gt; &gt; Example 2: 1234&gt; Input: &quot;/../&quot;&gt; Output: &quot;/&quot;&gt; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.&gt; &gt; Example 3: 1234&gt; Input: &quot;/home//foo/&quot;&gt; Output: &quot;/home/foo&quot;&gt; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.&gt; &gt; Example 4: 123&gt; Input: &quot;/a/./b/../../c/&quot;&gt; Output: &quot;/c&quot;&gt; &gt; Example 5: 123&gt; Input: &quot;/a/../../b/../c//.//&quot;&gt; Output: &quot;/c&quot;&gt; &gt; Example 6: 123&gt; Input: &quot;/a//b////c/d//././/..&quot;&gt; Output: &quot;/a/b/c&quot;&gt; 一开始想到的比较笨的方式，将字符串转换为数组进行判断 每个位置有三个可能：/ . 字母 / + 字母 ： 追加 / + / : 跳过 . + / : 跳过 . + . : 通过lastIndexOf(“/“)定位剔除最后一段 但是死于输入 “/…”，喵的， “…”在linux还真能建立，但是用ll都查看不到，但是确实能通过 cd … 进入该文件夹 所以，换种方式： 通过 split将字符串分割，只需判断是否为空，是否为“.”和”..”三种情况，其他的追加上去就好。 1234567891011121314151617181920212223242526class Solution &#123; public String simplifyPath(String path) &#123; String[] StrArr = path.split("/"); StringBuilder sb = new StringBuilder(); for(String str :StrArr)&#123; if("".equals(str))continue; if(".".equals(str))&#123; continue; &#125;else if("..".equals(str))&#123; int lindex = sb.lastIndexOf("/"); if(lindex == -1)&#123; continue; &#125; String tmp = sb.toString().substring(0, lindex); sb = new StringBuilder(tmp); &#125;else&#123; sb.append("/" + str); &#125; &#125; if(sb.length()==0)&#123; sb.append("/"); &#125; return sb.toString(); &#125;&#125; 1234567891011121314151617181920// 最短用时 2msclass Solution &#123; public String simplifyPath(String path) &#123; int i = path.length() - 1, count = 0; StringBuilder builder = new StringBuilder(i); while (i &gt; 0) &#123; int j = path.lastIndexOf('/', i);// 从i开始向前搜索 "/" if (i == j) i--; //说明 i 处 正好是 "/" else &#123; String x = path.substring(j + 1, i + 1); i = j - 1; if (".".equals(x)) ; else if ("..".equals(x)) count++; else if (count &gt; 0) count--; else builder.insert(0, "/" + x); &#125; &#125; return builder.length() == 0 ? "/" : builder.toString(); &#125;&#125; 73. Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: 12345678910111213&gt; Input: &gt; [&gt; [1,1,1],&gt; [1,0,1],&gt; [1,1,1]&gt; ]&gt; Output: &gt; [&gt; [1,0,1],&gt; [0,0,0],&gt; [1,0,1]&gt; ]&gt; &gt; Example 2: 12345678910111213&gt; Input: &gt; [&gt; [0,1,2,0],&gt; [3,4,5,2],&gt; [1,3,1,5]&gt; ]&gt; Output: &gt; [&gt; [0,0,0,0],&gt; [0,4,5,0],&gt; [0,3,1,0]&gt; ]&gt; &gt; Follow up: A straight forward solution using O(m**n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 12345678910111213141516171819202122232425262728293031323334353637383940// O(m+n) space 2msclass Solution &#123; public void setZeroes(int[][] matrix) &#123; int row = matrix.length; int col = matrix[0].length; int[] rowZero = new int[row]; int[] colZero = new int[col]; for(int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if(matrix[i][j] == 0)&#123; rowZero[i] = 1; colZero[j] = 1; &#125; &#125; &#125; for(int i = 0; i &lt; row; i++)&#123; if(rowZero[i] == 1)&#123; setRowZero(matrix, i); &#125; &#125; for(int j = 0; j &lt; col; j++)&#123; if(colZero[j] == 1)&#123; setColZero(matrix, j); &#125; &#125; &#125; public void setRowZero(int[][] matrix, int row)&#123; int col = matrix[0].length; for(int i = 0; i &lt; col; i++)&#123; matrix[row][i] = 0; &#125; &#125; public void setColZero(int[][] matrix, int col)&#123; int row = matrix.length; for(int i = 0; i &lt; row; i++)&#123; matrix[i][col] = 0; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 少于 O(m+n)额外空间的，将首行和首列用来存储对应行列是否存在0class Solution &#123; public void setZeroes(int[][] matrix) &#123; //如果首行或首列有元素为0，在最后将行或列置为0 boolean rowFlag = false; //判断首行 for (int i = 0; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; rowFlag=true; break; &#125; &#125; //判断首列 boolean colFlag = false; for (int i = 0; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; matrix[0][0]=0; break; &#125; &#125; //把对应的首行首列置为0，从[1][1]开始遍历 for (int i = 1; i &lt; matrix.length; i++) &#123; for (int j = 1; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; //行置0 for (int i = 1; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; matrix[j][i] = 0; &#125; &#125; &#125; //列置0 for (int i = 1; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[i][j] = 0; &#125; &#125; &#125; //如果首列中有0，将首列置为0 if (matrix[0][0]==0)&#123; for (int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; //如果首行有0，将首行置为0 if (rowFlag)&#123; for (int i = 0; i &lt; matrix[0].length; i++) &#123; matrix[0][i] = 0; &#125; &#125; &#125; &#125; 74. Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: 123456789&gt; Input:&gt; matrix = [&gt; [1, 3, 5, 7],&gt; [10, 11, 16, 20],&gt; [23, 30, 34, 50]&gt; ]&gt; target = 3&gt; Output: true&gt; &gt; Example 2: 123456789&gt; Input:&gt; matrix = [&gt; [1, 3, 5, 7],&gt; [10, 11, 16, 20],&gt; [23, 30, 34, 50]&gt; ]&gt; target = 13&gt; Output: false&gt; 1234567891011121314151617181920212223242526272829303132333435// 日常判断 传入的值可能为 null 或者 长度为0class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(null == matrix)return false; int row = matrix.length; if(0 == row)return false; int col = matrix[0].length; if(0 == col)return false; for(int i = 0; i &lt; row; i++)&#123; if (matrix[i][col-1] == target || matrix[i][0] == target) &#123; return true; &#125; else if(matrix[i][col-1] &gt; target)&#123; return rowFind(matrix[i], target); &#125; &#125; return false; &#125;// 行查找使用二分查找，对于更长的矩阵，具有更高的效率 public boolean rowFind(int[] row, int target)&#123; int left = 0; int right = row.length - 1; int mid = -1; while (left &lt;= right) &#123; mid = (right + left) / 2; if (row[mid] == target) &#123; return true; &#125; else if (row[mid] &gt; target) &#123; right = mid - 1; &#125; else if (row[mid] &lt; target) &#123; left = mid + 1; &#125; &#125; return false; &#125;&#125; 75. Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? 1234567891011121314151617181920212223242526// 遍历，把红的往前放，蓝的往后放，每次交换两处索引的值就可以了。class Solution &#123; public void sortColors(int[] nums) &#123; //遍历，把红的往前放，把蓝的往后放 int left = 0; int right = nums.length -1; int index = 0; while(left &lt; right &amp;&amp; index &lt;=right)&#123; if(left &lt; index &amp;&amp; nums[index] == 0)&#123; swap(nums, left, index); left ++; &#125;else if(nums[index] == 2)&#123; swap(nums, right, index); right --; &#125;else&#123; index ++; &#125; &#125; &#125; public void swap(int[] nums, int index1, int index2)&#123; int tmp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = tmp; &#125;&#125; 77. CombinationsGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. Example: 12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 12345678910111213141516171819202122// 最先想到的办法，回溯class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; combine(n, k, new ArrayList&lt;Integer&gt;()); return list; &#125; public void combine(int n, int k, List&lt;Integer&gt; combine)&#123; if(k == 0)&#123; list.add(new ArrayList(combine)); return; &#125; if(n &lt; 1)return; for(int i = n; i &gt; 0 &amp;&amp; i &gt;= k; i--)&#123; // 注意，添加 i &gt;= k 可以节约很多时间，避免大量无用功，差不多是5ms和57ms的区别 combine.add(i); combine(i-1, k-1, combine); combine.remove((Object)i); // 或 combine.remove(combine.size()-1); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 原理差不多，一个从大到小组合，一个从小到大组合class Solution &#123; private int max; private int num; private List&lt;List&lt;Integer&gt;&gt; res; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; max = n; num = k; res = new ArrayList&lt;&gt;(); if (k == 0) &#123; return res; &#125; getCombine(1, new ArrayList&lt;&gt;()); return res; &#125; private void getCombine(int index, List&lt;Integer&gt; form) &#123; if (form.size() == num) &#123; res.add(new ArrayList&lt;&gt;(form)); return; &#125; // 剪枝，[i, n]区间至少需要有k - form.size()个元素，否则跳过 int range = max - num + form.size() + 1; for (int i = index; i &lt;= range; i++) &#123; form.add(i); getCombine(i + 1, form); form.remove(form.size() - 1); &#125; &#125;&#125; 78. Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910111213&gt; Input: nums = [1,2,3]&gt; Output:&gt; [&gt; [3],&gt; [1],&gt; [2],&gt; [1,2,3],&gt; [1,3],&gt; [2,3],&gt; [1,2],&gt; []&gt; ]&gt; 12345678910111213141516171819class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = null; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; res = new ArrayList&lt;&gt;(); ArrayList &lt;Integer&gt; temp = new ArrayList&lt;&gt;(); sub(nums,temp, 0); return res; &#125; public void sub(int[] nums, List temp, int index) &#123; if(index == nums.length) &#123; res.add(new ArrayList(temp)); return; &#125; temp.add(nums[index]); sub(nums, temp, index + 1); temp.remove(temp.size() - 1); sub(nums, temp, index + 1); &#125;&#125; 123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); result.add(new ArrayList&lt;Integer&gt;()); for(int n:nums)&#123; int size = result.size(); for(int i=0;i&lt;size;i++)&#123; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(result.get(i)); temp.add(n); result.add(temp); &#125; &#125; return result; &#125;&#125; 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: 1234567891011&gt; board =&gt; [&gt; [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],&gt; [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],&gt; [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]&gt; ]&gt; &gt; Given word = &quot;ABCCED&quot;, return true.&gt; Given word = &quot;SEE&quot;, return true.&gt; Given word = &quot;ABCB&quot;, return false.&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 10 ms 38.7MBclass Solution &#123; private char[][] board = null; private int[][] mark = null; private String word = null; public boolean exist(char[][] board, String word) &#123; // 通过遍历定位首字母位置，然后再逐步递归调用比较旁边位置， 将起始坐标都保存 // 同时还需要标记 相应位置 是否已经使用过（由于可能多个方向可能相同，需要使用到回溯） this.board = board; this.word = word; int row = board.length; int col = board[0].length; mark = new int[row][col]; List&lt;int[]&gt; starts = find(word.charAt(0)); for(int[] point : starts)&#123; mark[point[0]][point[1]] = 1; if(exist(point[0], point[1], 0))&#123; return true; &#125; mark[point[0]][point[1]] = 0; &#125; return false; &#125; private boolean exist(int curRow, int curCol, int curIndex)&#123; if(word.charAt(curIndex) == board[curRow][curCol] &amp;&amp; curIndex == word.length() -1)&#123; return true; &#125; if( word.charAt(curIndex) == board[curRow][curCol])&#123; //判断四个方向是否可行 // 上 if(curRow - 1 &gt;= 0 &amp;&amp; mark[curRow-1][curCol] ==0)&#123; mark[curRow -1][curCol] = 1; boolean exist = exist(curRow -1, curCol, curIndex + 1); mark[curRow -1][curCol] = 0; if(exist)return exist; &#125; // 下 if(curRow + 1 &lt; board.length &amp;&amp; mark[curRow+1][curCol] ==0)&#123; mark[curRow + 1][curCol] = 1; boolean exist = exist(curRow + 1, curCol, curIndex + 1); mark[curRow + 1][curCol] = 0; if(exist)return exist; &#125; // 左 if(curCol -1 &gt;= 0 &amp;&amp; mark[curRow][curCol -1] == 0)&#123; mark[curRow][curCol - 1] = 1; boolean exist = exist(curRow, curCol -1, curIndex + 1); mark[curRow][curCol - 1] = 0; if(exist)return exist; &#125; // 右 if(curCol + 1 &lt; board[0].length &amp;&amp; mark[curRow][curCol + 1] == 0)&#123; mark[curRow][curCol + 1] = 1; boolean exist = exist(curRow, curCol + 1, curIndex + 1); mark[curRow][curCol + 1] = 0; if(exist)return exist; &#125; &#125;else&#123; return false; &#125; return false; &#125; // 查找首字母的位置 private List&lt;int[]&gt; find(char head)&#123; List&lt;int[]&gt; list = new ArrayList(); for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == head)&#123; list.add(new int[]&#123;i, j&#125;); &#125; &#125; &#125; return list; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 将上面的逻辑统一简化处理 14ms 43.9MBclass Solution &#123; private char[][] board = null; private int[][] mark = null; private String word = null; public boolean exist(char[][] board, String word) &#123; // 通过遍历定位首字母位置，然后再逐步递归调用比较旁边位置， 将起始坐标都保存 // 同时还需要标记 相应位置 是否已经使用过（由于可能多个方向可能相同，需要使用到回溯） this.board = board; this.word = word; int row = board.length; int col = board[0].length; mark = new int[row][col]; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == word.charAt(0))&#123; if(exist(i, j, 0))return true; &#125; &#125; &#125; return false; &#125; private boolean exist(int curRow, int curCol, int curIndex)&#123; if( curIndex == word.length())&#123; return true; &#125; if(curRow &lt; 0 || curRow == board.length || curCol &lt; 0 || curCol == board[0].length || mark[curRow][curCol] == 1)&#123; return false; &#125; if( word.charAt(curIndex) == board[curRow][curCol])&#123; //判断四个方向是否可行 mark[curRow][curCol] = 1; if(exist(curRow - 1, curCol, curIndex + 1) || exist(curRow + 1, curCol, curIndex + 1) || exist(curRow, curCol -1, curIndex + 1) || exist(curRow, curCol + 1, curIndex + 1))&#123; return true; &#125; mark[curRow][curCol] = 0; &#125; return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// 由于是比较值是相同，所以可以通过临时改变值使不相同来做标记，节省内存 8ms 39.6MBclass Solution &#123; private char[][] board = null; private String word = null; public boolean exist(char[][] board, String word) &#123; // 通过遍历定位首字母位置，然后再逐步递归调用比较旁边位置 // 同时还需要标记 相应位置 是否已经使用过（由于可能多个方向可能相同，需要使用到回溯） this.board = board; this.word = word; int row = board.length; int col = board[0].length; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == word.charAt(0))&#123; if(exist(i, j, 0))return true; &#125; &#125; &#125; return false; &#125; private boolean exist(int curRow, int curCol, int curIndex)&#123; if( curIndex == word.length())&#123; return true; &#125; if(curRow &lt; 0 || curRow == board.length || curCol &lt; 0 || curCol == board[0].length)&#123; return false; &#125; if( word.charAt(curIndex) == board[curRow][curCol])&#123; //判断四个方向是否可行 board[curRow][curCol] ^= 256; // 使用位运算，加快计算速度，同时计算后不是字母，相当于标记了已遍历 if(exist(curRow - 1, curCol, curIndex + 1) || exist(curRow + 1, curCol, curIndex + 1) || exist(curRow, curCol -1, curIndex + 1) || exist(curRow, curCol + 1, curIndex + 1))&#123; return true; &#125; board[curRow][curCol] ^= 256; // 二次异或，回复原值 &#125; return false; &#125;&#125; 80. Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 123456&gt; Given nums = [1,1,1,2,2,3],&gt; &gt; Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.&gt; &gt; It doesn&apos;t matter what you leave beyond the returned length.&gt; &gt; Example 2: 123456&gt; Given nums = [0,0,1,1,1,1,2,3,3],&gt; &gt; Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.&gt; &gt; It doesn&apos;t matter what values are set beyond the returned length.&gt; &gt; Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 123456789&gt; // nums is passed in by reference. (i.e., without making a copy)&gt; int len = removeDuplicates(nums);&gt; &gt; // any modification to nums in your function would be known by the caller.&gt; // using the length returned by your function, it prints the first len elements.&gt; for (int i = 0; i &lt; len; i++) &#123;&gt; print(nums[i]);&gt; &#125;&gt; 1234567891011121314151617181920212223242526272829// 理解容易，写起来绕class Solution &#123; public int removeDuplicates(int[] nums) &#123; if( 0 == nums.length)return 0; int newLength = 0; int count = 0; int preVal = nums[0]; for(int i = 1; i &lt; nums.length; i++)&#123; if(preVal == nums[i]) &#123; count ++; &#125;else&#123; count = 0; &#125; preVal = nums[i]; if(count &lt; 2)&#123;//在这里控制重复的个数是多少 newLength++;; &#125; if(i &gt; newLength)&#123;//如果没有超过3个的重复数，则没必要交换 swap(nums, i, newLength); &#125; &#125; return newLength + 1;//长度是最后索引+1 &#125; private void swap(int[] nums, int index1, int index2)&#123; int tmp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = tmp; &#125;&#125; 12345678910111213141516class Solution &#123; public int removeDuplicates(int[] nums) &#123; int flag = 0; if (nums == null || nums.length &lt;= 0)&#123; return flag; &#125; for (int i = 0;i &lt; nums.length;i++)&#123; if (flag &lt; 2 || nums[i] &gt; nums[flag - 2])&#123; //flag 指向有效值赋值后一位置，（即newLength）,因而flag-2指向上一个值 // 可以通过修改 flag 减少 num 来控制多少个重复 nums[flag++] = nums[i]; &#125; &#125; return flag; &#125;&#125; Mark-81. Search in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: 123&gt; Input: nums = [2,5,6,0,0,1,2], target = 0&gt; Output: true&gt; &gt; Example 2: 123&gt; Input: nums = [2,5,6,0,0,1,2], target = 3&gt; Output: false&gt; &gt; Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean search(int[] nums, int target) &#123; if(nums.length == 0)return false; return find(nums, 0, nums.length - 1, target); &#125; public boolean find(int[] nums, int left, int right, int target)&#123; if(left &gt; right)return false; if(nums[left] == target || nums[right] == target)&#123; return true; &#125; if(left == right )return false; int mid = left + (right - left) / 2; if(nums[mid] == target)return true; if(nums[left] &lt; nums[mid])&#123; if(nums[left] &lt;=target &amp;&amp; target &lt;= nums[mid])&#123; return find(nums, left, mid -1, target); &#125;else&#123; return find(nums, mid+1, right, target); &#125; &#125;else if(nums[right] &gt; nums[mid])&#123; if(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right])&#123; return find(nums, mid +1, right, target); &#125;else&#123; return find(nums, left, mid -1, target); &#125; &#125;else&#123; if(nums[mid] == nums[left])&#123; return find(nums, left +1, right, target); &#125;else&#123; return find(nums, left, right -1, target); &#125; &#125; &#125;&#125; 123456789101112131415161718192021class Solution &#123; public boolean search(int[] nums, int target) &#123; int l = 0, r = nums.length-1; while(l&lt;=r)&#123; //处理重复数字 while(l&lt;r&amp;&amp;nums[l]==nums[l+1]) ++l; while(l&lt;r&amp;&amp;nums[r]==nums[r-1]) --r; int mid = l+(r-l)/2; if(nums[mid]==target) return true; //左半部分有序 if(nums[mid]&gt;=nums[l])&#123; if(target&lt;nums[mid]&amp;&amp;target&gt;=nums[l]) r = mid-1;//target落在左半边 else l = mid+1; &#125;else&#123;//右半部分有序 if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[r]) l = mid+1;//target落在右半边 else r = mid-1; &#125; &#125; return false; &#125;&#125; Mark-82. Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinctnumbers from the original list. Example 1: 123&gt; Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5&gt; Output: 1-&gt;2-&gt;5&gt; &gt; Example 2: 123&gt; Input: 1-&gt;1-&gt;1-&gt;2-&gt;3&gt; Output: 2-&gt;3&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 先虚拟一个前节点，用于获取指针class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(null == head || null == head.next)return head; ListNode dHead = new ListNode(0); dHead.next = head; ListNode pointer = head; ListNode prePoint = dHead; while(pointer!= null &amp;&amp; pointer.next != null)&#123; if(pointer.val == pointer.next.val)&#123; while(null != pointer.next &amp;&amp; pointer.val == pointer.next.val)&#123; pointer.next = pointer.next.next; &#125; prePoint.next = pointer.next; pointer = pointer.next; &#125;else&#123; prePoint = prePoint.next; pointer = pointer.next; &#125; &#125; return dHead.next; &#125;&#125;// 递归调用class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(null == head || null == head.next)return head; if(head.val == head.next.val)&#123; while(null != head.next &amp;&amp; head.val == head.next.val)&#123; head.next = head.next.next; &#125; head = head.next; return deleteDuplicates(head); &#125;else&#123; head.next = deleteDuplicates(head.next); return head; &#125; &#125;&#125;class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode prev = null; ListNode cur = head; while( null != cur)&#123; if(cur.next != null &amp;&amp; cur.val == cur.next.val)&#123; while(null != cur.next &amp;&amp; cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125; cur = cur.next; if(prev == null)&#123; head = cur; &#125;else&#123; prev.next = cur;// 修改节点的next，否则还是指向重复的 &#125; &#125;else&#123; prev = cur; cur = cur.next; &#125; &#125; return head; &#125;&#125; 86. Partition ListMark Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 123&gt; Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3&gt; Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5&gt; 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode partition(ListNode head, int x) &#123; // 建立两个虚拟头部来链接值 ListNode less_head = new ListNode(0);//用来链接比x更小的值 ListNode more_head = new ListNode(0);//用来链接比x更大或相等的值 ListNode less_cur = less_head;// 插入点 ListNode more_cur = more_head;//插入点 while(head != null)&#123; if(head.val &lt; x)&#123; less_cur.next = head; less_cur = less_cur.next; &#125; else&#123; more_cur.next = head; more_cur = more_cur.next; &#125; head = head.next; &#125; less_cur.next = more_head.next; more_cur.next = null; return less_head.next; &#125;&#125; 89. Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: 12345678910111213141516&gt; Input: 2&gt; Output: [0,1,3,2]&gt; Explanation:&gt; 00 - 0&gt; 01 - 1&gt; 11 - 3&gt; 10 - 2&gt; &gt; For a given n, a gray code sequence may not be uniquely defined.&gt; For example, [0,2,3,1] is also a valid gray code sequence.&gt; &gt; 00 - 0&gt; 10 - 2&gt; 11 - 3&gt; 01 - 1&gt; &gt; Example 2: 123456&gt; Input: 0&gt; Output: [0]&gt; Explanation: We define the gray code sequence to begin with 0.&gt; A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.&gt; Therefore, for n = 0 the gray code sequence is [0].&gt; 这道题如果了解格雷码构成的原理就很简单了 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; grayCode(int n) &#123; if(n == 0)&#123; List&lt;Integer&gt; list = new ArrayList(); list.add(0); return list; &#125; List&lt;Integer&gt; list = new ArrayList(); List preList = grayCode(n - 1); for(Object val : preList)&#123; list.add((int)val); &#125; int addVal = 1 &lt;&lt;(n-1); for(int i = preList.size() - 1; i&gt;=0; i--)&#123; list.add((int)preList.get(i) + addVal); &#125; return list; &#125;&#125; 90. Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 1234567891011&gt; Input: [1,2,2]&gt; Output:&gt; [&gt; [2],&gt; [1],&gt; [1,2,2],&gt; [2,2],&gt; [1,2],&gt; []&gt; ]&gt; 123456789101112131415161718192021222324252627282930class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; result.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(nums); for(int i = 1; i &lt;= nums.length; i ++)&#123; genSub(nums, 0, i, new ArrayList(i)); &#125; return result; &#125; private void genSub(int[] nums, int sIndex, int len, List&lt;Integer&gt; sub)&#123; if(len == sub.size())&#123; result.add(new ArrayList(sub)); return; &#125; for(int i = sIndex; i + len - sub.size() &lt;= nums.length; i++)&#123; // 判断条件很重要 i + len - sub.size() &lt;= nums.length sub.add(nums[i]); genSub(nums, i + 1, len , sub); sub.remove(sub.size() -1); while(i &lt; nums.length -1 &amp;&amp; nums[i] == nums[i+1])&#123; i++ ; &#125; &#125; &#125;&#125; 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); Arrays.sort(nums); helper(nums,res,tmp,0); return res; &#125; public void helper(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, int start)&#123; res.add(new ArrayList&lt;Integer&gt;(tmp)); for (int i = start; i &lt; nums.length; i++)&#123; if (i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; tmp.add(nums[i]); helper(nums,res,tmp,i+1); tmp.remove(tmp.size()-1); &#125; &#125;&#125; 91. Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 12345&gt; &apos;A&apos; -&gt; 1&gt; &apos;B&apos; -&gt; 2&gt; ...&gt; &apos;Z&apos; -&gt; 26&gt; &gt; Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: 1234&gt; Input: &quot;12&quot;&gt; Output: 2&gt; Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).&gt; &gt; Example 2: 1234&gt; Input: &quot;226&quot;&gt; Output: 3&gt; Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).&gt; 组合相关基本使用 动态规划、回溯、分治等 123456789101112131415161718192021222324class Solution &#123; public int numDecodings(String s) &#123; char[] ss=s.toCharArray(); int n=ss.length; if(n==0) &#123;//没有数字的情况 return 0; &#125; int[] dp=new int[n+1];//dp[i]表示前i个数字的组合数 dp[0]=1;//为了后面的好计算 for(int i=1;i&lt;=n;i++) &#123; int t=ss[i-1]-'0'; if(t&gt;=1&amp;&amp;t&lt;=9) &#123;//最后一个数字 dp[i]+=dp[i-1]; &#125; if(i&gt;=2) &#123;//最后两个组合成数字 t=(ss[i-2]-'0')*10+(ss[i-1]-'0'); if(t&gt;=10&amp;&amp;t&lt;=26) &#123; dp[i]+=dp[i-2]; &#125; &#125; &#125; return dp[n]; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536class Solution: # 原型还是斐波那契的思路，第i的个数由i-1和i-2的个数决定 def numDecodings(self, s: str) -&gt; int: # '0'开头的全部违规 if s[0] == '0': return 0 # '0'结尾的，前一位比2大也全部违规，受测试用例'230'的启发 # 其实下面的循环也实现了，但就是想早点剔除违规的哈哈哈 if s[-1] == '0' and s[-2] &gt; '2': return 0 # 这有点斐波那契的意思，因为第i位在不违规的情况下， # 要么自己成一位，要么和前一位组成两位的字母，所以可就是f(i) = f(i-1) + f(i-2) a = 1 # 第i-1位的组合个数 b = 1 # 第i-2位的组合个数 for i in range(1, len(s)): # 连续两个0肯定违规 if s[i-1] == '0' and s[i] == '0': return 0 # 小于26就有可能i和i+1配对变斐波那契 elif s[i-1]+s[i] &lt;= '26': # i为0，就只能f(i) = f(i-2),和前一个合体，不能自己单独 if s[i] == '0': a, b = b, a # 如果前一个为0，而自己为不为0，f(i) = f(i-1) elif s[i-1] == '0': a = b # 一切正常，f(i) = f(i-1) + f(i-2) else: a, b = b, a+b # 删除任何30，40，50这种出现在尾部，中部的违规组合 elif s[i] == '0': return 0 else: a = b return b 92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 123&gt; Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4&gt; Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(m == n || head == null || head.next == null)return head; ListNode prev = null; ListNode cur = head; ListNode part1Start = head; ListNode part1End = null, part2Start = null, part2End = null, part3Start = null; for(int i = 1; cur != null; i++)&#123; if(i == m )&#123; part1End = prev; part2End = cur; &#125; if(i == n)&#123; part2Start = cur; part3Start = cur.next; &#125; if( i &gt;= m &amp;&amp; i &lt;= n)&#123; ListNode next = cur.next; cur.next = prev; prev = cur; cur = next; &#125;else&#123; prev = cur; cur = cur.next; &#125; &#125; if(m == 1)&#123; head = part2Start; part2End.next = part3Start; &#125;else&#123; part1End.next = part2Start; part2End.next = part3Start; &#125; return head; &#125;&#125; 93. Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 123&gt; Input: &quot;25525511135&quot;&gt; Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 4ms 37.4MBclass Solution &#123; private List&lt;String&gt; result = new ArrayList(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; restore(s, "", 4); return result; &#125; private void restore(String s, String sb, int len)&#123; if(len == 0 &amp;&amp; s.length() == 0)&#123; result.add(sb.substring(0, sb.length() -1)); return; &#125; if(s.length() &gt; len * 3 || len == 0 || s.length() &lt; 1)&#123; return; &#125; restore(s.substring(1), sb + s.substring(0,1) +".", len -1); if(s.length() &gt;= 2 )&#123; int val = Integer.parseInt(s.substring(0, 2)); if(val &gt; 9)&#123; restore(s.substring(2), sb + s.substring(0,2) +".", len -1); &#125; &#125; if(s.length() &gt;= 3)&#123; int val = Integer.parseInt(s.substring(0, 3)); if( val &gt; 99 &amp;&amp; val &lt; 256)&#123; restore(s.substring(3), sb + s.substring(0,3) +".", len -1); &#125; &#125; &#125;&#125;// 也可以用 StringBuilder 4ms 34.7MBclass Solution &#123; private List&lt;String&gt; result = new ArrayList(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; restore(s, new StringBuilder(), 4); return result; &#125; private void restore(String s, StringBuilder sb, int len)&#123; if(len == 0 &amp;&amp; s.length() == 0)&#123; result.add(sb.toString().substring(0, sb.length() -1)); return; &#125; if(s.length() &gt; len * 3 || len == 0 || s.length() &lt; 1)&#123; return; &#125; sb.append(s.substring(0,1)).append("."); restore(s.substring(1), sb, len -1); sb.delete(sb.length()-2, sb.length()); if(s.length() &gt;= 2 )&#123; int val = Integer.parseInt(s.substring(0, 2)); if(val &gt; 9)&#123; sb.append(s.substring(0,2)).append("."); restore(s.substring(2), sb, len -1); sb.delete(sb.length()-3, sb.length()); &#125; &#125; if(s.length() &gt;= 3)&#123; int val = Integer.parseInt(s.substring(0, 3)); if( val &gt; 99 &amp;&amp; val &lt; 256)&#123; sb.append(s.substring(0,3)).append("."); restore(s.substring(3), sb, len -1); sb.delete(sb.length()-4, sb.length()); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// 2ms 37.2MBclass Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; int[] splits = new int[5]; //分割的每一段的开始位置，从1开始 List&lt;String&gt; ips = new ArrayList&lt;&gt;(); restoreIpAddresses(0,splits,s,ips); return ips; &#125; //通过寻找原IP地址的四个分段的起始位置来确定新的IP地址 private void restoreIpAddresses(int level,int[] s,String ip,List&lt;String&gt; ips)&#123; if(level == 4 &amp;&amp; s[4] != ip.length())&#123; //生成的ip地址的长度不和原ip地址长度相同则退出 return; &#125; if(level == 4 &amp;&amp; s[4] == ip.length())&#123; String r = ip.substring(s[0],s[1])+"."+ip.substring(s[1],s[2])+"."+ip.substring(s[2],s[3])+"."+ip.substring(s[3]); ips.add(r); &#125; int num = 0; for(int i = s[level];i&lt;ip.length();i++)&#123; num = num*10+ip.charAt(i)-'0'; if((num == 0 &amp;&amp; i==s[level]) || (num&gt;0 &amp;&amp; num&lt;=255))&#123; //越界检查，当num为0时，i必须与该段的开始位置相等 s[level+1]=i+1; restoreIpAddresses(level+1,s,ip,ips); if(num == 0 &amp;&amp; i==s[level]) //如果是0，则0后面不能有其他数字 break; continue; &#125; break; &#125; &#125; &#125; 94. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes’ values. Example: 123456789&gt; Input: [1,null,2,3]&gt; 1&gt; \&gt; 2&gt; /&gt; 3&gt; &gt; Output: [1,3,2]&gt; &gt; Follow up: Recursive solution is trivial, could you do it iteratively? 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;Integer&gt; result = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null)return result; if(root.left == null &amp;&amp; root.right == null)&#123; result.add(root.val); return result; &#125; if(root.left != null)&#123; inorderTraversal(root.left); &#125; result.add(root.val); if(root.right != null)&#123; inorderTraversal(root.right); &#125; return result; &#125;&#125; 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;Integer&gt; result = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null)return result; TreeNode curRoot = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(curRoot != null || !stack.isEmpty())&#123; while(curRoot != null)&#123; stack.push(curRoot); curRoot = curRoot.left; &#125; curRoot = stack.pop(); result.add(curRoot.val); curRoot = curRoot.right; &#125; return result; &#125;&#125; 95. Unique Binary Search Trees II Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 123456789101112131415161718&gt; Input: 3&gt; Output:&gt; [&gt; [1,null,3,2],&gt; [3,2,null,1],&gt; [3,1,null,null,2],&gt; [2,1,3],&gt; [1,null,2,null,3]&gt; ]&gt; Explanation:&gt; The above output corresponds to the 5 unique BST&apos;s shown below:&gt; &gt; 1 3 3 2 1&gt; \ / / / \ \&gt; 3 2 1 1 3 2&gt; / / \ \&gt; 2 1 2 3&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n == 0) return new ArrayList(); return generate(1, n); &#125; private List&lt;TreeNode&gt; generate(int start, int end) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if (start &gt; end) &#123; res.add(null); return res; &#125; if (start == end) &#123; res.add(new TreeNode(start)); return res; &#125; for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; leftSubTrees = generate(start, i-1); List&lt;TreeNode&gt; rightSubTrees = generate(i+1, end); for (TreeNode left : leftSubTrees) &#123; for(TreeNode right : rightSubTrees) &#123; TreeNode node = new TreeNode(i); node.left = left; node.right = right; res.add(node); &#125; &#125; &#125; return res; &#125;&#125; 96. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 1234567891011&gt; Input: 3&gt; Output: 5&gt; Explanation:&gt; Given n = 3, there are a total of 5 unique BST&apos;s:&gt; &gt; 1 3 3 2 1&gt; \ / / / \ \&gt; 3 2 1 1 3 2&gt; / / \ \&gt; 2 1 2 3&gt; 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt;= n; i ++)&#123; for(int j = 0; j &lt; i; j++)&#123; dp[i] += dp[j]* dp[i - j -1]; &#125; &#125; return dp[n]; &#125;&#125; 98. Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456&gt; Input:&gt; 2&gt; / \&gt; 1 3&gt; Output: true&gt; &gt; Example 2: 123456789&gt; 5&gt; / \&gt; 1 4&gt; / \&gt; 3 6&gt; Output: false&gt; Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value&gt; is 5 but its right child&apos;s value is 4.&gt; 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 注意：Double.MIN_VALUE 不是最小负数，而是最小非负数 double preVal = -Double.MAX_VALUE; public boolean isValidBST(TreeNode root) &#123; //不仅要保证 左节点&lt;根节点&lt;右节点，同时左节点的所有节点都得小于根节点；右节点同理 if(root == null)return true; if(isValidBST(root.left))&#123; if(preVal &lt; root.val)&#123; preVal = root.val; return isValidBST(root.right); &#125; &#125; return false; &#125;&#125; 100. Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 12345678&gt; Input: 1 1&gt; / \ / \&gt; 2 3 2 3&gt; &gt; [1,2,3], [1,2,3]&gt; &gt; Output: true&gt; &gt; Example 2: 12345678&gt; Input: 1 1&gt; / \&gt; 2 2&gt; &gt; [1,2], [1,null,2]&gt; &gt; Output: false&gt; &gt; Example 3: 12345678&gt; Input: 1 1&gt; / \ / \&gt; 2 1 1 2&gt; &gt; [1,2,1], [1,1,2]&gt; &gt; Output: false&gt; 1234567891011121314151617/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q==null)return true; if(p == null | q == null)return false; if(p.val != q.val)return false; return isSameTree(p.left, q.left)&amp;&amp; isSameTree(p.right, q.right); &#125;&#125; 101. Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 123456&gt; 1&gt; / \&gt; 2 2&gt; / \ / \&gt; 3 4 4 3&gt; &gt; But the following [1,2,2,null,3,null,3] is not: 123456&gt; 1&gt; / \&gt; 2 2&gt; \ \&gt; 3 3&gt; &gt; Note:Bonus points if you could solve it both recursively and iteratively. 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null)return true; return isSymmetric(root.left, root.right); &#125; public boolean isSymmetric(TreeNode left, TreeNode right)&#123; if(left == null &amp;&amp; right == null)return true; if(left == null || right == null)return false; if(left.val == right.val)&#123; return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客踩坑]]></title>
    <url>%2F2019%2F04%2F08%2Fhexo%E5%8D%9A%E5%AE%A2-bug-making-debug%2F</url>
    <content type="text"><![CDATA[每次写完markdown笔记后上传到csdn都是件恼火的事情，如果没有图片，倒也方便，若是有较多图片，那就脑壳疼了。起意很久，还是用github&amp;gitee实践一波自己的博客吧。期间遇到很多bug，感谢文末链接中的大佬们，前人踩坑，后来者接着踩。 环境搭建 安装Git 在Windows系统，部署相关指令主要在Git Bash中运行 博客发布在Gitee/Github上都需要使用到Git 安装Node.js 安装hexo及初始化本地博客 Hexo相关指令介绍 hexo init ：初始化本地博客 123&gt; $ hexo init &lt;folder&gt; # 在指定文件夹初始化项目&gt; $ hexo init # 在当前文件夹初始化项目&gt; hexo generate： 通过markdown文件生成静态网页 hexo deploy：将public文件夹中的静态资源发布到指定仓库 1234&gt; $ hexo generate --watch # 一般默认自带--watch，根据文件的sha1值以比对文件是否改动，从而及时刷新&gt; $ hexo generate --deploy&gt; $ hexo deploy --generate # 两者的效果一样，生成完毕后自动部署&gt; &gt; 123&gt; $ hexo g -d&gt; $ hexo d -g # 上面两个指令的简写，同理，hexo server 可以简写为 hexo s&gt; hexo server：在本地发布服务，提供访问 123456&gt; # 安装服务器模块，3.0默认是个别模块&gt; $ npm install hexo-server --save&gt; $ hexo server -p 5000 # 指定端口发布&gt; $ hexo server -s # 静态模式，不会动态跟进source文件夹文件变动&gt; $ hexo server -i ip_addr # 一般不会用到这种骚操作&gt; &gt; hexo new：新建页面或者blog 1234&gt; $ hexo new [layout] &lt;title&gt; &gt; # layout默认是_post,可以在_config.yml中的default_layout修改对应参数，&gt; # 同时如果标题包含空格，用括号将内容包裹 &gt; &gt; 12&gt; $ hexo new page page_name # 新建页面，提供访问，可以在主题的 _config.yml中修改提供访问 &gt; hexo clean: 清除缓存文件(db.json)和已生成的静态文件(public文件夹中内容)，在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 其他命令详情见 12345# 在指定文件夹中新建所需要的文件，如果后续不接参数，则在当前文件夹建立hexo init &lt;folder&gt; cd &lt;folder&gt;# 根据对应的package.json安装相关的npm依赖包npm install 建立完成后，指定文件夹目录如下 12345678.├── _config.yml # 网站的相关配置信息├── package.json # 应用程序的信息，及相关依赖├── scaffolds # 模板文件夹，新建页面和文章时，会根据模板初始化├── source # 资源文件夹，_posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。| ├── _drafts | └── _posts └── themes # 主题文件夹，hexo根据不同的主题生成静态页面 将本地博客同步到仓库（Gitee/Coding/Github等） 发布前预备工作，以git为例，其他代码托管网站原理一致 安装 hexo-deployer-git 12&gt; $ npm install hexo-deployer-git --save&gt; 修改_config.yml配置文件,冒号后务必有空格12345678910&gt; deploy:&gt; - type: git&gt; repo: &lt;repository url&gt;&gt; branch: [branch]&gt; message: [message]&gt; - type: git&gt; repo: &lt;repository url&gt;&gt; branch: [branch]&gt; message: [message]&gt; 仓库取名：默认情况不是子目录，需要将仓库名取为: &lt;用户名&gt;.github.io 这样命名，github的page服务会自动识别处理，否则需要额外设置子目录，如果想在子目录发布，需要额外在_config.yml中配置 分支名称：如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。也可以在仓库中的setting中勾选GitHub Pages勾选分支 其他如Heroku、Netlify、Rsync等详见官网文档 附：在子目录中发布参数修改 123&gt; url: &lt;github仓库地址&gt; # 仓库访问地址&gt; root: &lt;子目录&gt; # 一般子目录也就是项目名&gt; &gt; 主题选择与优化主题有多种，各种折腾后，最后我选择的next主题。 相关插件配置 本地搜索 评论 公式支持]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js创建流媒体服务器]]></title>
    <url>%2F2018%2F10%2F28%2Fnode.js%E5%88%9B%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[系统：linuxnpm安装Ubuntu：123456# 安装 npmsudo apt-get install npm # npm 升级sudo npm install -g npm# 切换到淘宝镜像源npm install -g cnpm --registry=http://registry.npm.taobao.org 安装express1234# 先安装generatorsudo npm install -g express-generator# 安装expresssudo npm instal -g express 通过express创建工程1234# 新建工程express --view=ejs nodeServer# 进入到工程目录cd nodeServer 123456789101112131415161718&lt;!-- 打开 package.json 并在dependencies 添加相关依赖 --&gt; &#123; "name": "nodeServer", "version": "0.0.0", "private": true, "scripts": &#123; "start": "node ./bin/www" &#125;, "dependencies": &#123; "cookie-parser": "~1.4.3", "debug": "~2.6.9", "ejs": "~2.5.7", "express": "~4.16.0", "http-errors": "~1.6.2", "morgan": "~1.9.0", "node-media-server": "~1.4.3" &#125;&#125; 123# 利用npm安装所有依赖npm install # 至此 node.js 环境配置完成 在NodeServer文件夹中新建js文件，如：nodeServerTest.js并设置内容如下123456789101112131415161718const &#123; NodeMediaServer &#125; = require('node-media-server');const config = &#123; rtmp: &#123; port: 1935, chunk_size: 60000, gop_cache: true, ping: 60, ping_timeout: 30 &#125;, http: &#123; port: 8000, allow_origin: '*' &#125;&#125;;var nms = new NodeMediaServer(config);nms.run(); 在该文件夹下终端运行如下指令：12# 以非严格模式运行node --harmony nodeServerTest.js 得到结果如下：至此，node.js已创建服务器，相关端口参数如果后来者不明白，自己百度科普 安装ffmpeg并推送流数据Ubuntu下安装ffmpeg比较方便：1sudo apt-get install ffmpeg 查找摄像头设备：12sudo ls /dev/video*# 若只有一个摄像头，得到的一般是 /dev/video0 ffmpeg推送流12ffmpeg -f video4linux2 -i /dev/video0 -vcodec libx264 -acodec libvo_aacenc -b 1080k -r 33 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://localhost:1935/live/STREAM_NAME# 附注：在Windows系统下，-f后面的参数多为dshow，-i后面的参数video="摄像头名":audio="麦克风名"，在Windows系统中，多为虚拟设备 运行效果如下：参考链接链接备用：（https://oainin.wordpress.com/2018/06/09/nodejs%E5%88%9B%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/）至此在其他主机上能够访问实时流 在网页上访问流数据新建html文件，如：videoPlay.html123456789101112131415&lt;!-- 将192.168.128.112换成服务器实际ip --&gt;&lt;script src="https://cdn.bootcss.com/flv.js/1.4.0/flv.min.js"&gt;&lt;/script&gt;&lt;video id="videoElement" width="720" height="400" controls&gt;&lt;/video&gt;&lt;script&gt; if (flvjs.isSupported()) &#123; var videoElement = document.getElementById('videoElement'); var flvPlayer = flvjs.createPlayer(&#123; type: 'flv', url: 'http://192.168.128.112:8000/live/STREAM_NAME.flv' &#125;); flvPlayer.attachMediaElement(videoElement); flvPlayer.load(); flvPlayer.play(); &#125;&lt;/script&gt; 用浏览器打开该html文件即可实时查看流数据。1、视频延迟比较久，原因暂未知，貌似和缓冲区大小无关2、打开的浏览器用高端点的，需要能够支持html5，否则自己该页面代码3、视频未加载音频，若需加载详情百度ffserver.conf相关配置以及linux音频输入设备查找]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>流媒体</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode note - part 1]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-note-part-1%2F</url>
    <content type="text"><![CDATA[刷LeetCode的笔记，方便自己查看做题遇到的坑 Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1:1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2:12345Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3:123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 12345678910111213141516171819202122232425262728293031class Solution &#123; public int maxProfit(int[] prices) &#123; return calculate(prices, 0); &#125; public int calculate(int prices[], int s) &#123; if (s &gt;= prices.length) return 0; int max = 0; for (int start = s; start &lt; prices.length; start++) &#123; System.out.println("======new start== "+start+" ===="); int maxprofit = 0; for (int i = start + 1; i &lt; prices.length; i++) &#123; if (prices[start] &lt; prices[i]) &#123; System.out.println("index :"+start+"--"+i+" buy: "+prices[start] +" sell: " + prices[i]); int profit = calculate(prices, i + 1) + prices[i] - prices[start]; if (profit &gt; maxprofit)&#123; System.out.println("profit change:"+ maxprofit +" --&gt; " +profit); maxprofit = profit; &#125; &#125; &#125; if (maxprofit &gt; max)&#123; System.out.println("max profit change:"+ max +" --&gt; " +maxprofit); max = maxprofit; &#125; &#125; System.out.println("profit:"+max); return max; &#125;&#125; 12int[] price = new int[]&#123;7,1,5,3,6,4&#125;;new Solution().maxProfit(price); ======new start== 0 ==== ======new start== 1 ==== index :1--2 buy: 1 sell: 5 ======new start== 3 ==== index :3--4 buy: 3 sell: 6 ======new start== 5 ==== profit:0 profit change:0 --&gt; 3 index :3--5 buy: 3 sell: 4 max profit change:0 --&gt; 3 ======new start== 4 ==== ======new start== 5 ==== profit:3 profit change:0 --&gt; 7 index :1--3 buy: 1 sell: 3 ======new start== 4 ==== ======new start== 5 ==== profit:0 index :1--4 buy: 1 sell: 6 ======new start== 5 ==== profit:0 index :1--5 buy: 1 sell: 4 max profit change:0 --&gt; 7 ======new start== 2 ==== index :2--4 buy: 5 sell: 6 ======new start== 5 ==== profit:0 profit change:0 --&gt; 1 ======new start== 3 ==== index :3--4 buy: 3 sell: 6 ======new start== 5 ==== profit:0 profit change:0 --&gt; 3 index :3--5 buy: 3 sell: 4 ======new start== 4 ==== ======new start== 5 ==== profit:7 125. Valid PalindromeGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1:12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true Example 2:12Input: &quot;race a car&quot;Output: false 12345678910111213141516171819202122232425// 自己的解决方案class Solution &#123; public boolean isPalindrome(String s) &#123; //利用正则，去除空格和无关符号，倒转看知否相等 String pattern = "^[a-z0-9]"; s = s.toLowerCase(); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i =0 ; i&lt; s.length(); i++)&#123; if(String.valueOf(s.charAt(i)).matches(pattern))&#123; list.add(s.charAt(i)); &#125; &#125; Object[] strArray = list.toArray(); return isPalindromeArray(strArray); &#125; private boolean isPalindromeArray(Object[] array)&#123; int length = array.length; for(int i = 0; i&lt; array.length /2; i++)&#123; if( array[i] != array[length-1-i])&#123; return false; &#125; &#125; return true; &#125;&#125; 12345678910111213141516171819202122232425262728293031// 最好的解决方案class Solution &#123; private static final int[] map = new int[256]; static&#123; for(int i = 0; i &lt; 10; i++)&#123; map[i + '0'] = (i + 1); &#125; for(int i = 0; i &lt; 26; i++)&#123; map[i + 'a'] = map[i + 'A'] = (i + 11); &#125; &#125; public boolean isPalindrome(String s) &#123; char[] arrays = s.toCharArray(); int start = 0, end = arrays.length - 1; int startVal, endVal; while(start &lt; end)&#123; startVal = map[arrays[start]]; endVal = map[arrays[end]]; if(startVal != 0 &amp;&amp; endVal != 0)&#123; if(startVal != endVal) return false; start++; end--; &#125;else&#123; if(startVal == 0) start++; else end--; &#125; &#125; return true; &#125;&#125; 136. Single NumberGiven a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1:12Input: [2,2,1]Output: 1 Example 2:12Input: [4,1,2,1,2]Output: 4 123456789101112131415161718192021//自己写的错误方法class Solution &#123; public int singleNumber(int[] nums) &#123; int[] positive = new int[Integer.MAX_VALUE]; int[] negative = new int[Integer.MAX_VALUE]; for( int i = 0; i &lt; nums.length; i++ )&#123; if( nums[i] &gt;=0 )&#123; positive[nums[i]]++; &#125; else&#123; negative[-nums[i]]++; &#125; &#125; for( int i = 0; i &lt; Integer.MAX_VALUE; i++)&#123; if(positive[i] == 1 )return i; if(negative[i] == 1 )return i; &#125; return nums[0]; &#125;&#125; 12345678910// 推荐的方法class Solution &#123; public int singleNumber(int[] nums) &#123; int a = 0; for( int i = 0; i &lt; nums.length; i++ )&#123; a ^= nums[i]; &#125; return a; &#125;&#125; 141. Linked List CycleGiven a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 12345678910111213141516171819202122232425262728293031323334// my Code //错误原因：有环，但是不一定首尾相连，可能是中间部位/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125; &#125;public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode head_bak = head; if( null == head || head.next == null )return false; while(null != head.next)&#123; head = head.next; if( head_bak == head)&#123; return true; &#125; &#125; return false; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** 正确解法有两种： *一种通过Set来逐个加入，判断是否已含有，如果有则表示有环 *双指针解法，一个一次走一步，一个一次走两步，如果有环，总有一次会遇上**//** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125; &#125;public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if( null == head || head.next == null )return false; ListNode walker = head; ListNode runner = head.next; while(walker != runner)&#123; if( null == walker.next || null== runner.next)&#123; return false; &#125; walker = walker.next; runner = runner.next.next; &#125; return true; &#125;&#125; 8. String to Integer (atoi)Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.Example 1:12Input: &quot;42&quot;Output: 42 Example 2:1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3:123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. Example 4:1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5:1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 123456789101112131415161718192021222324252627282930//我的答案class Solution &#123; public int myAtoi(String str) &#123; if(null == str)return 0; String toInt = str.trim(); if( 0 == toInt.length())return 0; int start = 0; int end = 0; if(toInt.startsWith("-") || toInt.startsWith("+"))start ++; for(end = start; end &lt; toInt.length(); )&#123; if('0'&lt;= toInt.charAt(end) &amp;&amp; '9'&gt;= toInt.charAt(end))&#123; end++; &#125;else&#123; break; &#125; &#125; if(end - start &lt; 1)return 0; int value = 0; try&#123; value = Integer.parseInt(toInt.substring(0,end)); &#125;catch(Exception e)&#123; if(toInt.startsWith("-"))&#123; return Integer.MIN_VALUE; &#125;else&#123; return Integer.MAX_VALUE; &#125; &#125; return value; &#125;&#125; 123456789101112131415161718192021222324252627282930313233// 推荐答案class Solution &#123; public int myAtoi(String str) &#123; if(str==null || str.length() == 0) return 0; int index = 0; while(index &lt; str.length() &amp;&amp; str.charAt(index) == ' ') index++; int sign = 1; // 正负只能有一个，同时及时判断是否out of index if(index &lt; str.length() &amp;&amp; str.charAt(index) == '-') &#123; sign = -1; index++; &#125; else if (index &lt; str.length() &amp;&amp; str.charAt(index) == '+') &#123; index++; &#125; int total = 0; while(index &lt; str.length()) &#123; int digit = str.charAt(index) - '0'; if(digit &lt; 0 || digit &gt; 9) break; if((Integer.MAX_VALUE - digit) / 10 &lt; total) &#123;//判断是否超过int值范围 return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; total = total * 10 + digit; index++; &#125; return total * sign; &#125;&#125; 5. Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1:123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2:12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 12345678910111213141516171819202122232425262728// 我的答案class Solution &#123; public String longestPalindrome(String s) &#123; if(null == s || s.length() == 0 ) return ""; if(s.length() == 1) return s; int start = 0; int end = 1; String palindromeStr = ""; while(start !=s.length())&#123; String temp = s.substring(start,end); if(isPalindromic(temp))&#123; if(temp.length() &gt;= palindromeStr.length())&#123; palindromeStr = temp; &#125; &#125; end++; if(end &gt; s.length())&#123; start++; end = start +1; &#125; &#125; return palindromeStr; &#125; public boolean isPalindromic(String s)&#123; StringBuilder sb = new StringBuilder(s); return s.equals(sb.reverse().toString()); &#125;&#125; 12345678910111213141516171819202122232425//推荐答案class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt;= 1) return s; int len = s.length(); for (int i = 0; i &lt; len - 1; i++) &#123; extendPalindrome(s, i, i); // assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i + 1); // assume even length &#125; return s.substring(lo, lo + maxLen); &#125; private void extendPalindrome(String s, int i, int j) &#123; while (i &gt;= 0 &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i--; j++; &#125; if (maxLen &lt; j - i - 1) &#123;//j-i+1 -2 maxLen = j - i - 1; lo = i + 1; &#125; &#125;&#125; 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Example 1:123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2:123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3:1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 注释部分是自己写ac的答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; /*char[] sArray = s.toCharArray(); int maxLength = 0; for(int i = 0; i &lt; sArray.length; i++)&#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int j = i; j &lt; sArray.length; j++)&#123; if(set.contains(sArray[j])) break; set.add(sArray[j]); &#125; maxLength = maxLength &gt; set.size() ? maxLength : set.size(); &#125; return maxLength;*/ /* int len = 0; if(s==null || s.length() == 0) return len; int start = 0; int end = 1; len++; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); char[] c = s.toCharArray(); set.add(c[0]); int max = len; while( end != c.length)&#123; if( set.contains(c[end]))&#123; set.remove(c[start]); start++; len--; continue; &#125; set.add(c[end]); len++; end++; max = max &gt; len ? max : len; &#125; return max; */ int[] arr = new int[256]; int rep = 0; int max = 0; for(int i = 1; i &lt;= s.length(); i++)&#123; int c = s.charAt(i-1); rep = Math.max(rep,arr[c]); int count = i -rep ;//如果没有重复，rep等于0，count等于i，相当于count++ max = max &gt; count ? max : count; arr[c] = i; &#125; return max; &#125;&#125; 11. Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example:12Input: [1,8,6,2,5,4,8,3,7]Output: 49 1234567891011121314151617181920//逐个遍历求面积然后取最大值，肯定能做出来，但是效率太差class Solution &#123; public int maxArea(int[] height) &#123; int start = 0; int end = height.length -1; int cap = 0; while (start &lt; end)&#123; int min_height = Math.min(height[start], height[end]); int tempCap = min_height * (end -start); if(height[start] &lt; height[end])&#123;//我用的比较左右面积来移动，得出结果是错的；需思考为何用高度是对的 start ++; &#125;else&#123; end --; &#125; cap = cap &gt; tempCap ? cap : tempCap; &#125; return cap; &#125;&#125; 15. 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example:1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 我的acclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if(3 &gt; nums.length) return list; int num1Index = 0; int num2Index = 1; boolean is3Zero = false; boolean isAllZero = true; for(int i = 0; i &lt; nums.length; i++)&#123;//需要考虑全是0的特殊情况，避免大量判断 if(nums[i] != 0)&#123; isAllZero = false; break; &#125; &#125; if(isAllZero)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.add(0); tmp.add(0); tmp.add(0); list.add(tmp); return list; &#125; while(num1Index &lt; nums.length-2)&#123; for(int i = num2Index + 1; i &lt; nums.length; i++)&#123; if(nums[num1Index] + nums[num2Index] + nums[i] == 0)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.add(nums[num1Index]); tmp.add(nums[num2Index]); tmp.add(nums[i]); if(nums[num1Index] == 0 &amp;&amp; nums[num2Index] == 0 &amp;&amp; !is3Zero)&#123; list.add(tmp); is3Zero = true; continue; &#125; if(isDuplicated(list,tmp))continue; list.add(tmp); &#125; &#125; if(num2Index == nums.length-2)&#123; num1Index ++; num2Index = num1Index +1; &#125;else&#123; num2Index ++; &#125; &#125; return list; &#125; public boolean isDuplicated(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; list2)&#123; for(List&lt;Integer&gt; temp : list)&#123; if(temp.containsAll(list2))return true; &#125; return false; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 推荐答案，先进行排序，然后进行相关判断（子对队列首、尾相加并进行判断）class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; resultArray=new ArrayList&lt;&gt;(); if(nums==null||nums.length&lt;3) return resultArray; Arrays.sort(nums); for(int i=0;i&lt;nums.length-2;i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])continue; List&lt;List&lt;Integer&gt;&gt; result=find(nums,i+1,nums.length-1,nums[i]); resultArray.addAll(result); &#125; return resultArray; &#125; public List&lt;List&lt;Integer&gt;&gt; find(int[] nums,int start,int end,int target)&#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); int left=start,right=end; while(left&lt;right)&#123; if(nums[left]+nums[right]+target==0)&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); list.add(nums[left]); list.add(nums[right]); list.add(target); result.add(list); while(left&lt;right&amp;&amp;nums[left]==nums[left+1])left++; while(left&lt;right&amp;&amp;nums[right]==nums[right-1])right--; left++; right--; &#125; else if(nums[left]+nums[right]&lt;-1*target)//要使和大一些，那么right保持不动，left向右移动 &#123; left++; &#125; else &#123; right--; &#125; &#125; return result; &#125;&#125; 16. 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example:123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 123456789101112131415161718192021222324252627282930313233//我的答案class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int diff = 0; while(true)&#123; for(int i = 0; i &lt;nums.length; i++)&#123; // nums[i] + num[start] + nums[end] = target + diff if(find(nums, i+1, nums.length-1, target + diff - nums[i]))&#123; return target + diff; &#125; // nums[i] + num[start] + nums[end] = target - diff if(find(nums, i+1, nums.length-1, target - diff - nums[i]))&#123; return target - diff; &#125; &#125; diff++; &#125; &#125; public boolean find(int[] nums, int start, int end, int target)&#123; while(start &lt; end)&#123; if(nums[start] + nums[end] == target)&#123; return true; &#125;else if(nums[start] + nums[end] &lt; target)&#123; start++; &#125;else&#123; end--; &#125; &#125; return false; &#125;&#125; 1234567891011121314151617181920212223242526//使用空间最小的答案class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if(nums==null || nums.length&lt;3) return 0; Arrays.sort(nums); int len = nums.length; int result = nums[0]+nums[1]+nums[len-1]; for(int i=0; i&lt;len-2; i++)&#123; int val1 = nums[i]; int j=i+1; int k=len-1; while(j&lt;k)&#123; int sum = val1+nums[j]+nums[k]; if(sum &gt;target)&#123; k--; &#125;else&#123; j++; &#125; if(Math.abs(target-result) &gt; Math.abs(target-sum))&#123; result = sum; &#125; &#125; &#125; return result; &#125;&#125; 17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example:12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 123456789101112131415161718192021222324252627// 我的方法，使用循环实现class Solution &#123; public String[] letterTable = &#123;"","","abc", "def", "ghi", "jkl", "mno", "qprs", "tuv", "wxyz"&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if(digits.length() == 0)return list; for(int i = 0; i &lt; letterTable[digits.charAt(0) - '0'].length(); i++)&#123; list.add(letterTable[digits.charAt(0) - '0'].charAt(i) + ""); &#125; for(int i = 1; i &lt; digits.length(); i++)&#123; int digit = digits.charAt(i) - '0'; String numStr = letterTable[digit]; List&lt;String&gt; tmpList = new ArrayList(); for(String str : list)&#123; for(int j = 0; j &lt; numStr.length(); j++)&#123; tmpList.add(str + numStr.charAt(j)); &#125; &#125; list = tmpList; &#125; return list; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 当前排名使用最少空间的，使用的是递归的方法，其实原理和循环类似，通过substring方法完成递归实现class Solution &#123; Map&lt;Character, String&gt; phone = new HashMap&lt;Character, String&gt;() &#123;&#123; put('2', "abc"); put('3', "def"); put('4', "ghi"); put('5', "jkl"); put('6', "mno"); put('7', "pqrs"); put('8', "tuv"); put('9', "wxyz"); &#125;&#125;; List&lt;String&gt; output; public void backtrack(String combination, String next_digits)&#123; // if there is no more digits to check if(next_digits.length() == 0)&#123; // the combination is done output.add(combination); &#125; // if there are still digits to check else &#123; // iterate over all letters which map // the next available digit char digit = next_digits.charAt(0); String letters = phone.get(digit); for(int i = 0 ; i &lt; letters.length() ; i++)&#123; char letter = phone.get(digit).charAt(i); // append the current letter to the combination // and proceed to the next digits backtrack(combination + letter, next_digits.substring(1)); &#125; &#125; &#125; public List&lt;String&gt; letterCombinations(String digits) &#123; output = new ArrayList&lt;&gt;(); if(digits.length() != 0)&#123; backtrack("", digits); &#125; return output; &#125;&#125; 18. 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example:12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 123456789101112131415161718192021222324252627282930313233343536373839//我的ac 25 msclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); Arrays.sort(nums); if(nums.length &lt; 4)return result; for(int i = 0; i &lt; nums.length - 3; i++)&#123; for(int j = i + 1; j &lt; nums.length -2; j++)&#123; List&lt;List&lt;Integer&gt;&gt; tmpresult =find(nums, i, j, j + 1, nums.length - 1, target -nums[i] - nums[j]); result.addAll(tmpresult); while(j&lt;nums.length-2 &amp;&amp; nums[j] == nums[j+1])j++;//注意重复数值可能导致添加重复组合 &#125; while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1]) i++;//注意重复数值可能导致添加重复组合 &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; find (int[] nums, int ind1, int ind2, int left, int right, int target)&#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; List&lt;Integer&gt; tmp = new ArrayList(); tmp.add(nums[ind1]); tmp.add(nums[ind2]); tmp.add(nums[left]); tmp.add(nums[right]); result.add(tmp); while(left&lt;right&amp;&amp;nums[left] == nums[left+1])left++;//注意重复数值可能导致添加重复组合 while(left&lt;right&amp;&amp;nums[right] == nums[right-1])right--;//注意重复数值可能导致添加重复组合 left ++;//注意，这里还是得前进，因为前面只是排除重复的 right --;//注意，这里还是得前进，因为前面只是排除重复的 &#125;else if(nums[left] + nums[right] &lt; target)&#123; left ++; &#125;else&#123; right --; &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//查看其它ac后的改良版本 10 msclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); Arrays.sort(nums); if(nums.length &lt; 4)return result; for(int i = 0; i &lt; nums.length - 3; i++)&#123; // 此处为改良处，提前判断后续是否有合适的结果，减少不必要的计算 if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target) break; if(nums[i]+nums[nums.length-1]+nums[nums.length-2]+nums[nums.length-3]&lt;target) continue; for(int j = i + 1; j &lt; nums.length -2; j++)&#123; // 此处为改良处，提前判断后续是否有合适的结果，减少不必要的计算 if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[nums.length-1]+nums[nums.length-2]&lt;target) continue; List&lt;List&lt;Integer&gt;&gt; tmpresult =find(nums, i, j, j + 1, nums.length - 1, target -nums[i] - nums[j]); result.addAll(tmpresult); while(j&lt;nums.length-2 &amp;&amp; nums[j] == nums[j+1])j++; &#125; while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1]) i++; &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; find (int[] nums, int ind1, int ind2, int left, int right, int target)&#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; List&lt;Integer&gt; tmp = new ArrayList(); tmp.add(nums[ind1]); tmp.add(nums[ind2]); tmp.add(nums[left]); tmp.add(nums[right]); result.add(tmp); while(left&lt;right&amp;&amp;nums[left] == nums[left+1])left++; while(left&lt;right&amp;&amp;nums[right] == nums[right-1])right--; left ++; right --; &#125;else if(nums[left] + nums[right] &lt; target)&#123; left ++; &#125;else&#123; right --; &#125; &#125; return result; &#125;&#125; 1// 最少空间的ac 19. Remove Nth Node From End of ListGiven a linked list, remove the n-th node from the end of list and return its head. Example:123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. 12345678910111213141516171819202122232425262728293031323334353637// my ac/** Definition for singly-linked list.*/ public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode point = head; int size = 1; while(point.next != null)&#123; size ++; point = point.next; &#125; if(size ==1 &amp;&amp; n&gt;=1)return null; if(size == n)return head.next; point = head; for(int i = 0; i &lt; size - n -1; i++)&#123; point = point.next; &#125; if(point == head)&#123; if(size &gt; 2)&#123; head.next = head.next.next; &#125;else&#123; head.next = null; &#125; &#125;else&#123; if(null != point.next)&#123; point.next = point.next.next; &#125; &#125; return head; &#125;&#125; 1234567891011121314151617181920212223242526272829303132// min space ,使用的递归方法class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head == null || head.next == null) &#123; return null; &#125; int i = getNodeIndex(head,n); if(i == n) &#123; head = head.next; &#125; return head; &#125; private int getNodeIndex(ListNode node, int n) &#123; if(node.next == null) &#123; return 1; &#125; int i = 1 + getNodeIndex(node.next,n); if( n == i-1) &#123; node.next = node.next.next; return i ; &#125; return i; &#125;&#125; 22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 1234567891011121314151617181920212223// 第一次错误方法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList(); if(n == 0)return list; list.add("()"); for(int i = 1; i &lt; n; i++)&#123; List&lt;String&gt; tmp = new ArrayList(); for(String str : list)&#123; tmp.add("(" + str +")"); String tmpstr = str + "()"; if(tmpstr.equals("()"+str))&#123; tmp.add(tmpstr); &#125;else&#123; tmp.add(str + "()"); tmp.add("()" + str); &#125; &#125; list = tmp; &#125; return list; &#125;&#125; 12345678910111213141516171819202122232425262728293031//第二次错误方法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; listAll = new ArrayList(); List&lt;String&gt; tmp = new ArrayList(); if(n == 0)return tmp; tmp.add("()"); listAll.add(tmp); for(int i = 1; i &lt; n; i++)&#123; tmp = new ArrayList(); for(int j = 1; j &lt;= i/2 + 1; j++)&#123; if( j==1 )&#123; for(String str : listAll.get(i-1))&#123; tmp.add("(" + str + ")"); &#125; &#125; for(String str1:listAll.get(j-1))&#123; for(String str2 : listAll.get(i - j))&#123; tmp.add(str2 + str1); &#125; &#125; &#125; if(i&gt;=2)tmp.remove(tmp.size() -1); listAll.add(tmp); &#125; return listAll.get(n-1); &#125;&#125; 123456789101112131415161718// 推荐方法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList(); if(n == 0)&#123; list.add(""); &#125;else&#123; for(int i = 0; i &lt; n; i++)&#123; for(String left : generateParenthesis(i))&#123; for(String right : generateParenthesis(n - i -1))&#123; list.add("(" + left + ")" + right);//此处添加了一对括号 &#125; &#125; &#125; &#125; return list; &#125;&#125; 1234567891011121314151617181920//回溯法class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList(); backtrack(ans, "", 0, 0, n); return ans; &#125; public void backtrack(List&lt;String&gt; ans, String cur, int open, int close, int max)&#123; if (cur.length() == max * 2) &#123; ans.add(cur); return; &#125; if (open &lt; max) backtrack(ans, cur+"(", open+1, close, max); if (close &lt; open) backtrack(ans, cur+")", open, close+1, max); &#125;&#125; 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; combinations = new ArrayList(); generateAll(new char[2 * n], 0, combinations); return combinations; &#125; public void generateAll(char[] current, int pos, List&lt;String&gt; result) &#123; if (pos == current.length) &#123; if (valid(current)) result.add(new String(current)); &#125; else &#123; current[pos] = '('; generateAll(current, pos+1, result); current[pos] = ')'; generateAll(current, pos+1, result); &#125; &#125; public boolean valid(char[] current) &#123; int balance = 0; for (char c: current) &#123; if (c == '(') balance++; else balance--; if (balance &lt; 0) return false; &#125; return (balance == 0); &#125;&#125; 24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example:1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 1234567891011121314151617181920212223242526272829303132// my ac// Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; public ListNode swapPairs(ListNode head) &#123; return douExchange(head); &#125; public ListNode douExchange(ListNode left)&#123; if(left == null)return null; if(left.next ==null)return left; ListNode point = left.next.next; ListNode right = left.next; // 如果右边是最后一个，需要额外考虑 if(null == right.next)&#123; left.next = null; right.next = left; return right; &#125;else&#123; left.next = right.next.next; right.next = left; &#125; left.next = douExchange(point); return right; &#125;&#125; 12345678910111213// better acclass Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head ==null || head.next ==null)return head; ListNode tmp = head; head = head.next; tmp.next = head.next; head.next = tmp; // tmp.next = swapPairs(tmp.next); head.next.next = swapPairs(head.next.next);//这样写，即使是head.next是最后一个节点也可以解决 return head; &#125; &#125; 29. Divide Two IntegersGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1:12Input: dividend = 10, divisor = 3Output: 3 Example 2:12Input: dividend = 7, divisor = -3Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^{31}$,$2^{31}$ − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. 12345678910111213//MY ACclass Solution &#123; public int divide(int dividend, int divisor) &#123; if(dividend == Integer.MIN_VALUE &amp;&amp; divisor ==-1)return Integer.MAX_VALUE; try&#123; int result = dividend/divisor; if(result &lt; Integer.MIN_VALUE || result &gt;= Integer.MAX_VALUE)return Integer.MAX_VALUE; return result; &#125;catch(Exception e) &#123; return Integer.MAX_VALUE; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233// BETTER AC class Solution &#123; public int divide(int dividend, int divisor) &#123; if (dividend == 0) &#123; return 0; &#125; if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; boolean isPositive = true; if (dividend &gt; 0 &amp;&amp; divisor &lt; 0 || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) &#123; isPositive = false; &#125; long a = Math.abs((long) dividend); long b = Math.abs((long) divisor); int shift = 0; int result = 0; // 所有的整数都能用2的若干次幂求和得到，同时采用位移操作，能加快运算效率 while (a &gt;= b) &#123; while (a &gt;= b &lt;&lt; shift) &#123; shift++; &#125; a -= b &lt;&lt; (shift - 1); result += 1 &lt;&lt; (shift - 1); shift = 0; &#125; return isPositive ? result : -result; &#125;&#125; 33. Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1:12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2:12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int search(int[] nums, int target) &#123; if(nums.length ==0)return -1; if(nums[0] == target)return 0; return find(nums, 0, nums.length-1, target); &#125; public int find(int[] nums, int left, int right, int target)&#123; if(right &lt;left)return -1; if(nums[left] == target)return left; if(nums[right] == target)return right; int mid = left + (right -left)/2; if(nums[mid] == target)return mid; //判断右边的数值是否比左边的小，如果是，则说明翻转过 if(nums[mid] &lt; nums[right])&#123; //判断target落在哪个区间 //一定只会有两种可能，要么在左边，要么在右边 if(nums[mid] &lt; target &amp;&amp; target &lt; nums[right]) &#123; return find(nums, mid+1, right, target); &#125;else&#123; return find(nums, left, mid-1, target); &#125; &#125;else&#123; if(nums[left] &lt; target &amp;&amp; target &lt; nums[mid]) &#123; return find(nums, left, mid-1, target); &#125;else&#123; return find(nums, mid+1, right, target); &#125; &#125; &#125;&#125; 34. Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1:12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2:12Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 1234567891011121314151617181920212223242526// my acclass Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int tindex = find(nums, 0, nums.length-1, target); int left = tindex, right = tindex; while(left &gt;0 &amp;&amp;nums[left -1] == target)&#123; left --; &#125; while(right &lt; nums.length-1 &amp;&amp; nums[right +1] == target)&#123; right ++; &#125; return new int[]&#123;left, right&#125;; &#125; public int find(int[] nums, int left, int right, int target)&#123; if(left &gt; right)return -1; if(nums[left] == target)return left; if(nums[right] == target)return right; int mid = left + (right - left)/2; if(nums[mid] == target)return mid; if( nums[mid] &lt; target &amp;&amp; target &lt; nums[right])&#123; return find(nums, mid +1, right, target); &#125;else&#123; return find(nums, left, mid-1, target); &#125; &#125;&#125; 36. Valid SudokuDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. Example 1:12345678910111213Input:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true Example 2:12345678910111213141516Input:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. 1234567891011121314151617181920212223242526272829303132333435363738394041// my acclass Solution &#123; public boolean isValidSudoku(char[][] board) &#123; // 先进行判断 for(int i = 0; i &lt;9; i++)&#123; Set&lt;Character&gt; set = new HashSet(); for(int j = 0; j&lt;9; j++)&#123; if(!(board[i][j] == '.'))&#123; if(set.contains(board[i][j]))return false; set.add(board[i][j]); &#125; &#125; &#125; // 进行列判断 for(int i = 0; i &lt;9; i++)&#123; Set&lt;Character&gt; set = new HashSet(); for(int j = 0; j&lt;9; j++)&#123; if(! (board[j][i] == '.'))&#123; if(set.contains(board[j][i]))return false; set.add(board[j][i]); &#125; &#125; &#125; // 九宫格判断 for(int i = 0; i &lt;9; i = i + 3)&#123; for(int j = 0; j&lt;9; j = j + 3)&#123; Set&lt;Character&gt; set = new HashSet(); for(int k = 0; k&lt;3; k++)&#123; for(int h=0; h&lt;3; h++)&#123; if(!(board[i+k][j+h] == '.'))&#123; if(set.contains(board[i+k][j+h]))return false; set.add(board[i+k][j+h]); &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536// suggested acclass Solution &#123; public boolean isValidSudoku(char[][] board) &#123; // init data HashMap&lt;Integer, Integer&gt; [] rows = new HashMap[9]; HashMap&lt;Integer, Integer&gt; [] columns = new HashMap[9]; HashMap&lt;Integer, Integer&gt; [] boxes = new HashMap[9]; for (int i = 0; i &lt; 9; i++) &#123; rows[i] = new HashMap&lt;Integer, Integer&gt;(); columns[i] = new HashMap&lt;Integer, Integer&gt;(); boxes[i] = new HashMap&lt;Integer, Integer&gt;(); &#125; // validate a board for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; char num = board[i][j]; if (num != '.') &#123; int n = (int)num; int box_index = (i / 3 ) * 3 + j / 3; // keep the current cell value rows[i].put(n, rows[i].getOrDefault(n, 0) + 1); columns[j].put(n, columns[j].getOrDefault(n, 0) + 1); boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1); // check if this value has been already seen before if (rows[i].get(n) &gt; 1 || columns[j].get(n) &gt; 1 || boxes[box_index].get(n) &gt; 1) return false; &#125; &#125; &#125; return true; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// my preferred acclass Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; int[] row = new int[9]; int[] col = new int[9]; int[] cube = new int[9]; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != '.') &#123; if (row[board[i][j] - '1'] == 1) &#123; return false; &#125; else &#123; row[board[i][j] - '1'] = 1; &#125; &#125; if (board[j][i] != '.') &#123; if (col[board[j][i] - '1'] == 1) &#123; return false; &#125; else &#123; col[board[j][i] - '1'] = 1; &#125; &#125; // 每一宫内行列的变化 int cubeX = 3 * (i / 3) + j / 3; int cubeY = 3 * (i % 3) + j % 3; if (board[cubeX][cubeY] != '.') &#123; if (cube[board[cubeX][cubeY] - '1'] == 1) &#123; return false; &#125; else &#123; cube[board[cubeX][cubeY] - '1'] = 1; &#125; &#125; &#125; &#125; return true; &#125;&#125; 39. Combination SumMark Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations. Example 1:123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 2:1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); Arrays.sort(candidates);//貌似本身排好序的，加上无伤大雅 find(candidates, 0, result, tmp, target); return result; &#125; public void find(int[] candidates, int sIndex, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int target )&#123; if(target == 0)&#123; result.add(tmp); return ; &#125; if(target &lt; 0)&#123; return; &#125; for(int i = sIndex; i &lt; candidates.length; i++)&#123; List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(candidates[i]); find(candidates, i, result, tmpc, target - candidates[i]); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031// better answer ，利用数组替换List能够节省空间class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;(); int [] path=new int[100];//记录答案 int len=0; public void robot(int idx,int [] nums,int target)&#123;//idx是扫描到数组哪个数字 if(target==0)&#123; //拼答案,把记录在path里的数字拿出来 List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); for(int i=0;i&lt;len;i++)&#123; res.add(path[i]); &#125; ans.add(res); return; &#125; if(target&lt;0||idx&gt;=nums.length) return; //写递归,两种策略取和不取nums[idx] path[len]=nums[idx]; len++; robot(idx,nums,target-nums[idx]);//取但是idx不加1，因为下一次还可以取这个数 len--;//必须加这行，因为递归结束后不满足条件的数要从刚加入的删除掉，也就是指针回滚 robot(idx+1,nums,target);//不在取前面的数 &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; robot(0,candidates,target); return ans; &#125;&#125; 40. Combination Sum IIMark Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.Example 1:12345678Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Example 2:123456Input: candidates = [2,5,2,1,2], target = 5,A solution set is:[ [1,2,2], [5]] 1234567891011121314151617181920212223242526272829303132// my extreme difficult acclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); find(candidates, 0, result, tmp, target); return result; &#125; public void find(int[] candidates, int sidx, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int target)&#123; if(target ==0)&#123; result.add(tmp); return; &#125; if(target &lt; candidates[0])&#123;//相比小于0，能更快结束递归 return ; &#125; for(int i = sidx; i &lt; candidates.length &amp;&amp; candidates[i] &lt;= target; i++)&#123; /* if (i &gt; sidx &amp;&amp; candidates[i] == candidates[i-1])&#123;//达到的效果和后面while一样 continue; &#125;*/ List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(candidates[i]); find(candidates, i+1, result, tmpc, target - candidates[i]); while(i &lt; candidates.length -1 &amp;&amp; candidates[i] == candidates[i+1])&#123; i++; &#125; &#125; &#125;&#125; 43. Multiply StringsGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1:12Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot; Example 2:12Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// my acclass Solution &#123; public String multiply(String num1, String num2) &#123; if("0".equals(num1) || "0".equals(num2))return "0"; return bigMul(num1, num2).toString(); &#125; public StringBuilder bigMul(String num1, String num2)&#123; StringBuilder result = new StringBuilder(); // 先将字符串翻转，方便计算 String num1rev = new StringBuilder(num1).reverse().toString(); String num2rev = new StringBuilder(num2).reverse().toString(); for(int i = 0; i &lt; num1rev.length(); i++ )&#123; StringBuilder tmp = new StringBuilder(); int carry = 0; for(int count = 0; count &lt; i; count++)&#123; tmp.append("0"); &#125; int mul1 = num1rev.charAt(i) - '0'; for(int j = 0; j &lt; num2rev.length(); j++)&#123; int mul2 = num2rev.charAt(j) - '0'; int product = mul1 * mul2 + carry; carry = product /10; tmp.append(product % 10); &#125; if(carry &gt; 0)tmp.append(carry); result = bigAdd(result.toString(), tmp.reverse().toString()); &#125; return result; &#125; public StringBuilder bigAdd(String num1, String num2)&#123; StringBuilder result = new StringBuilder(); // 先将字符串翻转，方便计算 String num1rev = new StringBuilder(num1).reverse().toString(); String num2rev = new StringBuilder(num2).reverse().toString(); int carry = 0; int i = 0; for(i = 0; i &lt; num1rev.length() &amp;&amp; i&lt; num2rev.length(); i++)&#123; int add1 = num1rev.charAt(i) - '0'; int add2 = num2rev.charAt(i) - '0'; int sum = add1 + add2 +carry; carry = sum /10; result.append(sum %10); &#125; while(i &lt; num1rev.length())&#123; int add = num1rev.charAt(i) - '0'; int sum = add + carry; carry = sum /10; result.append(sum %10); i++; &#125; while(i &lt; num2rev.length())&#123; int add = num2rev.charAt(i) - '0'; int sum = add + carry; carry = sum /10; result.append(sum %10); i++; &#125; if(carry &gt;0)result.append(carry); return result.reverse(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536// better ac，利用数组处理结果能够良好节省计算过程空间和时间class Solution &#123; public String multiply(String num1, String num2) &#123; StringBuilder res = new StringBuilder(); char[] a = num1.toCharArray(); char[] b = num2.toCharArray(); if ((num1.length()==1&amp;&amp;num1.equals("0"))||(num2.length()==1&amp;&amp;num2.equals("0")))return "0"; //两数相乘最大不会超过两位相加的位数 int[] result = new int[a.length + b.length]; //两数倒向相乘 for (int i = a.length-1; i &gt;=0; i--) &#123; for (int j=b.length-1; j &gt;=0; j--) &#123; result[a.length-1-i + b.length-1-j]+= (a[i] - 48) * (b[j] - 48); &#125; &#125; for (int i = 0; i &lt; result.length - 1; i++) &#123; if (result[i] &gt;= 10) &#123; result[i + 1] += result[i] / 10; result[i] = result[i] % 10; &#125; &#125; //从前向后判断是否可以读取也就是第一位是不是为零 boolean juge = false; for (int i = result.length - 1; i &gt;= 0; i--) &#123; if (result[i] != 0) &#123; juge = true; &#125; if (juge) &#123; res.append(result[i]); &#125; &#125; return res.toString(); &#125;&#125; 46. PermutationsGiven a collection of distinct integers, return all possible permutations. Example:12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 1234567891011121314151617181920212223// my acclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); combine(result, tmp, nums); return result; &#125; public void combine(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int[] nums)&#123; if(tmp.size() == nums.length)&#123; result.add(tmp); return; &#125;else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tmp.contains(nums[i]))continue; List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(nums[i]); combine(result, tmpc, nums); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// seems better ac ? 利用数组记录该数是否已包含该数字，而不是用list判断class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; numList; private boolean[] isContain; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; numList = new ArrayList&lt;&gt;(); isContain = new boolean[nums.length]; for (int i = 0; i &lt; isContain.length; i++) &#123; isContain[i] = false; &#125; List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); getPermute(nums, 0 , integerList); return numList; &#125; /** * * @param nums * @param index * @param result */ private void getPermute(int[] nums, int index, List&lt;Integer&gt; result)&#123; if(index == nums.length)&#123; List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;(result); numList.add(tempList); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if(!isContain[i])&#123; result.add(nums[i]); isContain[i] = true; getPermute(nums, index + 1, result); //判断完后回溯 result.remove(result.size() - 1); isContain[i] = false; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// 不是很好理解 2ms/**每次将已经选过的数字换在前面去，如第n个数是nums[m],则将nums[m]和nums[n]互换未利用额外空间，同时只对数组进行操作*/class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if(nums ==null)return result; int len = nums.length; sortNums(nums, 0, len); return result; &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public void sortNums(int[] nums, int n, int len)&#123; List&lt;Integer&gt; list = new ArrayList(); if(len-1 ==n)&#123; for(int i =0; i &lt;len; i++)&#123; list.add(nums[i]); &#125; result.add(list); return; &#125; for(int j =n; j &lt;len; j++)&#123; swap(nums,n,j); sortNums(nums,n+1,len); swap(nums,n,j); //不还原，for不同次的循环使用的nums不同 &#125; &#125; public void swap(int[] nums, int n, int j)&#123; int temp = 0; temp = nums[n]; nums[n] = nums[j]; nums[j] = temp; &#125;&#125; 47. Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations. Example:1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 1234567891011121314151617181920212223242526272829// my ac,实验证明用数组记录是否已包含该数值会比用list.contains效果更好，因为前者可以定位到具体位置的数字，而不是判断值是否相等class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); List&lt;Integer&gt; tmp = new ArrayList(); boolean[] isContained = new boolean[nums.length]; combine(result, tmp, nums, isContained); return result; &#125; public void combine(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp, int[] nums, boolean[] isContained)&#123; if( tmp.size() == nums.length )&#123; result.add(tmp); return; &#125; for(int i = 0; i &lt; nums.length; i++)&#123; if(isContained[i])continue; List&lt;Integer&gt; tmpc = new ArrayList(tmp); tmpc.add(nums[i]); isContained[i] = true; combine(result, tmpc, nums, isContained); isContained[i] = false; while(i &lt; nums.length -1 &amp;&amp; nums[i] == nums[i+1])&#123; i++; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// 使用的回溯，相比之下，比我的方法能节约多次new ArrayList(tmp)的空间import java.util.Arrays;import java.util.List;import java.util.ArrayList;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (nums == null || nums.length == 0) &#123; return ret; &#125; Arrays.sort(nums); boolean[] visited = new boolean[nums.length]; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); dfs(nums, visited, list, ret); return ret; &#125; public void dfs(int[] nums, boolean[] visited, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (list.size() == nums.length) &#123; ret.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) &#123; continue; &#125; if (!visited[i]) &#123; list.add(nums[i]); visited[i] = true; dfs(nums, visited, list, ret); list.remove(list.size() - 1); visited[i] = false; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 和上一题一样，还是这货，用的换值的方法 3msclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); traceback(nums,0,nums.length-1,result); return result; &#125; private void traceback(int[] nums, int start, int length, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (start==length)&#123; List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); for (int num:nums) &#123; item.add(num); &#125; res.add(item); return; &#125; for (int i = start; i &lt;=length; i++) &#123; if(isDuplicate(nums,start,i))&#123; swap(nums,start,i); traceback(nums,start+1,length,res); swap(nums,start,i); &#125; &#125; &#125; private boolean isDuplicate(int[] nums, int start, int end) &#123; for (int j = start; j &lt;end; j++) &#123; if (nums[j]==nums[end])&#123; return false; &#125; &#125; return true; &#125; private void swap(int[] nums, int i, int start) &#123; int temp = nums[i]; nums[i] = nums[start]; nums[start] = temp; &#125;&#125; 48. Rotate ImageYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1:12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2:123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 123456789101112131415161718192021222324252627// my ac 2msclass Solution &#123; public void rotate(int[][] matrix) &#123; // 先逐行将数据倒转顺序 int sideLen = matrix.length; int evenOdd = sideLen %2; for(int row = 0; row &lt; matrix.length; row++)&#123; for(int col = 0; col &lt; matrix[0].length /2 + evenOdd; col ++)&#123; int tmp = matrix[row][col]; matrix[row][col] = matrix[row][sideLen - col -1] ; matrix[row][sideLen - col -1] = tmp; &#125; &#125; // 将数组matrix对折，matrix[i][j]与matrix[n-j][n-i] //将数组matrix对折，matrix[i][j]与matrix[j][i]交换为逆时针 for(int row = 0; row &lt; matrix.length ; row++)&#123; for(int col = 0; col &lt; sideLen - row ; col ++)&#123; int tmp = matrix[row][col]; matrix[row][col] = matrix[sideLen -1 - col][sideLen - row -1]; matrix[sideLen -1 - col][sideLen - row -1] = tmp; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728// shortest time 1msclass Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; float translate = (n - 1) / 2.0f; int last; int col, row;// 剥洋葱 for (int i = 0; i &lt; n / 2; i++) &#123; // 圈 for (int j = i; j &lt; n - i - 1; j++) &#123; // 边 last = matrix[i][j];// 为第一次交换存值 row = i; col = j; //加上后面三次，四条边，交换四次 for (int k = 0; k &lt; 3; k++) &#123; // 点// pre_point int pre_col = row; int pre_row = (int) (2 * translate - col); matrix[row][col] = matrix[pre_row][pre_col]; row = pre_row; col = pre_col; &#125; matrix[row][col] = last; &#125; &#125; &#125;&#125; 49. Group AnagramsGiven an array of strings, group anagrams together. Example:1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase. The order of your output does not matter. 1234567891011121314151617181920212223242526272829303132333435363738394041// my ac 1741msclass Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList(); if(strs.length == 0)return result; List&lt;String&gt; temp = new ArrayList(); temp.add(strs[0]); result.add(temp); for(int i = 1; i &lt; strs.length; i++)&#123; boolean added = false; for(int j = 0; j &lt; result.size(); j++)&#123; temp = result.get(j); if(compareString(temp.get(0), strs[i]))&#123; temp.add(strs[i]); added = true; &#125; &#125; if(!added)&#123; temp = new ArrayList(); temp.add(strs[i]); result.add(temp); &#125; &#125; return result; &#125; public boolean compareString(String a, String b)&#123; if(a.length() != b.length() ) return false; int[] countA = new int[26]; int[] countB = new int[26]; int len = a.length(); for(int i = 0; i &lt; len; i++)&#123; countA[a.charAt(i) - 'a'] ++; countB[b.charAt(i) - 'a'] ++; &#125; for(int i = 0; i &lt; 26; i++ )&#123; if(countA[i] != countB[i])return false; &#125; return true; &#125;&#125; 123456789101112131415161718192021222324252627282930// best acclass Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; //只有质数才能保证相乘的结果是真的唯一 int[] prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;;//最多10609个z List&lt;List&lt;String&gt;&gt; resultList = new ArrayList&lt;List&lt;String&gt;&gt;(); // // key = 唯一键值， value = resultList 中的 Key 的下标； HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (String s : strs) &#123; int key = 1; for (char c : s.toCharArray()) &#123;// 获得唯一Key key *= prime[c - 'a']; &#125; List&lt;String&gt; targetList; if (map.containsKey(key)) &#123; targetList = resultList.get(map.get(key)); &#125; else &#123; targetList = new ArrayList&lt;String&gt;(); resultList.add(targetList); map.put(key, resultList.size() - 1); &#125; targetList.add(s); &#125; return resultList; &#125;&#125; 50. Pow(x, n)Implement pow(x, n), which calculates x raised to the power n (xn). Example 1:12Input: 2.00000, 10Output: 1024.00000 Example 2:12Input: 2.10000, 3Output: 9.26100 Example 3:123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [$−2^{31}$, $2^{31}$ − 1] 1234567891011121314// 这道题的关键在于超时和效率class Solution &#123; public double myPow(double x, int n) &#123; double result = 1.0; for(int i = n; i != 0; i = i/2)&#123;//i==0时结束，n可能小于0，所以判断不等于0是最好的方式。 if(i%2 !=0)&#123; result *= x; &#125; x *= x; &#125; return n &gt; 0 ? result : 1.0/result; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-web项目建立及配置]]></title>
    <url>%2F2018%2F01%2F22%2FMaven-web%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[环境配置eclipse自带Maven一般在eclipse中自带maven通过Windows-&gt;Preference-&gt;Maven-&gt;Installations可以查看其中EMBEDDED为自带的版本，截图如下 图1 使用指定版本官网下载链接 : http://maven.apache.org/download.cgi对于Linux系统： 123456789101112131415sudo mkdir /opt/maven# 解压maven到指定目录sudo tar zxvf apache-maven-×.×.×-bin.tar.gz -C /opt/maven# 配置maven环境sudo gedit /etc/profile# 在文件内容后追加如下内容export M2_HOME=/opt/maven/apache-maven-3.5.0export CLASSPATH=$CLASSPATH:$M2_HOME/libexport PATH=$PATH:$M2_HOME/bin# 保存后使配置文件生效source /etc/profile# 运行以下指令以验证是否安装成功mvn -v# 修改maven源为阿里云及仓库存放路径，以加快下载速度sudo gedit /opt/maven/apache-maven-3.5.0/conf/settings.xml 123456789&lt;!-- 添加或修改 标签在home目录下生成对应文件夹maven/repository --&gt;&lt;localRepository&gt;maven/repository&lt;/localRepository&gt;&lt;!-- # 添加或修改 标签 以修改源 --&gt;&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 对于 Windows系统：1、下载对应版本文件2、解压到指定路径 如：D:\Program Files\Apache\maven3、配置环境变量：123456MAVEN_HOME:D:\Program Files\Apache\maven# 追加到Path变量如下内容（注意前面分号问题）%MAVEN_HOME%\bin\# 新开cmd窗口并验证mvn -v# 配置D:\Program Files\Apache\maven\conf\settings.xml 同Ubuntu 通过点击图1 Add 按钮添加指定版本，配置安装路径即可：图2至此，环境配置完成 新建maven项目通过New-&gt;Project 并输入maven，到如下界面：图3路径设置，一般使用默认，也可自己选择图4可以使用默认的archetype，也可自行添加archetype（该操作当前不详述）图5Group Id：唯一就好，个人项目随意Artifact Id：差不多就项目名的意思图6点击finish后项目路径分布如下：图7右击项目选择 Build Path-&gt;Configure Build Path:图8点击 Add Library，添加Server Runtime，如有需要可修改Jre System Library图9点击刷新，红色叉号就消失了。右击，运行，则在浏览器金收入 Hello World！ 页面至此 maven项目建立完成（关于修改 maven项目名，webapp版本暂不详述） 下载jar包在 图7 中可以看到 pom.xml 通过修改该文件并保存，maven会自动下载或添加对应jar包其初始内容如下：123456789101112131415161718192021&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.liang.maven&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;MavenTest Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;MavenTest&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 百度输入，maven进入其依赖查询官网 : https://mvnrepository.com/ 搜索 如：mysql 并在结果中点击第一个链接：图10点击后会进入版本选择页面，一般我选择使用人数最多的版本，如5.1.6图11点击对应版本链接后，会进入如下页面：图12将图中如下内容复制粘贴到 pom.xml 中的 dependencies 标签内：123456&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 粘贴后，pom.xml 内容如下：12345678910111213141516171819202122232425262728&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.liang.maven&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;MavenTest Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;MavenTest&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 点击保存，并等待下载完成，下载进度在Progress中查看，下载完成后，可在项目中查看相应jar包：图13在此项目基础之上，可以轻松下载想要的jar包（如果要拷贝jar包给其他人的话） Maven切换阿里云镜像源修改 $MAVEN_HOME/conf/settings.xml在中添加至如下1234567891011121314151617181920 &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt;&lt;mirror&gt; &lt;id&gt;AliMaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; &lt;/mirrors&gt; 在eclipse中 Window—&gt;Preference—&gt;Maven—&gt;User Settings 将user setting或者Global Settings路径只想settings.xml,再点击apply即可。settings.xml可以复制到其他路径，只要eclipse设置和settings.xml路径一一对应即可 Maven报错1Failure to transferorg.apache.maven.plugins:maven-surefire-plugin:pom: 报类似错，找到目录 ~/.m2/repository/org/apache/maven/plugins将该目录下所有文件都删除，然后右击项目 Maven—&gt;Update Project 即可其中 ~ 表示用户目录]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
</search>
